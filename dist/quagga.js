(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(factory.toString()).default;
	else if(typeof exports === 'object')
		exports["Quagga"] = factory(factory.toString()).default;
	else
		root["Quagga"] = factory(factory.toString()).default;
})(this, function(__factorySource__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 166);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_array_helper__ = __webpack_require__(3);


function BarcodeReader(config, supplements) {
    this._row = [];
    this.config = config || {};
    this.supplements = supplements;
    return this;
}

BarcodeReader.prototype._nextUnset = function (line, start) {
    var i;

    if (start === undefined) {
        start = 0;
    }
    for (i = start; i < line.length; i++) {
        if (!line[i]) {
            return i;
        }
    }
    return line.length;
};

BarcodeReader.prototype._matchPattern = function (counter, code, maxSingleError) {
    var i,
        error = 0,
        singleError = 0,
        sum = 0,
        modulo = 0,
        barWidth,
        count,
        scaled;

    maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

    for (i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
    }
    if (sum < modulo) {
        return Number.MAX_VALUE;
    }
    barWidth = sum / modulo;
    maxSingleError *= barWidth;

    for (i = 0; i < counter.length; i++) {
        count = counter[i];
        scaled = code[i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;
        if (singleError > maxSingleError) {
            return Number.MAX_VALUE;
        }
        error += singleError;
    }
    return error / modulo;
};

BarcodeReader.prototype._nextSet = function (line, offset) {
    var i;

    offset = offset || 0;
    for (i = offset; i < line.length; i++) {
        if (line[i]) {
            return i;
        }
    }
    return line.length;
};

BarcodeReader.prototype._correctBars = function (counter, correction, indices) {
    var length = indices.length,
        tmp = 0;
    while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);
        if (tmp > 1) {
            counter[indices[length]] = tmp;
        }
    }
};

BarcodeReader.prototype._matchTrace = function (cmpCounter, epsilon) {
    var counter = [],
        i,
        self = this,
        offset = self._nextSet(self._row),
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0
    },
        error;

    if (cmpCounter) {
        for (i = 0; i < cmpCounter.length; i++) {
            counter.push(0);
        }
        for (i = offset; i < self._row.length; i++) {
            if (self._row[i] ^ isWhite) {
                counter[counterPos]++;
            } else {
                if (counterPos === counter.length - 1) {
                    error = self._matchPattern(counter, cmpCounter);

                    if (error < epsilon) {
                        bestMatch.start = i - offset;
                        bestMatch.end = i;
                        bestMatch.counter = counter;
                        return bestMatch;
                    } else {
                        return null;
                    }
                } else {
                    counterPos++;
                }
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    } else {
        counter.push(0);
        for (i = offset; i < self._row.length; i++) {
            if (self._row[i] ^ isWhite) {
                counter[counterPos]++;
            } else {
                counterPos++;
                counter.push(0);
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    }

    // if cmpCounter was not given
    bestMatch.start = offset;
    bestMatch.end = self._row.length - 1;
    bestMatch.counter = counter;
    return bestMatch;
};

BarcodeReader.prototype.decodePattern = function (pattern) {
    var self = this,
        result;

    self._row = pattern;
    result = self._decode();
    if (result === null) {
        self._row.reverse();
        result = self._decode();
        if (result) {
            result.direction = BarcodeReader.DIRECTION.REVERSE;
            result.start = self._row.length - result.start;
            result.end = self._row.length - result.end;
        }
    } else {
        result.direction = BarcodeReader.DIRECTION.FORWARD;
    }
    if (result) {
        result.format = self.FORMAT;
    }
    return result;
};

BarcodeReader.prototype._matchRange = function (start, end, value) {
    var i;

    start = start < 0 ? 0 : start;
    for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
            return false;
        }
    }
    return true;
};

BarcodeReader.prototype._fillCounters = function (offset, end, isWhite) {
    var self = this,
        counterPos = 0,
        i,
        counters = [];

    isWhite = typeof isWhite !== 'undefined' ? isWhite : true;
    offset = typeof offset !== 'undefined' ? offset : self._nextUnset(self._row);
    end = end || self._row.length;

    counters[counterPos] = 0;
    for (i = offset; i < end; i++) {
        if (self._row[i] ^ isWhite) {
            counters[counterPos]++;
        } else {
            counterPos++;
            counters[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return counters;
};

BarcodeReader.prototype._toCounters = function (start, counter) {
    var self = this,
        numCounters = counter.length,
        end = self._row.length,
        isWhite = !self._row[start],
        i,
        counterPos = 0;

    __WEBPACK_IMPORTED_MODULE_0__common_array_helper__["a" /* default */].init(counter, 0);

    for (i = start; i < end; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            counterPos++;
            if (counterPos === numCounters) {
                break;
            } else {
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    }

    return counter;
};

Object.defineProperty(BarcodeReader.prototype, "FORMAT", {
    value: 'unknown',
    writeable: false
});

BarcodeReader.DIRECTION = {
    FORWARD: 1,
    REVERSE: -1
};

BarcodeReader.Exception = {
    StartNotFoundException: "Start-Info was not found!",
    CodeNotFoundException: "Code could not be found!",
    PatternNotFoundException: "Pattern could not be found!"
};

BarcodeReader.CONFIG_KEYS = {};

/* harmony default export */ __webpack_exports__["a"] = (BarcodeReader);

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
    init: function init(arr, val) {
        var l = arr.length;
        while (l--) {
            arr[l] = val;
        }
    },

    /**
     * Shuffles the content of an array
     * @return {Array} the array itself shuffled
     */
    shuffle: function shuffle(arr) {
        var i = arr.length - 1,
            j,
            x;
        for (i; i >= 0; i--) {
            j = Math.floor(Math.random() * i);
            x = arr[i];
            arr[i] = arr[j];
            arr[j] = x;
        }
        return arr;
    },

    toPointList: function toPointList(arr) {
        var i,
            j,
            row = [],
            rows = [];
        for (i = 0; i < arr.length; i++) {
            row = [];
            for (j = 0; j < arr[i].length; j++) {
                row[j] = arr[i][j];
            }
            rows[i] = "[" + row.join(",") + "]";
        }
        return "[" + rows.join(",\r\n") + "]";
    },

    /**
     * returns the elements which's score is bigger than the threshold
     * @return {Array} the reduced array
     */
    threshold: function threshold(arr, _threshold, scoreFunc) {
        var i,
            queue = [];
        for (i = 0; i < arr.length; i++) {
            if (scoreFunc.apply(arr, [arr[i]]) >= _threshold) {
                queue.push(arr[i]);
            }
        }
        return queue;
    },

    maxIndex: function maxIndex(arr) {
        var i,
            max = 0;
        for (i = 0; i < arr.length; i++) {
            if (arr[i] > arr[max]) {
                max = i;
            }
        }
        return max;
    },

    max: function max(arr) {
        var i,
            max = 0;
        for (i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    },

    sum: function sum(arr) {
        var length = arr.length,
            sum = 0;

        while (length--) {
            sum += arr[length];
        }
        return sum;
    }
});

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_merge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__barcode_reader__ = __webpack_require__(1);


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };




function EANReader(opts, supplements) {
    opts = __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default()(getDefaulConfig(), opts);
    __WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].call(this, opts, supplements);
}

function getDefaulConfig() {
    var config = {};

    Object.keys(EANReader.CONFIG_KEYS).forEach(function (key) {
        config[key] = EANReader.CONFIG_KEYS[key].default;
    });
    return config;
}

var properties = {
    CODE_L_START: { value: 0 },
    CODE_G_START: { value: 10 },
    START_PATTERN: { value: [1, 1, 1] },
    STOP_PATTERN: { value: [1, 1, 1] },
    MIDDLE_PATTERN: { value: [1, 1, 1, 1, 1] },
    EXTENSION_START_PATTERN: { value: [1, 1, 2] },
    CODE_PATTERN: { value: [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]] },
    CODE_FREQUENCY: { value: [0, 11, 13, 14, 19, 25, 28, 21, 22, 26] },
    SINGLE_CODE_ERROR: { value: 0.70 },
    AVG_CODE_ERROR: { value: 0.48 },
    FORMAT: { value: "ean_13", writeable: false }
};

EANReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].prototype, properties);
EANReader.prototype.constructor = EANReader;

EANReader.prototype._decodeCode = function (start, coderange) {
    var counter = [0, 0, 0, 0],
        i,
        self = this,
        offset = start,
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
    },
        code,
        error;

    if (!coderange) {
        coderange = self.CODE_PATTERN.length;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                for (code = 0; code < coderange; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                bestMatch.end = i;
                if (bestMatch.error > self.AVG_CODE_ERROR) {
                    return null;
                }
                return bestMatch;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

EANReader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder, epsilon) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    if (isWhite === undefined) {
        isWhite = false;
    }

    if (tryHarder === undefined) {
        tryHarder = true;
    }

    if (epsilon === undefined) {
        epsilon = self.AVG_CODE_ERROR;
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);

                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

EANReader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset);
        if (!startInfo) {
            return null;
        }
        leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

EANReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

EANReader.prototype._findEnd = function (offset, isWhite) {
    var self = this,
        endInfo = self._findPattern(self.STOP_PATTERN, offset, isWhite, false);

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

EANReader.prototype._calculateFirstDigit = function (codeFrequency) {
    var i,
        self = this;

    for (i = 0; i < self.CODE_FREQUENCY.length; i++) {
        if (codeFrequency === self.CODE_FREQUENCY[i]) {
            return i;
        }
    }
    return null;
};

EANReader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this,
        codeFrequency = 0x0,
        firstDigit;

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end);
        if (!code) {
            return null;
        }
        if (code.code >= self.CODE_G_START) {
            code.code = code.code - self.CODE_G_START;
            codeFrequency |= 1 << 5 - i;
        } else {
            codeFrequency |= 0 << 5 - i;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }

    firstDigit = self._calculateFirstDigit(codeFrequency);
    if (firstDigit === null) {
        return null;
    }
    result.unshift(firstDigit);

    code = self._findPattern(self.MIDDLE_PATTERN, code.end, true, false);
    if (code === null) {
        return null;
    }
    decodedCodes.push(code);

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
    }

    return code;
};

EANReader.prototype._decode = function () {
    var startInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        resultInfo = {};

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end
    };
    decodedCodes.push(code);
    code = self._decodePayload(code, result, decodedCodes);
    if (!code) {
        return null;
    }
    code = self._findEnd(code.end, false);
    if (!code) {
        return null;
    }

    decodedCodes.push(code);

    // Checksum
    if (!self._checksum(result)) {
        return null;
    }

    if (this.supplements.length > 0) {
        var ext = this._decodeExtensions(code.end);
        if (!ext) {
            return null;
        }
        var lastCode = ext.decodedCodes[ext.decodedCodes.length - 1],
            endInfo = {
            start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
            end: lastCode.end
        };
        if (!self._verifyTrailingWhitespace(endInfo)) {
            return null;
        }
        resultInfo = {
            supplement: ext,
            code: result.join("") + ext.code
        };
    }

    return _extends({
        code: result.join(""),
        start: startInfo.start,
        end: code.end,
        codeset: "",
        startInfo: startInfo,
        decodedCodes: decodedCodes
    }, resultInfo);
};

EANReader.prototype._decodeExtensions = function (offset) {
    var i,
        start = this._nextSet(this._row, offset),
        startInfo = this._findPattern(this.EXTENSION_START_PATTERN, start, false, false),
        result;

    if (startInfo === null) {
        return null;
    }

    for (i = 0; i < this.supplements.length; i++) {
        result = this.supplements[i].decode(this._row, startInfo.end);
        if (result !== null) {
            return {
                code: result.code,
                start: start,
                startInfo: startInfo,
                end: result.end,
                codeset: "",
                decodedCodes: result.decodedCodes
            };
        }
    }
    return null;
};

EANReader.prototype._checksum = function (result) {
    var sum = 0,
        i;

    for (i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    for (i = result.length - 1; i >= 0; i -= 2) {
        sum += result[i];
    }
    return sum % 10 === 0;
};

EANReader.CONFIG_KEYS = {
    supplements: {
        'type': 'arrayOf(string)',
        'default': [],
        'description': 'Allowed extensions to be decoded (2 and/or 5)'
    }
};

/* harmony default export */ __webpack_exports__["a"] = (EANReader);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(38);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = clone

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
    var out = new Float32Array(2)
    out[0] = a[0]
    out[1] = a[1]
    return out
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    getRawTag = __webpack_require__(119),
    objectToString = __webpack_require__(146);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
    drawRect: function drawRect(pos, size, ctx, style) {
        ctx.strokeStyle = style.color;
        ctx.fillStyle = style.color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.strokeRect(pos.x, pos.y, size.x, size.y);
    },
    drawPath: function drawPath(path, def, ctx, style) {
        ctx.strokeStyle = style.color;
        ctx.fillStyle = style.color;
        ctx.lineWidth = style.lineWidth;
        ctx.beginPath();
        ctx.moveTo(path[0][def.x], path[0][def.y]);
        for (var j = 1; j < path.length; j++) {
            ctx.lineTo(path[j][def.x], path[j][def.y]);
        }
        ctx.closePath();
        ctx.stroke();
    },
    drawImage: function drawImage(imageData, size, ctx) {
        var canvasData = ctx.getImageData(0, 0, size.x, size.y),
            data = canvasData.data,
            imageDataPos = imageData.length,
            canvasDataPos = data.length,
            value;

        if (canvasDataPos / imageDataPos !== 4) {
            return false;
        }
        while (imageDataPos--) {
            value = imageData[imageDataPos];
            data[--canvasDataPos] = 255;
            data[--canvasDataPos] = value;
            data[--canvasDataPos] = value;
            data[--canvasDataPos] = value;
        }
        ctx.putImageData(canvasData, 0, 0);
        return true;
    }
});

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(133),
    listCacheDelete = __webpack_require__(134),
    listCacheGet = __webpack_require__(135),
    listCacheHas = __webpack_require__(136),
    listCacheSet = __webpack_require__(137);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(17);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(2),
    isKey = __webpack_require__(130),
    stringToPath = __webpack_require__(154),
    toString = __webpack_require__(165);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(131);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(96),
    isObjectLike = __webpack_require__(6);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = imageRef;
/* unused harmony export computeIntegralImage2 */
/* unused harmony export computeIntegralImage */
/* unused harmony export thresholdImage */
/* unused harmony export computeHistogram */
/* unused harmony export sharpenLine */
/* unused harmony export determineOtsuThreshold */
/* harmony export (immutable) */ __webpack_exports__["f"] = otsuThreshold;
/* unused harmony export computeBinaryImage */
/* harmony export (immutable) */ __webpack_exports__["g"] = cluster;
/* unused harmony export Tracer */
/* unused harmony export DILATE */
/* unused harmony export ERODE */
/* unused harmony export dilate */
/* unused harmony export erode */
/* unused harmony export subtract */
/* unused harmony export bitwiseOr */
/* unused harmony export countNonZero */
/* harmony export (immutable) */ __webpack_exports__["h"] = topGeneric;
/* unused harmony export grayArrayFromImage */
/* unused harmony export grayArrayFromContext */
/* harmony export (immutable) */ __webpack_exports__["c"] = grayAndHalfSampleFromCanvasData;
/* harmony export (immutable) */ __webpack_exports__["d"] = computeGray;
/* unused harmony export loadImageArray */
/* harmony export (immutable) */ __webpack_exports__["i"] = halfSample;
/* harmony export (immutable) */ __webpack_exports__["a"] = hsv2rgb;
/* unused harmony export _computeDivisors */
/* harmony export (immutable) */ __webpack_exports__["e"] = calculatePatchSize;
/* unused harmony export _parseCSSDimensionValues */
/* unused harmony export _dimensionsConverters */
/* harmony export (immutable) */ __webpack_exports__["j"] = computeImageArea;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cluster__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array_helper__ = __webpack_require__(3);


var vec2 = {
    clone: __webpack_require__(7)
};
var vec3 = {
    clone: __webpack_require__(83)
};

/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */
function imageRef(x, y) {
    var that = {
        x: x,
        y: y,
        toVec2: function toVec2() {
            return vec2.clone([this.x, this.y]);
        },
        toVec3: function toVec3() {
            return vec3.clone([this.x, this.y, 1]);
        },
        round: function round() {
            this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
            this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
            return this;
        }
    };
    return that;
};

/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */
function computeIntegralImage2(imageWrapper, integralWrapper) {
    var imageData = imageWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0,
        posA = 0,
        posB = 0,
        posC = 0,
        posD = 0,
        x,
        y;

    // sum up first column
    posB = width;
    sum = 0;
    for (y = 1; y < height; y++) {
        sum += imageData[posA];
        integralImageData[posB] += sum;
        posA += width;
        posB += width;
    }

    posA = 0;
    posB = 1;
    sum = 0;
    for (x = 1; x < width; x++) {
        sum += imageData[posA];
        integralImageData[posB] += sum;
        posA++;
        posB++;
    }

    for (y = 1; y < height; y++) {
        posA = y * width + 1;
        posB = (y - 1) * width + 1;
        posC = y * width;
        posD = (y - 1) * width;
        for (x = 1; x < width; x++) {
            integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
            posA++;
            posB++;
            posC++;
            posD++;
        }
    }
};

function computeIntegralImage(imageWrapper, integralWrapper) {
    var imageData = imageWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0;

    // sum up first row
    for (var i = 0; i < width; i++) {
        sum += imageData[i];
        integralImageData[i] = sum;
    }

    for (var v = 1; v < height; v++) {
        sum = 0;
        for (var u = 0; u < width; u++) {
            sum += imageData[v * width + u];
            integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
        }
    }
};

function thresholdImage(imageWrapper, threshold, targetWrapper) {
    if (!targetWrapper) {
        targetWrapper = imageWrapper;
    }
    var imageData = imageWrapper.data,
        length = imageData.length,
        targetData = targetWrapper.data;

    while (length--) {
        targetData[length] = imageData[length] < threshold ? 1 : 0;
    }
};

function computeHistogram(imageWrapper, bitsPerPixel) {
    if (!bitsPerPixel) {
        bitsPerPixel = 8;
    }
    var imageData = imageWrapper.data,
        length = imageData.length,
        bitShift = 8 - bitsPerPixel,
        bucketCnt = 1 << bitsPerPixel,
        hist = new Int32Array(bucketCnt);

    while (length--) {
        hist[imageData[length] >> bitShift]++;
    }
    return hist;
};

function sharpenLine(line) {
    var i,
        length = line.length,
        left = line[0],
        center = line[1],
        right;

    for (i = 1; i < length - 1; i++) {
        right = line[i + 1];
        //  -1 4 -1 kernel
        line[i - 1] = center * 2 - left - right & 255;
        left = center;
        center = right;
    }
    return line;
};

function determineOtsuThreshold(imageWrapper, bitsPerPixel) {
    if (!bitsPerPixel) {
        bitsPerPixel = 8;
    }
    var hist,
        threshold,
        bitShift = 8 - bitsPerPixel;

    function px(init, end) {
        var sum = 0,
            i;
        for (i = init; i <= end; i++) {
            sum += hist[i];
        }
        return sum;
    }

    function mx(init, end) {
        var i,
            sum = 0;

        for (i = init; i <= end; i++) {
            sum += i * hist[i];
        }

        return sum;
    }

    function determineThreshold() {
        var vet = [0],
            p1,
            p2,
            p12,
            k,
            m1,
            m2,
            m12,
            max = (1 << bitsPerPixel) - 1;

        hist = computeHistogram(imageWrapper, bitsPerPixel);
        for (k = 1; k < max; k++) {
            p1 = px(0, k);
            p2 = px(k + 1, max);
            p12 = p1 * p2;
            if (p12 === 0) {
                p12 = 1;
            }
            m1 = mx(0, k) * p2;
            m2 = mx(k + 1, max) * p1;
            m12 = m1 - m2;
            vet[k] = m12 * m12 / p12;
        }
        return __WEBPACK_IMPORTED_MODULE_1__array_helper__["a" /* default */].maxIndex(vet);
    }

    threshold = determineThreshold();
    return threshold << bitShift;
};

function otsuThreshold(imageWrapper, targetWrapper) {
    var threshold = determineOtsuThreshold(imageWrapper);

    thresholdImage(imageWrapper, threshold, targetWrapper);
    return threshold;
};

// local thresholding
function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
    computeIntegralImage(imageWrapper, integralWrapper);

    if (!targetWrapper) {
        targetWrapper = imageWrapper;
    }
    var imageData = imageWrapper.data;
    var targetData = targetWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0,
        v,
        u,
        kernel = 3,
        A,
        B,
        C,
        D,
        avg,
        size = (kernel * 2 + 1) * (kernel * 2 + 1);

    // clear out top & bottom-border
    for (v = 0; v <= kernel; v++) {
        for (u = 0; u < width; u++) {
            targetData[v * width + u] = 0;
            targetData[(height - 1 - v) * width + u] = 0;
        }
    }

    // clear out left & right border
    for (v = kernel; v < height - kernel; v++) {
        for (u = 0; u <= kernel; u++) {
            targetData[v * width + u] = 0;
            targetData[v * width + (width - 1 - u)] = 0;
        }
    }

    for (v = kernel + 1; v < height - kernel - 1; v++) {
        for (u = kernel + 1; u < width - kernel; u++) {
            A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
            B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
            C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
            D = integralImageData[(v + kernel) * width + (u + kernel)];
            sum = D - C - B + A;
            avg = sum / size;
            targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
        }
    }
};

function cluster(points, threshold, property) {
    var i,
        k,
        cluster,
        point,
        clusters = [];

    if (!property) {
        property = "rad";
    }

    function addToCluster(newPoint) {
        var found = false;
        for (k = 0; k < clusters.length; k++) {
            cluster = clusters[k];
            if (cluster.fits(newPoint)) {
                cluster.add(newPoint);
                found = true;
            }
        }
        return found;
    }

    // iterate over each cloud
    for (i = 0; i < points.length; i++) {
        point = __WEBPACK_IMPORTED_MODULE_0__cluster__["a" /* default */].createPoint(points[i], i, property);
        if (!addToCluster(point)) {
            clusters.push(__WEBPACK_IMPORTED_MODULE_0__cluster__["a" /* default */].create(point, threshold));
        }
    }
    return clusters;
};

var Tracer = {
    trace: function trace(points, vec) {
        var iteration,
            maxIterations = 10,
            top = [],
            result = [],
            centerPos = 0,
            currentPos = 0;

        function trace(idx, forward) {
            var from,
                to,
                toIdx,
                predictedPos,
                thresholdX = 1,
                thresholdY = Math.abs(vec[1] / 10),
                found = false;

            function match(pos, predicted) {
                if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
                    return true;
                } else {
                    return false;
                }
            }

            // check if the next index is within the vec specifications
            // if not, check as long as the threshold is met

            from = points[idx];
            if (forward) {
                predictedPos = {
                    x: from.x + vec[0],
                    y: from.y + vec[1]
                };
            } else {
                predictedPos = {
                    x: from.x - vec[0],
                    y: from.y - vec[1]
                };
            }

            toIdx = forward ? idx + 1 : idx - 1;
            to = points[toIdx];
            while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
                toIdx = forward ? toIdx + 1 : toIdx - 1;
                to = points[toIdx];
            }

            return found ? toIdx : null;
        }

        for (iteration = 0; iteration < maxIterations; iteration++) {
            // randomly select point to start with
            centerPos = Math.floor(Math.random() * points.length);

            // trace forward
            top = [];
            currentPos = centerPos;
            top.push(points[currentPos]);
            while ((currentPos = trace(currentPos, true)) !== null) {
                top.push(points[currentPos]);
            }
            if (centerPos > 0) {
                currentPos = centerPos;
                while ((currentPos = trace(currentPos, false)) !== null) {
                    top.push(points[currentPos]);
                }
            }

            if (top.length > result.length) {
                result = top;
            }
        }
        return result;
    }
};

var DILATE = 1;
var ERODE = 2;

function dilate(inImageWrapper, outImageWrapper) {
    var v,
        u,
        inImageData = inImageWrapper.data,
        outImageData = outImageWrapper.data,
        height = inImageWrapper.size.y,
        width = inImageWrapper.size.x,
        sum,
        yStart1,
        yStart2,
        xStart1,
        xStart2;

    for (v = 1; v < height - 1; v++) {
        for (u = 1; u < width - 1; u++) {
            yStart1 = v - 1;
            yStart2 = v + 1;
            xStart1 = u - 1;
            xStart2 = u + 1;
            sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
            outImageData[v * width + u] = sum > 0 ? 1 : 0;
        }
    }
};

function erode(inImageWrapper, outImageWrapper) {
    var v,
        u,
        inImageData = inImageWrapper.data,
        outImageData = outImageWrapper.data,
        height = inImageWrapper.size.y,
        width = inImageWrapper.size.x,
        sum,
        yStart1,
        yStart2,
        xStart1,
        xStart2;

    for (v = 1; v < height - 1; v++) {
        for (u = 1; u < width - 1; u++) {
            yStart1 = v - 1;
            yStart2 = v + 1;
            xStart1 = u - 1;
            xStart2 = u + 1;
            sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
            outImageData[v * width + u] = sum === 5 ? 1 : 0;
        }
    }
};

function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
    if (!resultImageWrapper) {
        resultImageWrapper = aImageWrapper;
    }
    var length = aImageWrapper.data.length,
        aImageData = aImageWrapper.data,
        bImageData = bImageWrapper.data,
        cImageData = resultImageWrapper.data;

    while (length--) {
        cImageData[length] = aImageData[length] - bImageData[length];
    }
};

function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
    if (!resultImageWrapper) {
        resultImageWrapper = aImageWrapper;
    }
    var length = aImageWrapper.data.length,
        aImageData = aImageWrapper.data,
        bImageData = bImageWrapper.data,
        cImageData = resultImageWrapper.data;

    while (length--) {
        cImageData[length] = aImageData[length] || bImageData[length];
    }
};

function countNonZero(imageWrapper) {
    var length = imageWrapper.data.length,
        data = imageWrapper.data,
        sum = 0;

    while (length--) {
        sum += data[length];
    }
    return sum;
};

function topGeneric(list, top, scoreFunc) {
    var i,
        minIdx = 0,
        min = 0,
        queue = [],
        score,
        hit,
        pos;

    for (i = 0; i < top; i++) {
        queue[i] = {
            score: 0,
            item: null
        };
    }

    for (i = 0; i < list.length; i++) {
        score = scoreFunc.apply(this, [list[i]]);
        if (score > min) {
            hit = queue[minIdx];
            hit.score = score;
            hit.item = list[i];
            min = Number.MAX_VALUE;
            for (pos = 0; pos < top; pos++) {
                if (queue[pos].score < min) {
                    min = queue[pos].score;
                    minIdx = pos;
                }
            }
        }
    }

    return queue;
};

function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
    ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
    var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
    computeGray(ctxData, array);
};

function grayArrayFromContext(ctx, size, offset, array) {
    var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
    computeGray(ctxData, array);
};

function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
    var topRowIdx = 0;
    var bottomRowIdx = size.x;
    var endIdx = Math.floor(canvasData.length / 4);
    var outWidth = size.x / 2;
    var outImgIdx = 0;
    var inWidth = size.x;
    var i;

    while (bottomRowIdx < endIdx) {
        for (i = 0; i < outWidth; i++) {
            outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
            outImgIdx++;
            topRowIdx = topRowIdx + 2;
            bottomRowIdx = bottomRowIdx + 2;
        }
        topRowIdx = topRowIdx + inWidth;
        bottomRowIdx = bottomRowIdx + inWidth;
    }
};

function computeGray(imageData, outArray, config) {
    var l = imageData.length / 4 | 0,
        i,
        singleChannel = config && config.singleChannel === true;

    if (singleChannel) {
        for (i = 0; i < l; i++) {
            outArray[i] = imageData[i * 4 + 0];
        }
    } else {
        for (i = 0; i < l; i++) {
            outArray[i] = 0.299 * imageData[i * 4 + 0] + 0.587 * imageData[i * 4 + 1] + 0.114 * imageData[i * 4 + 2];
        }
    }
};

function loadImageArray(src, callback, canvas) {
    if (!canvas) {
        canvas = document.createElement('canvas');
    }
    var img = new Image();
    img.callback = callback;
    img.onload = function () {
        canvas.width = this.width;
        canvas.height = this.height;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(this, 0, 0);
        var array = new Uint8Array(this.width * this.height);
        ctx.drawImage(this, 0, 0);
        var data = ctx.getImageData(0, 0, this.width, this.height).data;
        computeGray(data, array);
        this.callback(array, {
            x: this.width,
            y: this.height
        }, this);
    };
    img.src = src;
};

/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */
function halfSample(inImgWrapper, outImgWrapper) {
    var inImg = inImgWrapper.data;
    var inWidth = inImgWrapper.size.x;
    var outImg = outImgWrapper.data;
    var topRowIdx = 0;
    var bottomRowIdx = inWidth;
    var endIdx = inImg.length;
    var outWidth = inWidth / 2;
    var outImgIdx = 0;
    while (bottomRowIdx < endIdx) {
        for (var i = 0; i < outWidth; i++) {
            outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
            outImgIdx++;
            topRowIdx = topRowIdx + 2;
            bottomRowIdx = bottomRowIdx + 2;
        }
        topRowIdx = topRowIdx + inWidth;
        bottomRowIdx = bottomRowIdx + inWidth;
    }
};

function hsv2rgb(hsv, rgb) {
    var h = hsv[0],
        s = hsv[1],
        v = hsv[2],
        c = v * s,
        x = c * (1 - Math.abs(h / 60 % 2 - 1)),
        m = v - c,
        r = 0,
        g = 0,
        b = 0;

    rgb = rgb || [0, 0, 0];

    if (h < 60) {
        r = c;
        g = x;
    } else if (h < 120) {
        r = x;
        g = c;
    } else if (h < 180) {
        g = c;
        b = x;
    } else if (h < 240) {
        g = x;
        b = c;
    } else if (h < 300) {
        r = x;
        b = c;
    } else if (h < 360) {
        r = c;
        b = x;
    }
    rgb[0] = (r + m) * 255 | 0;
    rgb[1] = (g + m) * 255 | 0;
    rgb[2] = (b + m) * 255 | 0;
    return rgb;
};

function _computeDivisors(n) {
    var largeDivisors = [],
        divisors = [],
        i;

    for (i = 1; i < Math.sqrt(n) + 1; i++) {
        if (n % i === 0) {
            divisors.push(i);
            if (i !== n / i) {
                largeDivisors.unshift(Math.floor(n / i));
            }
        }
    }
    return divisors.concat(largeDivisors);
};

function _computeIntersection(arr1, arr2) {
    var i = 0,
        j = 0,
        result = [];

    while (i < arr1.length && j < arr2.length) {
        if (arr1[i] === arr2[j]) {
            result.push(arr1[i]);
            i++;
            j++;
        } else if (arr1[i] > arr2[j]) {
            j++;
        } else {
            i++;
        }
    }
    return result;
};

function calculatePatchSize(patchSize, imgSize) {
    var divisorsX = _computeDivisors(imgSize.x),
        divisorsY = _computeDivisors(imgSize.y),
        wideSide = Math.max(imgSize.x, imgSize.y),
        common = _computeIntersection(divisorsX, divisorsY),
        nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80],
        nrOfPatchesMap = {
        "x-small": 5,
        "small": 4,
        "medium": 3,
        "large": 2,
        "x-large": 1
    },
        nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium,
        nrOfPatches = nrOfPatchesList[nrOfPatchesIdx],
        desiredPatchSize = Math.floor(wideSide / nrOfPatches),
        optimalPatchSize;

    function findPatchSizeForDivisors(divisors) {
        var i = 0,
            found = divisors[Math.floor(divisors.length / 2)];

        while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
            i++;
        }
        if (i > 0) {
            if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
                found = divisors[i - 1];
            } else {
                found = divisors[i];
            }
        }
        if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
            return { x: found, y: found };
        }
        return null;
    }

    optimalPatchSize = findPatchSizeForDivisors(common);
    if (!optimalPatchSize) {
        optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));
        if (!optimalPatchSize) {
            optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
        }
    }
    return optimalPatchSize;
};

function _parseCSSDimensionValues(value) {
    var dimension = {
        value: parseFloat(value),
        unit: value.indexOf("%") === value.length - 1 ? "%" : "%"
    };

    return dimension;
};

var _dimensionsConverters = {
    top: function top(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.height * (dimension.value / 100));
        }
    },
    right: function right(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.width - context.width * (dimension.value / 100));
        }
    },
    bottom: function bottom(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.height - context.height * (dimension.value / 100));
        }
    },
    left: function left(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.width * (dimension.value / 100));
        }
    }
};

function computeImageArea(inputWidth, inputHeight, area) {
    var context = { width: inputWidth, height: inputHeight };

    var parsedArea = Object.keys(area).reduce(function (result, key) {
        var value = area[key],
            parsed = _parseCSSDimensionValues(value),
            calculated = _dimensionsConverters[key](parsed, context);

        result[key] = calculated;
        return result;
    }, {});

    return {
        sx: parsedArea.left,
        sy: parsedArea.top,
        sw: parsedArea.right - parsedArea.left,
        sh: parsedArea.bottom - parsedArea.top
    };
};

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__subImage__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_cv_utils__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_array_helper__ = __webpack_require__(3);



var vec2 = {
    clone: __webpack_require__(7)
};

/**
 * Represents a basic image combining the data and size.
 * In addition, some methods for manipulation are contained.
 * @param size {x,y} The size of the image in pixel
 * @param data {Array} If given, a flat array containing the pixel data
 * @param ArrayType {Type} If given, the desired DataType of the Array (may be typed/non-typed)
 * @param initialize {Boolean} Indicating if the array should be initialized on creation.
 * @returns {ImageWrapper}
 */
function ImageWrapper(size, data, ArrayType, initialize) {
    if (!data) {
        if (ArrayType) {
            this.data = new ArrayType(size.x * size.y);
            if (ArrayType === Array && initialize) {
                __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(this.data, 0);
            }
        } else {
            this.data = new Uint8Array(size.x * size.y);
            if (Uint8Array === Array && initialize) {
                __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(this.data, 0);
            }
        }
    } else {
        this.data = data;
    }
    this.size = size;
}

/**
 * tests if a position is within the image with a given offset
 * @param imgRef {x, y} The location to test
 * @param border Number the padding value in pixel
 * @returns {Boolean} true if location inside the image's border, false otherwise
 * @see cvd/image.h
 */
ImageWrapper.prototype.inImageWithBorder = function (imgRef, border) {
    return imgRef.x >= border && imgRef.y >= border && imgRef.x < this.size.x - border && imgRef.y < this.size.y - border;
};

/**
 * Performs bilinear sampling
 * @param inImg Image to extract sample from
 * @param x the x-coordinate
 * @param y the y-coordinate
 * @returns the sampled value
 * @see cvd/vision.h
 */
ImageWrapper.sample = function (inImg, x, y) {
    var lx = Math.floor(x);
    var ly = Math.floor(y);
    var w = inImg.size.x;
    var base = ly * inImg.size.x + lx;
    var a = inImg.data[base + 0];
    var b = inImg.data[base + 1];
    var c = inImg.data[base + w];
    var d = inImg.data[base + w + 1];
    var e = a - b;
    x -= lx;
    y -= ly;

    var result = Math.floor(x * (y * (e - c + d) - e) + y * (c - a) + a);
    return result;
};

/**
 * Initializes a given array. Sets each element to zero.
 * @param array {Array} The array to initialize
 */
ImageWrapper.clearArray = function (array) {
    var l = array.length;
    while (l--) {
        array[l] = 0;
    }
};

/**
 * Creates a {SubImage} from the current image ({this}).
 * @param from {ImageRef} The position where to start the {SubImage} from. (top-left corner)
 * @param size {ImageRef} The size of the resulting image
 * @returns {SubImage} A shared part of the original image
 */
ImageWrapper.prototype.subImage = function (from, size) {
    return new __WEBPACK_IMPORTED_MODULE_0__subImage__["a" /* default */](from, size, this);
};

/**
 * Creates an {ImageWrapper) and copies the needed underlying image-data area
 * @param imageWrapper {ImageWrapper} The target {ImageWrapper} where the data should be copied
 * @param from {ImageRef} The location where to copy from (top-left location)
 */
ImageWrapper.prototype.subImageAsCopy = function (imageWrapper, from) {
    var sizeY = imageWrapper.size.y,
        sizeX = imageWrapper.size.x;
    var x, y;
    for (x = 0; x < sizeX; x++) {
        for (y = 0; y < sizeY; y++) {
            imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
    }
};

ImageWrapper.prototype.copyTo = function (imageWrapper) {
    var length = this.data.length,
        srcData = this.data,
        dstData = imageWrapper.data;

    while (length--) {
        dstData[length] = srcData[length];
    }
};

/**
 * Retrieves a given pixel position from the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
ImageWrapper.prototype.get = function (x, y) {
    return this.data[y * this.size.x + x];
};

/**
 * Retrieves a given pixel position from the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
ImageWrapper.prototype.getSafe = function (x, y) {
    var i;

    if (!this.indexMapping) {
        this.indexMapping = {
            x: [],
            y: []
        };
        for (i = 0; i < this.size.x; i++) {
            this.indexMapping.x[i] = i;
            this.indexMapping.x[i + this.size.x] = i;
        }
        for (i = 0; i < this.size.y; i++) {
            this.indexMapping.y[i] = i;
            this.indexMapping.y[i + this.size.y] = i;
        }
    }
    return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
};

/**
 * Sets a given pixel position in the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @param value {Number} The grayscale value to set
 * @returns {ImageWrapper} The Image itself (for possible chaining)
 */
ImageWrapper.prototype.set = function (x, y, value) {
    this.data[y * this.size.x + x] = value;
    return this;
};

/**
 * Sets the border of the image (1 pixel) to zero
 */
ImageWrapper.prototype.zeroBorder = function () {
    var i,
        width = this.size.x,
        height = this.size.y,
        data = this.data;
    for (i = 0; i < width; i++) {
        data[i] = data[(height - 1) * width + i] = 0;
    }
    for (i = 1; i < height - 1; i++) {
        data[i * width] = data[i * width + (width - 1)] = 0;
    }
};

/**
 * Inverts a binary image in place
 */
ImageWrapper.prototype.invert = function () {
    var data = this.data,
        length = data.length;

    while (length--) {
        data[length] = data[length] ? 0 : 1;
    }
};

ImageWrapper.prototype.convolve = function (kernel) {
    var x,
        y,
        kx,
        ky,
        kSize = kernel.length / 2 | 0,
        accu = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            accu = 0;
            for (ky = -kSize; ky <= kSize; ky++) {
                for (kx = -kSize; kx <= kSize; kx++) {
                    accu += kernel[ky + kSize][kx + kSize] * this.getSafe(x + kx, y + ky);
                }
            }
            this.data[y * this.size.x + x] = accu;
        }
    }
};

ImageWrapper.prototype.moments = function (labelcount) {
    var data = this.data,
        x,
        y,
        height = this.size.y,
        width = this.size.x,
        val,
        ysq,
        labelsum = [],
        i,
        label,
        mu11,
        mu02,
        mu20,
        x_,
        y_,
        tmp,
        result = [],
        PI = Math.PI,
        PI_4 = PI / 4;

    if (labelcount <= 0) {
        return result;
    }

    for (i = 0; i < labelcount; i++) {
        labelsum[i] = {
            m00: 0,
            m01: 0,
            m10: 0,
            m11: 0,
            m02: 0,
            m20: 0,
            theta: 0,
            rad: 0
        };
    }

    for (y = 0; y < height; y++) {
        ysq = y * y;
        for (x = 0; x < width; x++) {
            val = data[y * width + x];
            if (val > 0) {
                label = labelsum[val - 1];
                label.m00 += 1;
                label.m01 += y;
                label.m10 += x;
                label.m11 += x * y;
                label.m02 += ysq;
                label.m20 += x * x;
            }
        }
    }

    for (i = 0; i < labelcount; i++) {
        label = labelsum[i];
        if (!isNaN(label.m00) && label.m00 !== 0) {
            x_ = label.m10 / label.m00;
            y_ = label.m01 / label.m00;
            mu11 = label.m11 / label.m00 - x_ * y_;
            mu02 = label.m02 / label.m00 - y_ * y_;
            mu20 = label.m20 / label.m00 - x_ * x_;
            tmp = (mu02 - mu20) / (2 * mu11);
            tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI;
            label.theta = (tmp * 180 / PI + 90) % 180 - 90;
            if (label.theta < 0) {
                label.theta += 180;
            }
            label.rad = tmp > PI ? tmp - PI : tmp;
            label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
            result.push(label);
        }
    }

    return result;
};

/**
 * Displays the {ImageWrapper} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
ImageWrapper.prototype.show = function (canvas, scale) {
    var ctx, frame, data, current, pixel, x, y;

    if (!scale) {
        scale = 1.0;
    }
    ctx = canvas.getContext('2d');
    canvas.width = this.size.x;
    canvas.height = this.size.y;
    frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    data = frame.data;
    current = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            pixel = y * this.size.x + x;
            current = this.get(x, y) * scale;
            data[pixel * 4 + 0] = current;
            data[pixel * 4 + 1] = current;
            data[pixel * 4 + 2] = current;
            data[pixel * 4 + 3] = 255;
        }
    }
    //frame.data = data;
    ctx.putImageData(frame, 0, 0);
};

/**
 * Displays the {SubImage} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
ImageWrapper.prototype.overlay = function (canvas, scale, from) {
    if (!scale || scale < 0 || scale > 360) {
        scale = 360;
    }
    var hsv = [0, 1, 1];
    var rgb = [0, 0, 0];
    var whiteRgb = [255, 255, 255];
    var blackRgb = [0, 0, 0];
    var result = [];
    var ctx = canvas.getContext('2d');
    var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
    var data = frame.data;
    var length = this.data.length;
    while (length--) {
        hsv[0] = this.data[length] * scale;
        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["a" /* hsv2rgb */])(hsv, rgb);
        data[length * 4 + 0] = result[0];
        data[length * 4 + 1] = result[1];
        data[length * 4 + 2] = result[2];
        data[length * 4 + 3] = 255;
    }
    ctx.putImageData(frame, from.x, from.y);
};

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(37);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(97),
    getValue = __webpack_require__(120);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(27);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(25),
    isLength = __webpack_require__(26);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObject = __webpack_require__(0);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(100),
    createAssigner = __webpack_require__(116);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
    searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
    create: function create(imageWrapper, labelWrapper) {
        var imageData = imageWrapper.data,
            labelData = labelWrapper.data,
            searchDirections = this.searchDirections,
            width = imageWrapper.size.x,
            pos;

        function _trace(current, color, label, edgelabel) {
            var i, y, x;

            for (i = 0; i < 7; i++) {
                y = current.cy + searchDirections[current.dir][0];
                x = current.cx + searchDirections[current.dir][1];
                pos = y * width + x;
                if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
                    labelData[pos] = label;
                    current.cy = y;
                    current.cx = x;
                    return true;
                } else {
                    if (labelData[pos] === 0) {
                        labelData[pos] = edgelabel;
                    }
                    current.dir = (current.dir + 1) % 8;
                }
            }
            return false;
        }

        function vertex2D(x, y, dir) {
            return {
                dir: dir,
                x: x,
                y: y,
                next: null,
                prev: null
            };
        }

        function _contourTracing(sy, sx, label, color, edgelabel) {
            var Fv = null,
                Cv,
                P,
                ldir,
                current = {
                cx: sx,
                cy: sy,
                dir: 0
            };

            if (_trace(current, color, label, edgelabel)) {
                Fv = vertex2D(sx, sy, current.dir);
                Cv = Fv;
                ldir = current.dir;
                P = vertex2D(current.cx, current.cy, 0);
                P.prev = Cv;
                Cv.next = P;
                P.next = null;
                Cv = P;
                do {
                    current.dir = (current.dir + 6) % 8;
                    _trace(current, color, label, edgelabel);
                    if (ldir !== current.dir) {
                        Cv.dir = current.dir;
                        P = vertex2D(current.cx, current.cy, 0);
                        P.prev = Cv;
                        Cv.next = P;
                        P.next = null;
                        Cv = P;
                    } else {
                        Cv.dir = ldir;
                        Cv.x = current.cx;
                        Cv.y = current.cy;
                    }
                    ldir = current.dir;
                } while (current.cx !== sx || current.cy !== sy);
                Fv.prev = Cv.prev;
                Cv.prev.next = Fv;
            }
            return Fv;
        }

        return {
            trace: function trace(current, color, label, edgelabel) {
                return _trace(current, color, label, edgelabel);
            },
            contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
                return _contourTracing(sy, sx, label, color, edgelabel);
            }
        };
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_array_helper__ = __webpack_require__(3);



function Code39Reader() {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this);
}

var properties = {
    ALPHABETH_STRING: { value: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%" },
    ALPHABET: { value: [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 45, 46, 32, 42, 36, 47, 43, 37] },
    CHARACTER_ENCODINGS: { value: [0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A] },
    ASTERISK: { value: 0x094 },
    FORMAT: { value: "code_39", writeable: false }
};

Code39Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
Code39Reader.prototype.constructor = Code39Reader;

Code39Reader.prototype._decode = function () {
    var self = this,
        counters = [0, 0, 0, 0, 0, 0, 0, 0, 0],
        result = [],
        start = self._findStart(),
        decodedChar,
        lastStart,
        pattern,
        nextStart;

    if (!start) {
        return null;
    }
    nextStart = self._nextSet(self._row, start.end);

    do {
        counters = self._toCounters(nextStart, counters);
        pattern = self._toPattern(counters);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += __WEBPACK_IMPORTED_MODULE_1__common_array_helper__["a" /* default */].sum(counters);
        nextStart = self._nextSet(self._row, nextStart);
    } while (decodedChar !== '*');
    result.pop();

    if (!result.length) {
        return null;
    }

    if (!self._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
    }

    return {
        code: result.join(""),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result
    };
};

Code39Reader.prototype._verifyTrailingWhitespace = function (lastStart, nextStart, counters) {
    var trailingWhitespaceEnd,
        patternSize = __WEBPACK_IMPORTED_MODULE_1__common_array_helper__["a" /* default */].sum(counters);

    trailingWhitespaceEnd = nextStart - lastStart - patternSize;
    if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
    }
    return false;
};

Code39Reader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

Code39Reader.prototype._findNextWidth = function (counters, current) {
    var i,
        minWidth = Number.MAX_VALUE;

    for (i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
            minWidth = counters[i];
        }
    }

    return minWidth;
};

Code39Reader.prototype._toPattern = function (counters) {
    var numCounters = counters.length,
        maxNarrowWidth = 0,
        numWideBars = numCounters,
        wideBarWidth = 0,
        self = this,
        pattern,
        i;

    while (numWideBars > 3) {
        maxNarrowWidth = self._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        pattern = 0;
        for (i = 0; i < numCounters; i++) {
            if (counters[i] > maxNarrowWidth) {
                pattern |= 1 << numCounters - 1 - i;
                numWideBars++;
                wideBarWidth += counters[i];
            }
        }

        if (numWideBars === 3) {
            for (i = 0; i < numCounters && numWideBars > 0; i++) {
                if (counters[i] > maxNarrowWidth) {
                    numWideBars--;
                    if (counters[i] * 2 >= wideBarWidth) {
                        return -1;
                    }
                }
            }
            return pattern;
        }
    }
    return -1;
};

Code39Reader.prototype._findStart = function () {
    var self = this,
        offset = self._nextSet(self._row),
        patternStart = offset,
        counter = [0, 0, 0, 0, 0, 0, 0, 0, 0],
        counterPos = 0,
        isWhite = false,
        i,
        j,
        whiteSpaceMustStart;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                // find start pattern
                if (self._toPattern(counter) === self.ASTERISK) {
                    whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
                    if (self._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                        return {
                            start: patternStart,
                            end: i
                        };
                    }
                }

                patternStart += counter[0] + counter[1];
                for (j = 0; j < 7; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[7] = 0;
                counter[8] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

/* harmony default export */ __webpack_exports__["a"] = (Code39Reader);

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = dot

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1]
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22),
    root = __webpack_require__(5);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(138),
    mapCacheDelete = __webpack_require__(139),
    mapCacheGet = __webpack_require__(140),
    mapCacheHas = __webpack_require__(141),
    mapCacheSet = __webpack_require__(142);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(21),
    eq = __webpack_require__(17);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(21),
    eq = __webpack_require__(17);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(147);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(87);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(106),
    shortOut = __webpack_require__(148);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 43 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(5),
    stubFalse = __webpack_require__(163);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(98),
    baseUnary = __webpack_require__(109),
    nodeUtil = __webpack_require__(145);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(88),
    baseKeysIn = __webpack_require__(99),
    isArrayLike = __webpack_require__(24);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 47 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_merge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_typedefs__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_typedefs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__common_typedefs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_image_wrapper__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__locator_barcode_locator__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__decoder_barcode_decoder__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_events__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__input_camera_access__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_image_debug__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__analytics_result_collector__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__config_config__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_input_stream__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_frame_grabber__ = __webpack_require__(61);


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

 // eslint-disable-line no-unused-vars











var vec2 = {
    clone: __webpack_require__(7)
};

var _inputStream,
    _framegrabber,
    _stopped,
    _canvasContainer = {
    ctx: {
        image: null,
        overlay: null
    },
    dom: {
        image: null,
        overlay: null
    }
},
    _inputImageWrapper,
    _boxSize,
    _decoder,
    _workerPool = [],
    _onUIThread = true,
    _resultCollector,
    _config = {};

function initializeData(imageWrapper) {
    initBuffers(imageWrapper);
    _decoder = __WEBPACK_IMPORTED_MODULE_4__decoder_barcode_decoder__["a" /* default */].create(_config.decoder, _inputImageWrapper);
}

function initInputStream(cb) {
    var video;
    if (_config.inputStream.type === "VideoStream") {
        video = document.createElement("video");
        _inputStream = __WEBPACK_IMPORTED_MODULE_10_input_stream__["a" /* default */].createVideoStream(video);
    } else if (_config.inputStream.type === "ImageStream") {
        _inputStream = __WEBPACK_IMPORTED_MODULE_10_input_stream__["a" /* default */].createImageStream();
    } else if (_config.inputStream.type === "LiveStream") {
        var $viewport = getViewPort();
        if ($viewport) {
            video = $viewport.querySelector("video");
            if (!video) {
                video = document.createElement("video");
                $viewport.appendChild(video);
            }
        }
        _inputStream = __WEBPACK_IMPORTED_MODULE_10_input_stream__["a" /* default */].createLiveStream(video);
        __WEBPACK_IMPORTED_MODULE_6__input_camera_access__["a" /* default */].request(video, _config.inputStream.constraints).then(function () {
            _inputStream.trigger("canrecord");
        }).catch(function (err) {
            return cb(err);
        });
    }

    _inputStream.setAttribute("preload", "auto");
    _inputStream.setInputStream(_config.inputStream);
    _inputStream.addEventListener("canrecord", canRecord.bind(undefined, cb));
}

function getViewPort() {
    var target = _config.inputStream.target;
    // Check if target is already a DOM element
    if (target && target.nodeName && target.nodeType === 1) {
        return target;
    } else {
        // Use '#interactive.viewport' as a fallback selector (backwards compatibility)
        var selector = typeof target === 'string' ? target : '#interactive.viewport';
        return document.querySelector(selector);
    }
}

function canRecord(cb) {
    __WEBPACK_IMPORTED_MODULE_3__locator_barcode_locator__["a" /* default */].checkImageConstraints(_inputStream, _config.locator);
    initCanvas(_config);
    _framegrabber = __WEBPACK_IMPORTED_MODULE_11_frame_grabber__["a" /* default */].create(_inputStream, _canvasContainer.dom.image);

    adjustWorkerPool(_config.numOfWorkers, function () {
        if (_config.numOfWorkers === 0) {
            initializeData();
        }
        ready(cb);
    });
}

function ready(cb) {
    _inputStream.play();
    cb();
}

function initCanvas() {
    if (typeof document !== "undefined") {
        var $viewport = getViewPort();
        _canvasContainer.dom.image = document.querySelector("canvas.imgBuffer");
        if (!_canvasContainer.dom.image) {
            _canvasContainer.dom.image = document.createElement("canvas");
            _canvasContainer.dom.image.className = "imgBuffer";
            if ($viewport && _config.inputStream.type === "ImageStream") {
                $viewport.appendChild(_canvasContainer.dom.image);
            }
        }
        _canvasContainer.ctx.image = _canvasContainer.dom.image.getContext("2d");
        _canvasContainer.dom.image.width = _inputStream.getCanvasSize().x;
        _canvasContainer.dom.image.height = _inputStream.getCanvasSize().y;

        _canvasContainer.dom.overlay = document.querySelector("canvas.drawingBuffer");
        if (!_canvasContainer.dom.overlay) {
            _canvasContainer.dom.overlay = document.createElement("canvas");
            _canvasContainer.dom.overlay.className = "drawingBuffer";
            if ($viewport) {
                $viewport.appendChild(_canvasContainer.dom.overlay);
            }
            var clearFix = document.createElement("br");
            clearFix.setAttribute("clear", "all");
            if ($viewport) {
                $viewport.appendChild(clearFix);
            }
        }
        _canvasContainer.ctx.overlay = _canvasContainer.dom.overlay.getContext("2d");
        _canvasContainer.dom.overlay.width = _inputStream.getCanvasSize().x;
        _canvasContainer.dom.overlay.height = _inputStream.getCanvasSize().y;
    }
}

function initBuffers(imageWrapper) {
    if (imageWrapper) {
        _inputImageWrapper = imageWrapper;
    } else {
        _inputImageWrapper = new __WEBPACK_IMPORTED_MODULE_2__common_image_wrapper__["a" /* default */]({
            x: _inputStream.getWidth(),
            y: _inputStream.getHeight()
        });
    }

    if (true) {
        console.log(_inputImageWrapper.size);
    }
    _boxSize = [vec2.clone([0, 0]), vec2.clone([0, _inputImageWrapper.size.y]), vec2.clone([_inputImageWrapper.size.x, _inputImageWrapper.size.y]), vec2.clone([_inputImageWrapper.size.x, 0])];
    __WEBPACK_IMPORTED_MODULE_3__locator_barcode_locator__["a" /* default */].init(_inputImageWrapper, _config.locator);
}

function getBoundingBoxes() {
    if (_config.locate) {
        return __WEBPACK_IMPORTED_MODULE_3__locator_barcode_locator__["a" /* default */].locate();
    } else {
        return [[vec2.clone(_boxSize[0]), vec2.clone(_boxSize[1]), vec2.clone(_boxSize[2]), vec2.clone(_boxSize[3])]];
    }
}

function transformResult(result) {
    var topRight = _inputStream.getTopRight(),
        xOffset = topRight.x,
        yOffset = topRight.y,
        i;

    if (xOffset === 0 && yOffset === 0) {
        return;
    }

    if (result.barcodes) {
        for (i = 0; i < result.barcodes.length; i++) {
            transformResult(result.barcodes[i]);
        }
    }

    if (result.line && result.line.length === 2) {
        moveLine(result.line);
    }

    if (result.box) {
        moveBox(result.box);
    }

    if (result.boxes && result.boxes.length > 0) {
        for (i = 0; i < result.boxes.length; i++) {
            moveBox(result.boxes[i]);
        }
    }

    function moveBox(box) {
        var corner = box.length;

        while (corner--) {
            box[corner][0] += xOffset;
            box[corner][1] += yOffset;
        }
    }

    function moveLine(line) {
        line[0].x += xOffset;
        line[0].y += yOffset;
        line[1].x += xOffset;
        line[1].y += yOffset;
    }
}

function addResult(result, imageData) {
    if (!imageData || !_resultCollector) {
        return;
    }

    if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
            return barcode.codeResult;
        }).forEach(function (barcode) {
            return addResult(barcode, imageData);
        });
    } else if (result.codeResult) {
        _resultCollector.addResult(imageData, _inputStream.getCanvasSize(), result.codeResult);
    }
}

function hasCodeResult(result) {
    return result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
    }) : result.codeResult);
}

function publishResult(result, imageData) {
    var resultToPublish = result;

    if (result && _onUIThread) {
        transformResult(result);
        addResult(result, imageData);
        resultToPublish = result.barcodes || result;
    }

    __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].publish("processed", resultToPublish);
    if (hasCodeResult(result)) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].publish("detected", resultToPublish);
    }
}

function locateAndDecode() {
    var result, boxes;

    boxes = getBoundingBoxes();
    if (boxes) {
        result = _decoder.decodeFromBoundingBoxes(boxes);
        result = result || {};
        result.boxes = boxes;
        publishResult(result, _inputImageWrapper.data);
    } else {
        publishResult();
    }
}

function update() {
    var availableWorker;

    if (_onUIThread) {
        if (_workerPool.length > 0) {
            availableWorker = _workerPool.filter(function (workerThread) {
                return !workerThread.busy;
            })[0];
            if (availableWorker) {
                _framegrabber.attachData(availableWorker.imageData);
            } else {
                return; // all workers are busy
            }
        } else {
            _framegrabber.attachData(_inputImageWrapper.data);
        }
        if (_framegrabber.grab()) {
            if (availableWorker) {
                availableWorker.busy = true;
                availableWorker.worker.postMessage({
                    cmd: 'process',
                    imageData: availableWorker.imageData
                }, [availableWorker.imageData.buffer]);
            } else {
                locateAndDecode();
            }
        }
    } else {
        locateAndDecode();
    }
}

function startContinuousUpdate() {
    var next = null,
        delay = 1000 / (_config.frequency || 60);

    _stopped = false;
    (function frame(timestamp) {
        next = next || timestamp;
        if (!_stopped) {
            if (timestamp >= next) {
                next += delay;
                update();
            }
            window.requestAnimFrame(frame);
        }
    })(performance.now());
}

function _start() {
    if (_onUIThread && _config.inputStream.type === "LiveStream") {
        startContinuousUpdate();
    } else {
        update();
    }
}

function initWorker(cb) {
    var blobURL,
        workerThread = {
        worker: undefined,
        imageData: new Uint8Array(_inputStream.getWidth() * _inputStream.getHeight()),
        busy: true
    };

    blobURL = generateWorkerBlob();
    workerThread.worker = new Worker(blobURL);

    workerThread.worker.onmessage = function (e) {
        if (e.data.event === 'initialized') {
            URL.revokeObjectURL(blobURL);
            workerThread.busy = false;
            workerThread.imageData = new Uint8Array(e.data.imageData);
            if (true) {
                console.log("Worker initialized");
            }
            return cb(workerThread);
        } else if (e.data.event === 'processed') {
            workerThread.imageData = new Uint8Array(e.data.imageData);
            workerThread.busy = false;
            publishResult(e.data.result, workerThread.imageData);
        } else if (e.data.event === 'error') {
            if (true) {
                console.log("Worker error: " + e.data.message);
            }
        }
    };

    workerThread.worker.postMessage({
        cmd: 'init',
        size: { x: _inputStream.getWidth(), y: _inputStream.getHeight() },
        imageData: workerThread.imageData,
        config: configForWorker(_config)
    }, [workerThread.imageData.buffer]);
}

function configForWorker(config) {
    return _extends({}, config, {
        inputStream: _extends({}, config.inputStream, {
            target: null
        })
    });
}

function workerInterface(factory) {
    /* eslint-disable no-undef*/
    if (factory) {
        var Quagga = factory().default;
        if (!Quagga) {
            self.postMessage({ 'event': 'error', message: 'Quagga could not be created' });
            return;
        }
    }
    var imageWrapper;

    self.onmessage = function (e) {
        if (e.data.cmd === 'init') {
            var config = e.data.config;
            config.numOfWorkers = 0;
            imageWrapper = new Quagga.ImageWrapper({
                x: e.data.size.x,
                y: e.data.size.y
            }, new Uint8Array(e.data.imageData));
            Quagga.init(config, ready, imageWrapper);
            Quagga.onProcessed(onProcessed);
        } else if (e.data.cmd === 'process') {
            imageWrapper.data = new Uint8Array(e.data.imageData);
            Quagga.start();
        } else if (e.data.cmd === 'setReaders') {
            Quagga.setReaders(e.data.readers);
        }
    };

    function onProcessed(result) {
        self.postMessage({
            'event': 'processed',
            imageData: imageWrapper.data,
            result: result
        }, [imageWrapper.data.buffer]);
    }

    function ready() {
        // eslint-disable-line
        self.postMessage({ 'event': 'initialized', imageData: imageWrapper.data }, [imageWrapper.data.buffer]);
    }

    /* eslint-enable */
}

function generateWorkerBlob() {
    var blob, factorySource;

    /* jshint ignore:start */
    if (typeof __factorySource__ !== 'undefined') {
        factorySource = __factorySource__; // eslint-disable-line no-undef
    }
    /* jshint ignore:end */

    blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], { type: 'text/javascript' });

    return window.URL.createObjectURL(blob);
}

function _setReaders(readers) {
    if (_decoder) {
        _decoder.setReaders(readers);
    } else if (_onUIThread && _workerPool.length > 0) {
        _workerPool.forEach(function (workerThread) {
            workerThread.worker.postMessage({ cmd: 'setReaders', readers: readers });
        });
    }
}

function adjustWorkerPool(capacity, cb) {
    var increaseBy = capacity - _workerPool.length;
    if (increaseBy === 0) {
        return cb && cb();
    }
    if (increaseBy < 0) {
        var workersToTerminate = _workerPool.slice(increaseBy);
        workersToTerminate.forEach(function (workerThread) {
            workerThread.worker.terminate();
            if (true) {
                console.log("Worker terminated!");
            }
        });
        _workerPool = _workerPool.slice(0, increaseBy);
        return cb && cb();
    } else {
        var workerInitialized = function workerInitialized(workerThread) {
            _workerPool.push(workerThread);
            if (_workerPool.length >= capacity) {
                cb && cb();
            }
        };

        for (var i = 0; i < increaseBy; i++) {
            initWorker(workerInitialized);
        }
    }
}

/* harmony default export */ __webpack_exports__["default"] = ({
    init: function init(config, cb, imageWrapper) {
        _config = __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default()({}, __WEBPACK_IMPORTED_MODULE_9__config_config__["a" /* default */], config);
        if (imageWrapper) {
            _onUIThread = false;
            initializeData(imageWrapper);
            return cb();
        } else {
            initInputStream(cb);
        }
    },
    start: function start() {
        _start();
    },
    stop: function stop() {
        _stopped = true;
        adjustWorkerPool(0);
        if (_config.inputStream.type === "LiveStream") {
            __WEBPACK_IMPORTED_MODULE_6__input_camera_access__["a" /* default */].release();
            _inputStream.clearEventHandlers();
        }
    },
    pause: function pause() {
        _stopped = true;
    },
    onDetected: function onDetected(callback) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].subscribe("detected", callback);
    },
    offDetected: function offDetected(callback) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].unsubscribe("detected", callback);
    },
    onProcessed: function onProcessed(callback) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].subscribe("processed", callback);
    },
    offProcessed: function offProcessed(callback) {
        __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].unsubscribe("processed", callback);
    },
    setReaders: function setReaders(readers) {
        _setReaders(readers);
    },
    registerResultCollector: function registerResultCollector(resultCollector) {
        if (resultCollector && typeof resultCollector.addResult === 'function') {
            _resultCollector = resultCollector;
        }
    },
    canvas: _canvasContainer,
    decodeSingle: function decodeSingle(config, resultCallback) {
        var _this = this;

        config = __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default()({
            inputStream: {
                type: "ImageStream",
                sequence: false,
                size: 800,
                src: config.src
            },
            numOfWorkers: true && config.debug ? 0 : 1,
            locator: {
                halfSample: false
            }
        }, config);
        this.init(config, function () {
            __WEBPACK_IMPORTED_MODULE_5__common_events__["a" /* default */].once("processed", function (result) {
                _this.stop();
                resultCallback.call(null, result);
            }, true);
            _start();
        });
    },
    ImageWrapper: __WEBPACK_IMPORTED_MODULE_2__common_image_wrapper__["a" /* default */],
    ImageDebug: __WEBPACK_IMPORTED_MODULE_7__common_image_debug__["a" /* default */],
    ResultCollector: __WEBPACK_IMPORTED_MODULE_8__analytics_result_collector__["a" /* default */],
    CameraAccess: __WEBPACK_IMPORTED_MODULE_6__input_camera_access__["a" /* default */]
});

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_image_debug__ = __webpack_require__(9);


function contains(codeResult, list) {
    if (list) {
        return list.some(function (item) {
            return Object.keys(item).every(function (key) {
                return item[key] === codeResult[key];
            });
        });
    }
    return false;
}

function passesFilter(codeResult, filter) {
    if (typeof filter === 'function') {
        return filter(codeResult);
    }
    return true;
}

/* harmony default export */ __webpack_exports__["a"] = ({
    create: function create(config) {
        var canvas = document.createElement("canvas"),
            ctx = canvas.getContext("2d"),
            results = [],
            capacity = config.capacity || 20,
            capture = config.capture === true;

        function matchesConstraints(codeResult) {
            return capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
        }

        return {
            addResult: function addResult(data, imageSize, codeResult) {
                var result = {};

                if (matchesConstraints(codeResult)) {
                    capacity--;
                    result.codeResult = codeResult;
                    if (capture) {
                        canvas.width = imageSize.x;
                        canvas.height = imageSize.y;
                        __WEBPACK_IMPORTED_MODULE_0__common_image_debug__["a" /* default */].drawImage(data, imageSize, ctx);
                        result.frame = canvas.toDataURL();
                    }
                    results.push(result);
                }
            },
            getResults: function getResults() {
                return results;
            }
        };
    }
});

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var vec2 = {
    clone: __webpack_require__(7),
    dot: __webpack_require__(32)
    /**
     * Creates a cluster for grouping similar orientations of datapoints
     */
};/* harmony default export */ __webpack_exports__["a"] = ({
    create: function create(point, threshold) {
        var points = [],
            center = {
            rad: 0,
            vec: vec2.clone([0, 0])
        },
            pointMap = {};

        function init() {
            _add(point);
            updateCenter();
        }

        function _add(pointToAdd) {
            pointMap[pointToAdd.id] = pointToAdd;
            points.push(pointToAdd);
        }

        function updateCenter() {
            var i,
                sum = 0;
            for (i = 0; i < points.length; i++) {
                sum += points[i].rad;
            }
            center.rad = sum / points.length;
            center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
        }

        init();

        return {
            add: function add(pointToAdd) {
                if (!pointMap[pointToAdd.id]) {
                    _add(pointToAdd);
                    updateCenter();
                }
            },
            fits: function fits(otherPoint) {
                // check cosine similarity to center-angle
                var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));
                if (similarity > threshold) {
                    return true;
                }
                return false;
            },
            getPoints: function getPoints() {
                return points;
            },
            getCenter: function getCenter() {
                return center;
            }
        };
    },
    createPoint: function createPoint(newPoint, id, property) {
        return {
            rad: newPoint[property],
            point: newPoint,
            id: id
        };
    }
});

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ((function () {
    var events = {};

    function getEvent(eventName) {
        if (!events[eventName]) {
            events[eventName] = {
                subscribers: []
            };
        }
        return events[eventName];
    }

    function clearEvents() {
        events = {};
    }

    function publishSubscription(subscription, data) {
        if (subscription.async) {
            setTimeout(function () {
                subscription.callback(data);
            }, 4);
        } else {
            subscription.callback(data);
        }
    }

    function _subscribe(event, callback, async) {
        var subscription;

        if (typeof callback === "function") {
            subscription = {
                callback: callback,
                async: async
            };
        } else {
            subscription = callback;
            if (!subscription.callback) {
                throw "Callback was not specified on options";
            }
        }

        getEvent(event).subscribers.push(subscription);
    }

    return {
        subscribe: function subscribe(event, callback, async) {
            return _subscribe(event, callback, async);
        },
        publish: function publish(eventName, data) {
            var event = getEvent(eventName),
                subscribers = event.subscribers;

            // Publish one-time subscriptions
            subscribers.filter(function (subscriber) {
                return !!subscriber.once;
            }).forEach(function (subscriber) {
                publishSubscription(subscriber, data);
            });

            // remove them from the subscriber
            event.subscribers = subscribers.filter(function (subscriber) {
                return !subscriber.once;
            });

            // publish the rest
            event.subscribers.forEach(function (subscriber) {
                publishSubscription(subscriber, data);
            });
        },
        once: function once(event, callback, async) {
            _subscribe(event, {
                callback: callback,
                async: async,
                once: true
            });
        },
        unsubscribe: function unsubscribe(eventName, callback) {
            var event;

            if (eventName) {
                event = getEvent(eventName);
                if (event && callback) {
                    event.subscribers = event.subscribers.filter(function (subscriber) {
                        return subscriber.callback !== callback;
                    });
                } else {
                    event.subscribers = [];
                }
            } else {
                clearEvents();
            }
        }
    };
})());

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = enumerateDevices;
/* harmony export (immutable) */ __webpack_exports__["a"] = getUserMedia;

function enumerateDevices() {
    if (navigator.mediaDevices && typeof navigator.mediaDevices.enumerateDevices === 'function') {
        return navigator.mediaDevices.enumerateDevices();
    }
    return Promise.reject(new Error('enumerateDevices is not defined'));
};

function getUserMedia(constraints) {
    if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
        return navigator.mediaDevices.getUserMedia(constraints);
    }
    return Promise.reject(new Error('getUserMedia is not defined'));
}

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Construct representing a part of another {ImageWrapper}. Shares data
 * between the parent and the child.
 * @param from {ImageRef} The position where to start the {SubImage} from. (top-left corner)
 * @param size {ImageRef} The size of the resulting image
 * @param I {ImageWrapper} The {ImageWrapper} to share from
 * @returns {SubImage} A shared part of the original image
 */
function SubImage(from, size, I) {
    if (!I) {
        I = {
            data: null,
            size: size
        };
    }
    this.data = I.data;
    this.originalSize = I.size;
    this.I = I;

    this.from = from;
    this.size = size;
}

/**
 * Displays the {SubImage} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
SubImage.prototype.show = function (canvas, scale) {
    var ctx, frame, data, current, y, x, pixel;

    if (!scale) {
        scale = 1.0;
    }
    ctx = canvas.getContext('2d');
    canvas.width = this.size.x;
    canvas.height = this.size.y;
    frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    data = frame.data;
    current = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            pixel = y * this.size.x + x;
            current = this.get(x, y) * scale;
            data[pixel * 4 + 0] = current;
            data[pixel * 4 + 1] = current;
            data[pixel * 4 + 2] = current;
            data[pixel * 4 + 3] = 255;
        }
    }
    frame.data = data;
    ctx.putImageData(frame, 0, 0);
};

/**
 * Retrieves a given pixel position from the {SubImage}
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
SubImage.prototype.get = function (x, y) {
    return this.data[(this.from.y + y) * this.originalSize.x + this.from.x + x];
};

/**
 * Updates the underlying data from a given {ImageWrapper}
 * @param image {ImageWrapper} The updated image
 */
SubImage.prototype.updateData = function (image) {
    this.originalSize = image.size;
    this.data = image.data;
};

/**
 * Updates the position of the shared area
 * @param from {x,y} The new location
 * @returns {SubImage} returns {this} for possible chaining
 */
SubImage.prototype.updateFrom = function (from) {
    this.from = from;
    return this;
};

/* harmony default export */ __webpack_exports__["a"] = (SubImage);

/***/ }),
/* 54 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes
 */

if (typeof window !== 'undefined') {
    window.requestAnimFrame = function () {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( /* function FrameRequestCallback */callback) {
            window.setTimeout(callback, 1000 / 60);
        };
    }();
}
Math.imul = Math.imul || function (a, b) {
    var ah = a >>> 16 & 0xffff,
        al = a & 0xffff,
        bh = b >>> 16 & 0xffff,
        bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
};

if (typeof Object.assign !== 'function') {
    Object.assign = function (target) {
        // .length of function is 2
        'use strict';

        if (target === null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];

            if (nextSource !== null) {
                // Skip over if undefined or null
                for (var nextKey in nextSource) {
                    // Avoid bugs when hasOwnProperty is shadowed
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };
}

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = {
    inputStream: {
        name: "Live",
        type: "LiveStream",
        constraints: {
            width: 640,
            height: 480,
            // aspectRatio: 640/480, // optional
            facingMode: "environment" // or user
            // deviceId: "38745983457387598375983759834"
        },
        area: {
            top: "0%",
            right: "0%",
            left: "0%",
            bottom: "0%"
        },
        singleChannel: false // true: only the red color-channel is read
    },
    locate: true,
    numOfWorkers: 0,
    decoder: {
        readers: ['code_128_reader'],
        debug: {
            drawBoundingBox: false,
            showFrequency: false,
            drawScanline: false,
            showPattern: false
        }
    },
    locator: {
        halfSample: true,
        patchSize: "medium", // x-small, small, medium, large, x-large
        debug: {
            showCanvas: false,
            showPatches: false,
            showFoundPatches: false,
            showSkeleton: false,
            showLabels: false,
            showPatchLabels: false,
            showRemainingPatchLabels: false,
            boxFromPatches: {
                showTransformed: false,
                showTransformedBox: false,
                showBB: false
            }
        }
    }
};

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var config = void 0;

if (true) {
    config = __webpack_require__(55);
} else if (ENV.node) {
    config = require('./config.node.js');
} else {
    config = require('./config.prod.js');
}

/* harmony default export */ __webpack_exports__["a"] = (config);

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bresenham__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_image_debug__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__reader_code_128_reader__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__reader_ean_reader__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__reader_code_39_reader__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__reader_code_39_vin_reader__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__reader_codabar_reader__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__reader_upc_reader__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__reader_ean_8_reader__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__reader_ean_2_reader__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__reader_ean_5_reader__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__reader_upc_e_reader__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__reader_i2of5_reader__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__reader_2of5_reader__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__reader_code_93_reader__ = __webpack_require__(71);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

















var READERS = {
    code_128_reader: __WEBPACK_IMPORTED_MODULE_2__reader_code_128_reader__["a" /* default */],
    ean_reader: __WEBPACK_IMPORTED_MODULE_3__reader_ean_reader__["a" /* default */],
    ean_5_reader: __WEBPACK_IMPORTED_MODULE_10__reader_ean_5_reader__["a" /* default */],
    ean_2_reader: __WEBPACK_IMPORTED_MODULE_9__reader_ean_2_reader__["a" /* default */],
    ean_8_reader: __WEBPACK_IMPORTED_MODULE_8__reader_ean_8_reader__["a" /* default */],
    code_39_reader: __WEBPACK_IMPORTED_MODULE_4__reader_code_39_reader__["a" /* default */],
    code_39_vin_reader: __WEBPACK_IMPORTED_MODULE_5__reader_code_39_vin_reader__["a" /* default */],
    codabar_reader: __WEBPACK_IMPORTED_MODULE_6__reader_codabar_reader__["a" /* default */],
    upc_reader: __WEBPACK_IMPORTED_MODULE_7__reader_upc_reader__["a" /* default */],
    upc_e_reader: __WEBPACK_IMPORTED_MODULE_11__reader_upc_e_reader__["a" /* default */],
    i2of5_reader: __WEBPACK_IMPORTED_MODULE_12__reader_i2of5_reader__["a" /* default */],
    '2of5_reader': __WEBPACK_IMPORTED_MODULE_13__reader_2of5_reader__["a" /* default */],
    code_93_reader: __WEBPACK_IMPORTED_MODULE_14__reader_code_93_reader__["a" /* default */]
};
/* harmony default export */ __webpack_exports__["a"] = ({
    create: function create(config, inputImageWrapper) {
        var _canvas = {
            ctx: {
                frequency: null,
                pattern: null,
                overlay: null
            },
            dom: {
                frequency: null,
                pattern: null,
                overlay: null
            }
        },
            _barcodeReaders = [];

        initCanvas();
        initReaders();
        initConfig();

        function initCanvas() {
            if (true && typeof document !== 'undefined') {
                var $debug = document.querySelector("#debug.detection");
                _canvas.dom.frequency = document.querySelector("canvas.frequency");
                if (!_canvas.dom.frequency) {
                    _canvas.dom.frequency = document.createElement("canvas");
                    _canvas.dom.frequency.className = "frequency";
                    if ($debug) {
                        $debug.appendChild(_canvas.dom.frequency);
                    }
                }
                _canvas.ctx.frequency = _canvas.dom.frequency.getContext("2d");

                _canvas.dom.pattern = document.querySelector("canvas.patternBuffer");
                if (!_canvas.dom.pattern) {
                    _canvas.dom.pattern = document.createElement("canvas");
                    _canvas.dom.pattern.className = "patternBuffer";
                    if ($debug) {
                        $debug.appendChild(_canvas.dom.pattern);
                    }
                }
                _canvas.ctx.pattern = _canvas.dom.pattern.getContext("2d");

                _canvas.dom.overlay = document.querySelector("canvas.drawingBuffer");
                if (_canvas.dom.overlay) {
                    _canvas.ctx.overlay = _canvas.dom.overlay.getContext("2d");
                }
            }
        }

        function initReaders() {
            config.readers.forEach(function (readerConfig) {
                var reader,
                    configuration = {},
                    supplements = [];

                if ((typeof readerConfig === 'undefined' ? 'undefined' : _typeof(readerConfig)) === 'object') {
                    reader = readerConfig.format;
                    configuration = readerConfig.config;
                } else if (typeof readerConfig === 'string') {
                    reader = readerConfig;
                }
                if (true) {
                    console.log("Before registering reader: ", reader);
                }
                if (configuration.supplements) {
                    supplements = configuration.supplements.map(function (supplement) {
                        return new READERS[supplement]();
                    });
                }
                _barcodeReaders.push(new READERS[reader](configuration, supplements));
            });
            if (true) {
                console.log("Registered Readers: " + _barcodeReaders.map(function (reader) {
                    return JSON.stringify({ format: reader.FORMAT, config: reader.config });
                }).join(', '));
            }
        }

        function initConfig() {
            if (true && typeof document !== 'undefined') {
                var i,
                    vis = [{
                    node: _canvas.dom.frequency,
                    prop: config.debug.showFrequency
                }, {
                    node: _canvas.dom.pattern,
                    prop: config.debug.showPattern
                }];

                for (i = 0; i < vis.length; i++) {
                    if (vis[i].prop === true) {
                        vis[i].node.style.display = "block";
                    } else {
                        vis[i].node.style.display = "none";
                    }
                }
            }
        }

        /**
         * extend the line on both ends
         * @param {Array} line
         * @param {Number} angle
         */
        function getExtendedLine(line, angle, ext) {
            function extendLine(amount) {
                var extension = {
                    y: amount * Math.sin(angle),
                    x: amount * Math.cos(angle)
                };

                line[0].y -= extension.y;
                line[0].x -= extension.x;
                line[1].y += extension.y;
                line[1].x += extension.x;
            }

            // check if inside image
            extendLine(ext);
            while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0], 0) || !inputImageWrapper.inImageWithBorder(line[1], 0))) {
                ext -= Math.ceil(ext / 2);
                extendLine(-ext);
            }
            return line;
        }

        function getLine(box) {
            return [{
                x: (box[1][0] - box[0][0]) / 2 + box[0][0],
                y: (box[1][1] - box[0][1]) / 2 + box[0][1]
            }, {
                x: (box[3][0] - box[2][0]) / 2 + box[2][0],
                y: (box[3][1] - box[2][1]) / 2 + box[2][1]
            }];
        }

        function tryDecode(line) {
            var result = null,
                i,
                barcodeLine = __WEBPACK_IMPORTED_MODULE_0__bresenham__["a" /* default */].getBarcodeLine(inputImageWrapper, line[0], line[1]);

            if (true && config.debug.showFrequency) {
                __WEBPACK_IMPORTED_MODULE_1__common_image_debug__["a" /* default */].drawPath(line, { x: 'x', y: 'y' }, _canvas.ctx.overlay, { color: 'red', lineWidth: 3 });
                __WEBPACK_IMPORTED_MODULE_0__bresenham__["a" /* default */].debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
            }

            __WEBPACK_IMPORTED_MODULE_0__bresenham__["a" /* default */].toBinaryLine(barcodeLine);

            if (true && config.debug.showPattern) {
                __WEBPACK_IMPORTED_MODULE_0__bresenham__["a" /* default */].debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
            }

            for (i = 0; i < _barcodeReaders.length && result === null; i++) {
                result = _barcodeReaders[i].decodePattern(barcodeLine.line);
            }
            if (result === null) {
                return null;
            }
            return {
                codeResult: result,
                barcodeLine: barcodeLine
            };
        }

        /**
         * This method slices the given area apart and tries to detect a barcode-pattern
         * for each slice. It returns the decoded barcode, or null if nothing was found
         * @param {Array} box
         * @param {Array} line
         * @param {Number} lineAngle
         */
        function tryDecodeBruteForce(box, line, lineAngle) {
            var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2)),
                i,
                slices = 16,
                result = null,
                dir,
                extension,
                xdir = Math.sin(lineAngle),
                ydir = Math.cos(lineAngle);

            for (i = 1; i < slices && result === null; i++) {
                // move line perpendicular to angle
                dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
                extension = {
                    y: dir * xdir,
                    x: dir * ydir
                };
                line[0].y += extension.x;
                line[0].x -= extension.y;
                line[1].y += extension.x;
                line[1].x -= extension.y;

                result = tryDecode(line);
            }
            return result;
        }

        function getLineLength(line) {
            return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
        }

        /**
         * With the help of the configured readers (Code128 or EAN) this function tries to detect a
         * valid barcode pattern within the given area.
         * @param {Object} box The area to search in
         * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
         */
        function _decodeFromBoundingBox(box) {
            var line,
                lineAngle,
                ctx = _canvas.ctx.overlay,
                result,
                lineLength;

            if (true) {
                if (config.debug.drawBoundingBox && ctx) {
                    __WEBPACK_IMPORTED_MODULE_1__common_image_debug__["a" /* default */].drawPath(box, { x: 0, y: 1 }, ctx, { color: "blue", lineWidth: 2 });
                }
            }

            line = getLine(box);
            lineLength = getLineLength(line);
            lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
            line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));
            if (line === null) {
                return null;
            }

            result = tryDecode(line);
            if (result === null) {
                result = tryDecodeBruteForce(box, line, lineAngle);
            }

            if (result === null) {
                return null;
            }

            if (true && result && config.debug.drawScanline && ctx) {
                __WEBPACK_IMPORTED_MODULE_1__common_image_debug__["a" /* default */].drawPath(line, { x: 'x', y: 'y' }, ctx, { color: 'red', lineWidth: 3 });
            }

            return {
                codeResult: result.codeResult,
                line: line,
                angle: lineAngle,
                pattern: result.barcodeLine.line,
                threshold: result.barcodeLine.threshold
            };
        }

        return {
            decodeFromBoundingBox: function decodeFromBoundingBox(box) {
                return _decodeFromBoundingBox(box);
            },
            decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
                var i,
                    result,
                    barcodes = [],
                    multiple = config.multiple;

                for (i = 0; i < boxes.length; i++) {
                    var box = boxes[i];
                    result = _decodeFromBoundingBox(box) || {};
                    result.box = box;

                    if (multiple) {
                        barcodes.push(result);
                    } else if (result.codeResult) {
                        return result;
                    }
                }

                if (multiple) {
                    return {
                        barcodes: barcodes
                    };
                }
            },
            setReaders: function setReaders(readers) {
                config.readers = readers;
                _barcodeReaders.length = 0;
                initReaders();
            }
        };
    }
});

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__ = __webpack_require__(20);


var Bresenham = {};

var Slope = {
    DIR: {
        UP: 1,
        DOWN: -1
    }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */
Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
    var x0 = p1.x | 0,
        y0 = p1.y | 0,
        x1 = p2.x | 0,
        y1 = p2.y | 0,
        steep = Math.abs(y1 - y0) > Math.abs(x1 - x0),
        deltax,
        deltay,
        error,
        ystep,
        y,
        tmp,
        x,
        line = [],
        imageData = imageWrapper.data,
        width = imageWrapper.size.x,
        sum = 0,
        val,
        min = 255,
        max = 0;

    function read(a, b) {
        val = imageData[b * width + a];
        sum += val;
        min = val < min ? val : min;
        max = val > max ? val : max;
        line.push(val);
    }

    if (steep) {
        tmp = x0;
        x0 = y0;
        y0 = tmp;

        tmp = x1;
        x1 = y1;
        y1 = tmp;
    }
    if (x0 > x1) {
        tmp = x0;
        x0 = x1;
        x1 = tmp;

        tmp = y0;
        y0 = y1;
        y1 = tmp;
    }
    deltax = x1 - x0;
    deltay = Math.abs(y1 - y0);
    error = deltax / 2 | 0;
    y = y0;
    ystep = y0 < y1 ? 1 : -1;
    for (x = x0; x < x1; x++) {
        if (steep) {
            read(y, x);
        } else {
            read(x, y);
        }
        error = error - deltay;
        if (error < 0) {
            y = y + ystep;
            error = error + deltax;
        }
    }

    return {
        line: line,
        min: min,
        max: max
    };
};

/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */
Bresenham.toBinaryLine = function (result) {
    var min = result.min,
        max = result.max,
        line = result.line,
        slope,
        slope2,
        center = min + (max - min) / 2,
        extrema = [],
        currentDir,
        dir,
        threshold = (max - min) / 12,
        rThreshold = -threshold,
        i,
        j;

    // 1. find extrema
    currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
    extrema.push({
        pos: 0,
        val: line[0]
    });
    for (i = 0; i < line.length - 2; i++) {
        slope = line[i + 1] - line[i];
        slope2 = line[i + 2] - line[i + 1];
        if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
            dir = Slope.DIR.DOWN;
        } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
            dir = Slope.DIR.UP;
        } else {
            dir = currentDir;
        }

        if (currentDir !== dir) {
            extrema.push({
                pos: i,
                val: line[i]
            });
            currentDir = dir;
        }
    }
    extrema.push({
        pos: line.length,
        val: line[line.length - 1]
    });

    for (j = extrema[0].pos; j < extrema[1].pos; j++) {
        line[j] = line[j] > center ? 0 : 1;
    }

    // iterate over extrema and convert to binary based on avg between minmax
    for (i = 1; i < extrema.length - 1; i++) {
        if (extrema[i + 1].val > extrema[i].val) {
            threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
        } else {
            threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
        }

        for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
            line[j] = line[j] > threshold ? 0 : 1;
        }
    }

    return {
        line: line,
        threshold: threshold
    };
};

/**
 * Used for development only
 */
Bresenham.debug = {
    printFrequency: function printFrequency(line, canvas) {
        var i,
            ctx = canvas.getContext("2d");
        canvas.width = line.length;
        canvas.height = 256;

        ctx.beginPath();
        ctx.strokeStyle = "blue";
        for (i = 0; i < line.length; i++) {
            ctx.moveTo(i, 255);
            ctx.lineTo(i, 255 - line[i]);
        }
        ctx.stroke();
        ctx.closePath();
    },

    printPattern: function printPattern(line, canvas) {
        var ctx = canvas.getContext("2d"),
            i;

        canvas.width = line.length;
        ctx.fillColor = "black";
        for (i = 0; i < line.length; i++) {
            if (line[i] === 1) {
                ctx.fillRect(i, 0, 1, 100);
            }
        }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Bresenham);

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export pickConstraints */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_pick__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_pick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_pick__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_mediaDevices__ = __webpack_require__(52);




var facingMatching = {
    "user": /front/i,
    "environment": /back/i
};

var streamRef;

function waitForVideo(video) {
    return new Promise(function (resolve, reject) {
        var attempts = 10;

        function checkVideo() {
            if (attempts > 0) {
                if (video.videoWidth > 10 && video.videoHeight > 10) {
                    if (true) {
                        console.log(video.videoWidth + "px x " + video.videoHeight + "px");
                    }
                    resolve();
                } else {
                    window.setTimeout(checkVideo, 500);
                }
            } else {
                reject(new Error('Unable to play video stream. Is webcam working?'));
            }
            attempts--;
        }
        checkVideo();
    });
}

/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */
function initCamera(video, constraints) {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_mediaDevices__["a" /* getUserMedia */])(constraints).then(function (stream) {
        return new Promise(function (resolve, reject) {
            streamRef = stream;
            video.setAttribute("autoplay", true);
            video.setAttribute('muted', true);
            video.setAttribute('playsinline', true);
            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
                video.play().then(resolve).catch(reject);
            });
        });
    }).then(waitForVideo.bind(null, video));
}

function deprecatedConstraints(videoConstraints) {
    var normalized = __WEBPACK_IMPORTED_MODULE_0_lodash_pick___default()(videoConstraints, ["width", "height", "facingMode", "aspectRatio", "deviceId"]);

    if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
        normalized.aspectRatio = videoConstraints.minAspectRatio;
        console.log("WARNING: Constraint 'minAspectRatio' is deprecated; Use 'aspectRatio' instead");
    }
    if (typeof videoConstraints.facing !== 'undefined') {
        normalized.facingMode = videoConstraints.facing;
        console.log("WARNING: Constraint 'facing' is deprecated. Use 'facingMode' instead'");
    }
    return normalized;
}

function pickConstraints(videoConstraints) {
    var normalizedConstraints = {
        audio: false,
        video: deprecatedConstraints(videoConstraints)
    };

    if (normalizedConstraints.video.deviceId && normalizedConstraints.video.facingMode) {
        delete normalizedConstraints.video.facingMode;
    }
    return Promise.resolve(normalizedConstraints);
}

function enumerateVideoDevices() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_mediaDevices__["b" /* enumerateDevices */])().then(function (devices) {
        return devices.filter(function (device) {
            return device.kind === 'videoinput';
        });
    });
}

function getActiveTrack() {
    if (streamRef) {
        var tracks = streamRef.getVideoTracks();
        if (tracks && tracks.length) {
            return tracks[0];
        }
    }
}

/* harmony default export */ __webpack_exports__["a"] = ({
    request: function request(video, videoConstraints) {
        return pickConstraints(videoConstraints).then(initCamera.bind(null, video));
    },
    release: function release() {
        var tracks = streamRef && streamRef.getVideoTracks();
        if (tracks && tracks.length) {
            tracks[0].stop();
        }
        streamRef = null;
    },
    enumerateVideoDevices: enumerateVideoDevices,
    getActiveStreamLabel: function getActiveStreamLabel() {
        var track = getActiveTrack();
        return track ? track.label : '';
    },
    getActiveTrack: getActiveTrack
});

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export AvailableTags */
/* harmony export (immutable) */ __webpack_exports__["a"] = findTagsInObjectURL;
/* unused harmony export base64ToArrayBuffer */
/* unused harmony export findTagsInBuffer */
// Scraped from https://github.com/exif-js/exif-js

var ExifTags = { 0x0112: "orientation" };
var AvailableTags = Object.keys(ExifTags).map(function (key) {
    return ExifTags[key];
});

function findTagsInObjectURL(src) {
    var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

    if (/^blob\:/i.test(src)) {
        return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
            return findTagsInBuffer(buffer, tags);
        });
    }
    return Promise.resolve(null);
}

function base64ToArrayBuffer(dataUrl) {
    var base64 = dataUrl.replace(/^data\:([^\;]+)\;base64,/gmi, ''),
        binary = atob(base64),
        len = binary.length,
        buffer = new ArrayBuffer(len),
        view = new Uint8Array(buffer);

    for (var i = 0; i < len; i++) {
        view[i] = binary.charCodeAt(i);
    }
    return buffer;
}

function readToBuffer(blob) {
    return new Promise(function (resolve) {
        var fileReader = new FileReader();
        fileReader.onload = function (e) {
            return resolve(e.target.result);
        };
        fileReader.readAsArrayBuffer(blob);
    });
}

function objectURLToBlob(url) {
    return new Promise(function (resolve, reject) {
        var http = new XMLHttpRequest();
        http.open("GET", url, true);
        http.responseType = "blob";
        http.onreadystatechange = function () {
            if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
                resolve(this.response);
            }
        };
        http.onerror = reject;
        http.send();
    });
}

function findTagsInBuffer(file) {
    var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

    var dataView = new DataView(file),
        length = file.byteLength,
        exifTags = selectedTags.reduce(function (result, selectedTag) {
        var exifTag = Object.keys(ExifTags).filter(function (tag) {
            return ExifTags[tag] === selectedTag;
        })[0];
        if (exifTag) {
            result[exifTag] = selectedTag;
        }
        return result;
    }, {});
    var offset = 2,
        marker = void 0;

    if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
        return false;
    }

    while (offset < length) {
        if (dataView.getUint8(offset) !== 0xFF) {
            return false;
        }

        marker = dataView.getUint8(offset + 1);
        if (marker === 0xE1) {
            return readEXIFData(dataView, offset + 4, exifTags);
        } else {
            offset += 2 + dataView.getUint16(offset + 2);
        }
    }
}

function readEXIFData(file, start, exifTags) {
    if (getStringFromBuffer(file, start, 4) !== "Exif") {
        return false;
    }

    var tiffOffset = start + 6;
    var bigEnd = void 0,
        tags = void 0;

    if (file.getUint16(tiffOffset) === 0x4949) {
        bigEnd = false;
    } else if (file.getUint16(tiffOffset) === 0x4D4D) {
        bigEnd = true;
    } else {
        return false;
    }

    if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
        return false;
    }

    var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);
    if (firstIFDOffset < 0x00000008) {
        return false;
    }

    tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
    return tags;
}

function readTags(file, tiffStart, dirStart, strings, bigEnd) {
    var entries = file.getUint16(dirStart, !bigEnd),
        tags = {};

    for (var i = 0; i < entries; i++) {
        var entryOffset = dirStart + i * 12 + 2,
            tag = strings[file.getUint16(entryOffset, !bigEnd)];
        if (tag) {
            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
        }
    }
    return tags;
}

function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
    var type = file.getUint16(entryOffset + 2, !bigEnd),
        numValues = file.getUint32(entryOffset + 4, !bigEnd);

    switch (type) {
        case 3:
            if (numValues === 1) {
                return file.getUint16(entryOffset + 8, !bigEnd);
            }
    }
}

function getStringFromBuffer(buffer, start, length) {
    var outstr = "";
    for (var n = start; n < start + length; n++) {
        outstr += String.fromCharCode(buffer.getUint8(n));
    }
    return outstr;
}

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_cv_utils__ = __webpack_require__(19);


var TO_RADIANS = Math.PI / 180;

function adjustCanvasSize(canvas, targetSize) {
    if (canvas.width !== targetSize.x) {
        if (true) {
            console.log("WARNING: canvas-size needs to be adjusted");
        }
        canvas.width = targetSize.x;
    }
    if (canvas.height !== targetSize.y) {
        if (true) {
            console.log("WARNING: canvas-size needs to be adjusted");
        }
        canvas.height = targetSize.y;
    }
}

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
    var _that = {},
        _streamConfig = inputStream.getConfig(),
        _video_size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_cv_utils__["b" /* imageRef */])(inputStream.getRealWidth(), inputStream.getRealHeight()),
        _canvasSize = inputStream.getCanvasSize(),
        _size = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_cv_utils__["b" /* imageRef */])(inputStream.getWidth(), inputStream.getHeight()),
        topRight = inputStream.getTopRight(),
        _sx = topRight.x,
        _sy = topRight.y,
        _canvas,
        _ctx = null,
        _data = null;

    _canvas = canvas ? canvas : document.createElement("canvas");
    _canvas.width = _canvasSize.x;
    _canvas.height = _canvasSize.y;
    _ctx = _canvas.getContext("2d");
    _data = new Uint8Array(_size.x * _size.y);
    if (true) {
        console.log("FrameGrabber", JSON.stringify({
            size: _size,
            topRight: topRight,
            videoSize: _video_size,
            canvasSize: _canvasSize
        }));
    }

    /**
     * Uses the given array as frame-buffer
     */
    _that.attachData = function (data) {
        _data = data;
    };

    /**
     * Returns the used frame-buffer
     */
    _that.getData = function () {
        return _data;
    };

    /**
     * Fetches a frame from the input-stream and puts into the frame-buffer.
     * The image-data is converted to gray-scale and then half-sampled if configured.
     */
    _that.grab = function () {
        var doHalfSample = _streamConfig.halfSample,
            frame = inputStream.getFrame(),
            drawable = frame,
            drawAngle = 0,
            ctxData;
        if (drawable) {
            adjustCanvasSize(_canvas, _canvasSize);
            if (_streamConfig.type === 'ImageStream') {
                drawable = frame.img;
                if (frame.tags && frame.tags.orientation) {
                    switch (frame.tags.orientation) {
                        case 6:
                            drawAngle = 90 * TO_RADIANS;
                            break;
                        case 8:
                            drawAngle = -90 * TO_RADIANS;
                            break;
                    }
                }
            }

            if (drawAngle !== 0) {
                _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);
                _ctx.rotate(drawAngle);
                _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);
                _ctx.rotate(-drawAngle);
                _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
            } else {
                _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
            }

            ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;
            if (doHalfSample) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_cv_utils__["c" /* grayAndHalfSampleFromCanvasData */])(ctxData, _size, _data);
            } else {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_cv_utils__["d" /* computeGray */])(ctxData, _data, _streamConfig);
            }
            return true;
        } else {
            return false;
        }
    };

    _that.getSize = function () {
        return _size;
    };

    return _that;
};

/* harmony default export */ __webpack_exports__["a"] = (FrameGrabber);

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__exif_helper__ = __webpack_require__(60);


var ImageLoader = {};
ImageLoader.load = function (directory, callback, offset, size, sequence) {
    var htmlImagesSrcArray = new Array(size),
        htmlImagesArray = new Array(htmlImagesSrcArray.length),
        i,
        img,
        num;

    if (sequence === false) {
        htmlImagesSrcArray[0] = directory;
    } else {
        for (i = 0; i < htmlImagesSrcArray.length; i++) {
            num = offset + i;
            htmlImagesSrcArray[i] = directory + "image-" + ("00" + num).slice(-3) + ".jpg";
        }
    }
    htmlImagesArray.notLoaded = [];
    htmlImagesArray.addImage = function (image) {
        htmlImagesArray.notLoaded.push(image);
    };
    htmlImagesArray.loaded = function (loadedImg) {
        var notloadedImgs = htmlImagesArray.notLoaded;
        for (var x = 0; x < notloadedImgs.length; x++) {
            if (notloadedImgs[x] === loadedImg) {
                notloadedImgs.splice(x, 1);
                for (var y = 0; y < htmlImagesSrcArray.length; y++) {
                    var imgName = htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf("/"));
                    if (loadedImg.src.lastIndexOf(imgName) !== -1) {
                        htmlImagesArray[y] = { img: loadedImg };
                        break;
                    }
                }
                break;
            }
        }
        if (notloadedImgs.length === 0) {
            if (true) {
                console.log("Images loaded");
            }
            if (sequence === false) {
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__exif_helper__["a" /* findTagsInObjectURL */])(directory, ['orientation']).then(function (tags) {
                    htmlImagesArray[0].tags = tags;
                    callback(htmlImagesArray);
                }).catch(function (e) {
                    console.log(e);
                    callback(htmlImagesArray);
                });
            } else {
                callback(htmlImagesArray);
            }
        }
    };

    for (i = 0; i < htmlImagesSrcArray.length; i++) {
        img = new Image();
        htmlImagesArray.addImage(img);
        addOnloadHandler(img, htmlImagesArray);
        img.src = htmlImagesSrcArray[i];
    }
};

function addOnloadHandler(img, htmlImagesArray) {
    img.onload = function () {
        htmlImagesArray.loaded(this);
    };
}

/* harmony default export */ __webpack_exports__["a"] = (ImageLoader);

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__image_loader__ = __webpack_require__(62);


var InputStream = {};
InputStream.createVideoStream = function (video) {
    var that = {},
        _config = null,
        _eventNames = ['canrecord', 'ended'],
        _eventHandlers = {},
        _calculatedWidth,
        _calculatedHeight,
        _topRight = { x: 0, y: 0 },
        _canvasSize = { x: 0, y: 0 };

    function initSize() {
        var width = video.videoWidth,
            height = video.videoHeight;

        _calculatedWidth = _config.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
        _calculatedHeight = _config.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;

        _canvasSize.x = _calculatedWidth;
        _canvasSize.y = _calculatedHeight;
    }

    that.getRealWidth = function () {
        return video.videoWidth;
    };

    that.getRealHeight = function () {
        return video.videoHeight;
    };

    that.getWidth = function () {
        return _calculatedWidth;
    };

    that.getHeight = function () {
        return _calculatedHeight;
    };

    that.setWidth = function (width) {
        _calculatedWidth = width;
    };

    that.setHeight = function (height) {
        _calculatedHeight = height;
    };

    that.setInputStream = function (config) {
        _config = config;
        video.src = typeof config.src !== 'undefined' ? config.src : '';
    };

    that.ended = function () {
        return video.ended;
    };

    that.getConfig = function () {
        return _config;
    };

    that.setAttribute = function (name, value) {
        video.setAttribute(name, value);
    };

    that.pause = function () {
        video.pause();
    };

    that.play = function () {
        video.play();
    };

    that.setCurrentTime = function (time) {
        if (_config.type !== "LiveStream") {
            video.currentTime = time;
        }
    };

    that.addEventListener = function (event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
            if (!_eventHandlers[event]) {
                _eventHandlers[event] = [];
            }
            _eventHandlers[event].push(f);
        } else {
            video.addEventListener(event, f, bool);
        }
    };

    that.clearEventHandlers = function () {
        _eventNames.forEach(function (eventName) {
            var handlers = _eventHandlers[eventName];
            if (handlers && handlers.length > 0) {
                handlers.forEach(function (handler) {
                    video.removeEventListener(eventName, handler);
                });
            }
        });
    };

    that.trigger = function (eventName, args) {
        var j,
            handlers = _eventHandlers[eventName];

        if (eventName === 'canrecord') {
            initSize();
        }
        if (handlers && handlers.length > 0) {
            for (j = 0; j < handlers.length; j++) {
                handlers[j].apply(that, args);
            }
        }
    };

    that.setTopRight = function (topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
    };

    that.getTopRight = function () {
        return _topRight;
    };

    that.setCanvasSize = function (size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
    };

    that.getCanvasSize = function () {
        return _canvasSize;
    };

    that.getFrame = function () {
        return video;
    };

    return that;
};

InputStream.createLiveStream = function (video) {
    video.setAttribute("autoplay", true);
    var that = InputStream.createVideoStream(video);

    that.ended = function () {
        return false;
    };

    return that;
};

InputStream.createImageStream = function () {
    var that = {};
    var _config = null;

    var width = 0,
        height = 0,
        frameIdx = 0,
        paused = true,
        loaded = false,
        imgArray = null,
        size = 0,
        offset = 1,
        baseUrl = null,
        ended = false,
        calculatedWidth,
        calculatedHeight,
        _eventNames = ['canrecord', 'ended'],
        _eventHandlers = {},
        _topRight = { x: 0, y: 0 },
        _canvasSize = { x: 0, y: 0 };

    function loadImages() {
        loaded = false;
        __WEBPACK_IMPORTED_MODULE_0__image_loader__["a" /* default */].load(baseUrl, function (imgs) {
            imgArray = imgs;
            if (imgs[0].tags && imgs[0].tags.orientation) {
                switch (imgs[0].tags.orientation) {
                    case 6:
                    case 8:
                        width = imgs[0].img.height;
                        height = imgs[0].img.width;
                        break;
                    default:
                        width = imgs[0].img.width;
                        height = imgs[0].img.height;
                }
            } else {
                width = imgs[0].img.width;
                height = imgs[0].img.height;
            }
            calculatedWidth = _config.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
            calculatedHeight = _config.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
            _canvasSize.x = calculatedWidth;
            _canvasSize.y = calculatedHeight;
            loaded = true;
            frameIdx = 0;
            setTimeout(function () {
                publishEvent("canrecord", []);
            }, 0);
        }, offset, size, _config.sequence);
    }

    function publishEvent(eventName, args) {
        var j,
            handlers = _eventHandlers[eventName];

        if (handlers && handlers.length > 0) {
            for (j = 0; j < handlers.length; j++) {
                handlers[j].apply(that, args);
            }
        }
    }

    that.trigger = publishEvent;

    that.getWidth = function () {
        return calculatedWidth;
    };

    that.getHeight = function () {
        return calculatedHeight;
    };

    that.setWidth = function (newWidth) {
        calculatedWidth = newWidth;
    };

    that.setHeight = function (newHeight) {
        calculatedHeight = newHeight;
    };

    that.getRealWidth = function () {
        return width;
    };

    that.getRealHeight = function () {
        return height;
    };

    that.setInputStream = function (stream) {
        _config = stream;
        if (stream.sequence === false) {
            baseUrl = stream.src;
            size = 1;
        } else {
            baseUrl = stream.src;
            size = stream.length;
        }
        loadImages();
    };

    that.ended = function () {
        return ended;
    };

    that.setAttribute = function () {};

    that.getConfig = function () {
        return _config;
    };

    that.pause = function () {
        paused = true;
    };

    that.play = function () {
        paused = false;
    };

    that.setCurrentTime = function (time) {
        frameIdx = time;
    };

    that.addEventListener = function (event, f) {
        if (_eventNames.indexOf(event) !== -1) {
            if (!_eventHandlers[event]) {
                _eventHandlers[event] = [];
            }
            _eventHandlers[event].push(f);
        }
    };

    that.setTopRight = function (topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
    };

    that.getTopRight = function () {
        return _topRight;
    };

    that.setCanvasSize = function (canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
    };

    that.getCanvasSize = function () {
        return _canvasSize;
    };

    that.getFrame = function () {
        var frame;

        if (!loaded) {
            return null;
        }
        if (!paused) {
            frame = imgArray[frameIdx];
            if (frameIdx < size - 1) {
                frameIdx++;
            } else {
                setTimeout(function () {
                    ended = true;
                    publishEvent("ended", []);
                }, 0);
            }
        }
        return frame;
    };

    return that;
};

/* harmony default export */ __webpack_exports__["a"] = (InputStream);

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_cv_utils__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_array_helper__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_image_debug__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__rasterizer__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__tracer__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__skeletonizer__ = __webpack_require__(66);







var vec2 = {
    clone: __webpack_require__(7),
    dot: __webpack_require__(32),
    scale: __webpack_require__(81),
    transformMat2: __webpack_require__(82)
};
var mat2 = {
    copy: __webpack_require__(78),
    create: __webpack_require__(79),
    invert: __webpack_require__(80)
};

var _config,
    _currentImageWrapper,
    _skelImageWrapper,
    _subImageWrapper,
    _labelImageWrapper,
    _patchGrid,
    _patchLabelGrid,
    _imageToPatchGrid,
    _binaryImageWrapper,
    _patchSize,
    _canvasContainer = {
    ctx: {
        binary: null
    },
    dom: {
        binary: null
    }
},
    _numPatches = { x: 0, y: 0 },
    _inputImageWrapper,
    _skeletonizer;

function initBuffers() {
    var skeletonImageData;

    if (_config.halfSample) {
        _currentImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */]({
            x: _inputImageWrapper.size.x / 2 | 0,
            y: _inputImageWrapper.size.y / 2 | 0
        });
    } else {
        _currentImageWrapper = _inputImageWrapper;
    }

    _patchSize = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["e" /* calculatePatchSize */])(_config.patchSize, _currentImageWrapper.size);

    _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0;
    _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;

    _binaryImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_currentImageWrapper.size, undefined, Uint8Array, false);

    _labelImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_patchSize, undefined, Array, true);

    skeletonImageData = new ArrayBuffer(64 * 1024);
    _subImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
    _skelImageWrapper = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
    _skeletonizer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__skeletonizer__["a" /* default */])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
        size: _patchSize.x
    }, skeletonImageData);

    _imageToPatchGrid = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */]({
        x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
        y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
    }, undefined, Array, true);
    _patchGrid = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_imageToPatchGrid.size, undefined, undefined, true);
    _patchLabelGrid = new __WEBPACK_IMPORTED_MODULE_0__common_image_wrapper__["a" /* default */](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
    if (_config.useWorker || typeof document === 'undefined') {
        return;
    }
    _canvasContainer.dom.binary = document.createElement("canvas");
    _canvasContainer.dom.binary.className = "binaryBuffer";
    if (true && _config.debug.showCanvas === true) {
        document.querySelector("#debug").appendChild(_canvasContainer.dom.binary);
    }
    _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext("2d");
    _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
    _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}

/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */
function boxFromPatches(patches) {
    var overAvg,
        i,
        j,
        patch,
        transMat,
        minx = _binaryImageWrapper.size.x,
        miny = _binaryImageWrapper.size.y,
        maxx = -_binaryImageWrapper.size.x,
        maxy = -_binaryImageWrapper.size.y,
        box,
        scale;

    // draw all patches which are to be taken into consideration
    overAvg = 0;
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        overAvg += patch.rad;
        if (true && _config.debug.showPatches) {
            __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "red" });
        }
    }

    overAvg /= patches.length;
    overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;
    if (overAvg < 0) {
        overAvg += 180;
    }

    overAvg = (180 - overAvg) * Math.PI / 180;
    transMat = mat2.copy(mat2.create(), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]);

    // iterate over patches and rotate by angle
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        for (j = 0; j < 4; j++) {
            vec2.transformMat2(patch.box[j], patch.box[j], transMat);
        }

        if (true && _config.debug.boxFromPatches.showTransformed) {
            __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawPath(patch.box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#99ff00', lineWidth: 2 });
        }
    }

    // find bounding box
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        for (j = 0; j < 4; j++) {
            if (patch.box[j][0] < minx) {
                minx = patch.box[j][0];
            }
            if (patch.box[j][0] > maxx) {
                maxx = patch.box[j][0];
            }
            if (patch.box[j][1] < miny) {
                miny = patch.box[j][1];
            }
            if (patch.box[j][1] > maxy) {
                maxy = patch.box[j][1];
            }
        }
    }

    box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

    if (true && _config.debug.boxFromPatches.showTransformedBox) {
        __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawPath(box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#ff0000', lineWidth: 2 });
    }

    scale = _config.halfSample ? 2 : 1;
    // reverse rotation;
    transMat = mat2.invert(transMat, transMat);
    for (j = 0; j < 4; j++) {
        vec2.transformMat2(box[j], box[j], transMat);
    }

    if (true && _config.debug.boxFromPatches.showBB) {
        __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawPath(box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#ff0000', lineWidth: 2 });
    }

    for (j = 0; j < 4; j++) {
        vec2.scale(box[j], box[j], scale);
    }

    return box;
}

/**
 * Creates a binary image of the current image
 */
function binarizeImage() {
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["f" /* otsuThreshold */])(_currentImageWrapper, _binaryImageWrapper);
    _binaryImageWrapper.zeroBorder();
    if (true && _config.debug.showCanvas) {
        _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
    }
}

/**
 * Iterate over the entire image
 * extract patches
 */
function findPatches() {
    var i,
        j,
        x,
        y,
        moments,
        patchesFound = [],
        rasterizer,
        rasterResult,
        patch;
    for (i = 0; i < _numPatches.x; i++) {
        for (j = 0; j < _numPatches.y; j++) {
            x = _subImageWrapper.size.x * i;
            y = _subImageWrapper.size.y * j;

            // seperate parts
            skeletonize(x, y);

            // Rasterize, find individual bars
            _skelImageWrapper.zeroBorder();
            __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(_labelImageWrapper.data, 0);
            rasterizer = __WEBPACK_IMPORTED_MODULE_4__rasterizer__["a" /* default */].create(_skelImageWrapper, _labelImageWrapper);
            rasterResult = rasterizer.rasterize(0);

            if (true && _config.debug.showLabels) {
                _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), { x: x, y: y });
            }

            // calculate moments from the skeletonized patch
            moments = _labelImageWrapper.moments(rasterResult.count);

            // extract eligible patches
            patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
        }
    }

    if (true && _config.debug.showFoundPatches) {
        for (i = 0; i < patchesFound.length; i++) {
            patch = patchesFound[i];
            __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "#99ff00", lineWidth: 2 });
        }
    }

    return patchesFound;
}

/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */
function findBiggestConnectedAreas(maxLabel) {
    var i,
        sum,
        labelHist = [],
        topLabels = [];

    for (i = 0; i < maxLabel; i++) {
        labelHist.push(0);
    }
    sum = _patchLabelGrid.data.length;
    while (sum--) {
        if (_patchLabelGrid.data[sum] > 0) {
            labelHist[_patchLabelGrid.data[sum] - 1]++;
        }
    }

    labelHist = labelHist.map(function (val, idx) {
        return {
            val: val,
            label: idx + 1
        };
    });

    labelHist.sort(function (a, b) {
        return b.val - a.val;
    });

    // extract top areas with at least 6 patches present
    topLabels = labelHist.filter(function (el) {
        return el.val >= 5;
    });

    return topLabels;
}

/**
 *
 */
function findBoxes(topLabels, maxLabel) {
    var i,
        j,
        sum,
        patches = [],
        patch,
        box,
        boxes = [],
        hsv = [0, 1, 1],
        rgb = [0, 0, 0];

    for (i = 0; i < topLabels.length; i++) {
        sum = _patchLabelGrid.data.length;
        patches.length = 0;
        while (sum--) {
            if (_patchLabelGrid.data[sum] === topLabels[i].label) {
                patch = _imageToPatchGrid.data[sum];
                patches.push(patch);
            }
        }
        box = boxFromPatches(patches);
        if (box) {
            boxes.push(box);

            // draw patch-labels if requested
            if (true && _config.debug.showRemainingPatchLabels) {
                for (j = 0; j < patches.length; j++) {
                    patch = patches[j];
                    hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
                    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["a" /* hsv2rgb */])(hsv, rgb);
                    __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "rgb(" + rgb.join(",") + ")", lineWidth: 2 });
                }
            }
        }
    }
    return boxes;
}

/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */
function similarMoments(moments) {
    var clusters = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["g" /* cluster */])(moments, 0.90);
    var topCluster = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["h" /* topGeneric */])(clusters, 1, function (e) {
        return e.getPoints().length;
    });
    var points = [],
        result = [];
    if (topCluster.length === 1) {
        points = topCluster[0].item.getPoints();
        for (var i = 0; i < points.length; i++) {
            result.push(points[i].point);
        }
    }
    return result;
}

function skeletonize(x, y) {
    _binaryImageWrapper.subImageAsCopy(_subImageWrapper, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["b" /* imageRef */])(x, y));
    _skeletonizer.skeletonize();

    // Show skeleton if requested
    if (true && _config.debug.showSkeleton) {
        _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["b" /* imageRef */])(x, y));
    }
}

/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */
function describePatch(moments, patchPos, x, y) {
    var k,
        avg,
        eligibleMoments = [],
        matchingMoments,
        patch,
        patchesFound = [],
        minComponentWeight = Math.ceil(_patchSize.x / 3);

    if (moments.length >= 2) {
        // only collect moments which's area covers at least minComponentWeight pixels.
        for (k = 0; k < moments.length; k++) {
            if (moments[k].m00 > minComponentWeight) {
                eligibleMoments.push(moments[k]);
            }
        }

        // if at least 2 moments are found which have at least minComponentWeights covered
        if (eligibleMoments.length >= 2) {
            matchingMoments = similarMoments(eligibleMoments);
            avg = 0;
            // determine the similarity of the moments
            for (k = 0; k < matchingMoments.length; k++) {
                avg += matchingMoments[k].rad;
            }

            // Only two of the moments are allowed not to fit into the equation
            // add the patch to the set
            if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
                avg /= matchingMoments.length;
                patch = {
                    index: patchPos[1] * _numPatches.x + patchPos[0],
                    pos: {
                        x: x,
                        y: y
                    },
                    box: [vec2.clone([x, y]), vec2.clone([x + _subImageWrapper.size.x, y]), vec2.clone([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), vec2.clone([x, y + _subImageWrapper.size.y])],
                    moments: matchingMoments,
                    rad: avg,
                    vec: vec2.clone([Math.cos(avg), Math.sin(avg)])
                };
                patchesFound.push(patch);
            }
        }
    }
    return patchesFound;
}

/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */
function rasterizeAngularSimilarity(patchesFound) {
    var label = 0,
        threshold = 0.95,
        currIdx = 0,
        j,
        patch,
        hsv = [0, 1, 1],
        rgb = [0, 0, 0];

    function notYetProcessed() {
        var i;
        for (i = 0; i < _patchLabelGrid.data.length; i++) {
            if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
                return i;
            }
        }
        return _patchLabelGrid.length;
    }

    function trace(currentIdx) {
        var x,
            y,
            currentPatch,
            idx,
            dir,
            current = {
            x: currentIdx % _patchLabelGrid.size.x,
            y: currentIdx / _patchLabelGrid.size.x | 0
        },
            similarity;

        if (currentIdx < _patchLabelGrid.data.length) {
            currentPatch = _imageToPatchGrid.data[currentIdx];
            // assign label
            _patchLabelGrid.data[currentIdx] = label;
            for (dir = 0; dir < __WEBPACK_IMPORTED_MODULE_5__tracer__["a" /* default */].searchDirections.length; dir++) {
                y = current.y + __WEBPACK_IMPORTED_MODULE_5__tracer__["a" /* default */].searchDirections[dir][0];
                x = current.x + __WEBPACK_IMPORTED_MODULE_5__tracer__["a" /* default */].searchDirections[dir][1];
                idx = y * _patchLabelGrid.size.x + x;

                // continue if patch empty
                if (_patchGrid.data[idx] === 0) {
                    _patchLabelGrid.data[idx] = Number.MAX_VALUE;
                    continue;
                }

                if (_patchLabelGrid.data[idx] === 0) {
                    similarity = Math.abs(vec2.dot(_imageToPatchGrid.data[idx].vec, currentPatch.vec));
                    if (similarity > threshold) {
                        trace(idx);
                    }
                }
            }
        }
    }

    // prepare for finding the right patches
    __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(_patchGrid.data, 0);
    __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(_patchLabelGrid.data, 0);
    __WEBPACK_IMPORTED_MODULE_2__common_array_helper__["a" /* default */].init(_imageToPatchGrid.data, null);

    for (j = 0; j < patchesFound.length; j++) {
        patch = patchesFound[j];
        _imageToPatchGrid.data[patch.index] = patch;
        _patchGrid.data[patch.index] = 1;
    }

    // rasterize the patches found to determine area
    _patchGrid.zeroBorder();

    while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
        label++;
        trace(currIdx);
    }

    // draw patch-labels if requested
    if (true && _config.debug.showPatchLabels) {
        for (j = 0; j < _patchLabelGrid.data.length; j++) {
            if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
                patch = _imageToPatchGrid.data[j];
                hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
                __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["a" /* hsv2rgb */])(hsv, rgb);
                __WEBPACK_IMPORTED_MODULE_3__common_image_debug__["a" /* default */].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "rgb(" + rgb.join(",") + ")", lineWidth: 2 });
            }
        }
    }

    return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
    init: function init(inputImageWrapper, config) {
        _config = config;
        _inputImageWrapper = inputImageWrapper;

        initBuffers();
        initCanvas();
    },

    locate: function locate() {
        var patchesFound, topLabels, boxes;

        if (_config.halfSample) {
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["i" /* halfSample */])(_inputImageWrapper, _currentImageWrapper);
        }

        binarizeImage();
        patchesFound = findPatches();
        // return unless 5% or more patches are found
        if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
            return null;
        }

        // rasterrize area by comparing angular similarity;
        var maxLabel = rasterizeAngularSimilarity(patchesFound);
        if (maxLabel < 1) {
            return null;
        }

        // search for area with the most patches (biggest connected area)
        topLabels = findBiggestConnectedAreas(maxLabel);
        if (topLabels.length === 0) {
            return null;
        }

        boxes = findBoxes(topLabels, maxLabel);
        return boxes;
    },

    checkImageConstraints: function checkImageConstraints(inputStream, config) {
        var patchSize,
            width = inputStream.getWidth(),
            height = inputStream.getHeight(),
            halfSample = config.halfSample ? 0.5 : 1,
            size,
            area;

        // calculate width and height based on area
        if (inputStream.getConfig().area) {
            area = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["j" /* computeImageArea */])(width, height, inputStream.getConfig().area);
            inputStream.setTopRight({ x: area.sx, y: area.sy });
            inputStream.setCanvasSize({ x: width, y: height });
            width = area.sw;
            height = area.sh;
        }

        size = {
            x: Math.floor(width * halfSample),
            y: Math.floor(height * halfSample)
        };

        patchSize = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_cv_utils__["e" /* calculatePatchSize */])(config.patchSize, size);
        if (true) {
            console.log("Patch-Size: " + JSON.stringify(patchSize));
        }

        inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / halfSample) * patchSize.x));
        inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / halfSample) * patchSize.y));

        if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
            return true;
        }

        throw new Error("Image dimensions do not comply with the current settings: Width (" + width + " )and height (" + height + ") must a multiple of " + patchSize.x);
    }
});
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(47)))

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tracer__ = __webpack_require__(30);


/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Rasterizer = {
    createContour2D: function createContour2D() {
        return {
            dir: null,
            index: null,
            firstVertex: null,
            insideContours: null,
            nextpeer: null,
            prevpeer: null
        };
    },
    CONTOUR_DIR: {
        CW_DIR: 0,
        CCW_DIR: 1,
        UNKNOWN_DIR: 2
    },
    DIR: {
        OUTSIDE_EDGE: -32767,
        INSIDE_EDGE: -32766
    },
    create: function create(imageWrapper, labelWrapper) {
        var imageData = imageWrapper.data,
            labelData = labelWrapper.data,
            width = imageWrapper.size.x,
            height = imageWrapper.size.y,
            tracer = __WEBPACK_IMPORTED_MODULE_0__tracer__["a" /* default */].create(imageWrapper, labelWrapper);

        return {
            rasterize: function rasterize(depthlabel) {
                var color,
                    bc,
                    lc,
                    labelindex,
                    cx,
                    cy,
                    colorMap = [],
                    vertex,
                    p,
                    cc,
                    sc,
                    pos,
                    connectedCount = 0,
                    i;

                for (i = 0; i < 400; i++) {
                    colorMap[i] = 0;
                }

                colorMap[0] = imageData[0];
                cc = null;
                for (cy = 1; cy < height - 1; cy++) {
                    labelindex = 0;
                    bc = colorMap[0];
                    for (cx = 1; cx < width - 1; cx++) {
                        pos = cy * width + cx;
                        if (labelData[pos] === 0) {
                            color = imageData[pos];
                            if (color !== bc) {
                                if (labelindex === 0) {
                                    lc = connectedCount + 1;
                                    colorMap[lc] = color;
                                    bc = color;
                                    vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);
                                    if (vertex !== null) {
                                        connectedCount++;
                                        labelindex = lc;
                                        p = Rasterizer.createContour2D();
                                        p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                                        p.index = labelindex;
                                        p.firstVertex = vertex;
                                        p.nextpeer = cc;
                                        p.insideContours = null;
                                        if (cc !== null) {
                                            cc.prevpeer = p;
                                        }
                                        cc = p;
                                    }
                                } else {
                                    vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);
                                    if (vertex !== null) {
                                        p = Rasterizer.createContour2D();
                                        p.firstVertex = vertex;
                                        p.insideContours = null;
                                        if (depthlabel === 0) {
                                            p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                                        } else {
                                            p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                                        }
                                        p.index = depthlabel;
                                        sc = cc;
                                        while (sc !== null && sc.index !== labelindex) {
                                            sc = sc.nextpeer;
                                        }
                                        if (sc !== null) {
                                            p.nextpeer = sc.insideContours;
                                            if (sc.insideContours !== null) {
                                                sc.insideContours.prevpeer = p;
                                            }
                                            sc.insideContours = p;
                                        }
                                    }
                                }
                            } else {
                                labelData[pos] = labelindex;
                            }
                        } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                            labelindex = 0;
                            if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                                bc = imageData[pos];
                            } else {
                                bc = colorMap[0];
                            }
                        } else {
                            labelindex = labelData[pos];
                            bc = colorMap[labelindex];
                        }
                    }
                }
                sc = cc;
                while (sc !== null) {
                    sc.index = depthlabel;
                    sc = sc.nextpeer;
                }
                return {
                    cc: cc,
                    count: connectedCount
                };
            },
            debug: {
                drawContour: function drawContour(canvas, firstContour) {
                    var ctx = canvas.getContext("2d"),
                        pq = firstContour,
                        iq,
                        q,
                        p;

                    ctx.strokeStyle = "red";
                    ctx.fillStyle = "red";
                    ctx.lineWidth = 1;

                    if (pq !== null) {
                        iq = pq.insideContours;
                    } else {
                        iq = null;
                    }

                    while (pq !== null) {
                        if (iq !== null) {
                            q = iq;
                            iq = iq.nextpeer;
                        } else {
                            q = pq;
                            pq = pq.nextpeer;
                            if (pq !== null) {
                                iq = pq.insideContours;
                            } else {
                                iq = null;
                            }
                        }

                        switch (q.dir) {
                            case Rasterizer.CONTOUR_DIR.CW_DIR:
                                ctx.strokeStyle = "red";
                                break;
                            case Rasterizer.CONTOUR_DIR.CCW_DIR:
                                ctx.strokeStyle = "blue";
                                break;
                            case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                                ctx.strokeStyle = "green";
                                break;
                        }

                        p = q.firstVertex;
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        do {
                            p = p.next;
                            ctx.lineTo(p.x, p.y);
                        } while (p !== q.firstVertex);
                        ctx.stroke();
                    }
                }
            }
        };
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* @preserve ASM BEGIN */
/* eslint-disable eqeqeq*/
function Skeletonizer(stdlib, foreign, buffer) {
    "use asm";

    var images = new stdlib.Uint8Array(buffer),
        size = foreign.size | 0,
        imul = stdlib.Math.imul;

    function erode(inImagePtr, outImagePtr) {
        inImagePtr = inImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var v = 0,
            u = 0,
            sum = 0,
            yStart1 = 0,
            yStart2 = 0,
            xStart1 = 0,
            xStart2 = 0,
            offset = 0;

        for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
            offset = offset + size | 0;
            for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
                yStart1 = offset - size | 0;
                yStart2 = offset + size | 0;
                xStart1 = u - 1 | 0;
                xStart2 = u + 1 | 0;
                sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
                if ((sum | 0) == (5 | 0)) {
                    images[outImagePtr + offset + u | 0] = 1;
                } else {
                    images[outImagePtr + offset + u | 0] = 0;
                }
            }
        }
        return;
    }

    function subtract(aImagePtr, bImagePtr, outImagePtr) {
        aImagePtr = aImagePtr | 0;
        bImagePtr = bImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
        }
    }

    function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
        aImagePtr = aImagePtr | 0;
        bImagePtr = bImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
        }
    }

    function countNonZero(imagePtr) {
        imagePtr = imagePtr | 0;

        var sum = 0,
            length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
        }

        return sum | 0;
    }

    function init(imagePtr, value) {
        imagePtr = imagePtr | 0;
        value = value | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[imagePtr + length | 0] = value;
        }
    }

    function dilate(inImagePtr, outImagePtr) {
        inImagePtr = inImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var v = 0,
            u = 0,
            sum = 0,
            yStart1 = 0,
            yStart2 = 0,
            xStart1 = 0,
            xStart2 = 0,
            offset = 0;

        for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
            offset = offset + size | 0;
            for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
                yStart1 = offset - size | 0;
                yStart2 = offset + size | 0;
                xStart1 = u - 1 | 0;
                xStart2 = u + 1 | 0;
                sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
                if ((sum | 0) > (0 | 0)) {
                    images[outImagePtr + offset + u | 0] = 1;
                } else {
                    images[outImagePtr + offset + u | 0] = 0;
                }
            }
        }
        return;
    }

    function memcpy(srcImagePtr, dstImagePtr) {
        srcImagePtr = srcImagePtr | 0;
        dstImagePtr = dstImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
        }
    }

    function zeroBorder(imagePtr) {
        imagePtr = imagePtr | 0;

        var x = 0,
            y = 0;

        for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
            images[imagePtr + x | 0] = 0;
            images[imagePtr + y | 0] = 0;
            y = y + size - 1 | 0;
            images[imagePtr + y | 0] = 0;
            y = y + 1 | 0;
        }
        for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
            images[imagePtr + y | 0] = 0;
            y = y + 1 | 0;
        }
    }

    function skeletonize() {
        var subImagePtr = 0,
            erodedImagePtr = 0,
            tempImagePtr = 0,
            skelImagePtr = 0,
            sum = 0,
            done = 0;

        erodedImagePtr = imul(size, size) | 0;
        tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
        skelImagePtr = tempImagePtr + erodedImagePtr | 0;

        // init skel-image
        init(skelImagePtr, 0);
        zeroBorder(subImagePtr);

        do {
            erode(subImagePtr, erodedImagePtr);
            dilate(erodedImagePtr, tempImagePtr);
            subtract(subImagePtr, tempImagePtr, tempImagePtr);
            bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
            memcpy(erodedImagePtr, subImagePtr);
            sum = countNonZero(subImagePtr) | 0;
            done = (sum | 0) == 0 | 0;
        } while (!done);
    }
    return {
        skeletonize: skeletonize
    };
}
/* @preserve ASM END */
/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq*/

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);


function TwoOfFiveReader(opts) {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this, opts);
    this.barSpaceRatio = [1, 1];
}

var N = 1,
    W = 3,
    properties = {
    START_PATTERN: { value: [W, N, W, N, N, N] },
    STOP_PATTERN: { value: [W, N, N, N, W] },
    CODE_PATTERN: { value: [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]] },
    SINGLE_CODE_ERROR: { value: 0.78, writable: true },
    AVG_CODE_ERROR: { value: 0.30, writable: true },
    FORMAT: { value: "2of5" }
};

var startPatternLength = properties.START_PATTERN.value.reduce(function (sum, val) {
    return sum + val;
}, 0);

TwoOfFiveReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
TwoOfFiveReader.prototype.constructor = TwoOfFiveReader;

TwoOfFiveReader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum,
        epsilon = self.AVG_CODE_ERROR;

    isWhite = isWhite || false;
    tryHarder = tryHarder || false;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);
                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

TwoOfFiveReader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo,
        narrowBarWidth = 1;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset, false, true);
        if (!startInfo) {
            return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / startPatternLength);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

TwoOfFiveReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

TwoOfFiveReader.prototype._findEnd = function () {
    var self = this,
        endInfo,
        tmp,
        offset;

    self._row.reverse();
    offset = self._nextSet(self._row);
    endInfo = self._findPattern(self.STOP_PATTERN, offset, false, true);
    self._row.reverse();

    if (endInfo === null) {
        return null;
    }

    // reverse numbers
    tmp = endInfo.start;
    endInfo.start = self._row.length - endInfo.end;
    endInfo.end = self._row.length - tmp;

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

TwoOfFiveReader.prototype._decodeCode = function (counter) {
    var j,
        self = this,
        sum = 0,
        normalized,
        error,
        epsilon = self.AVG_CODE_ERROR,
        code,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    };

    for (j = 0; j < counter.length; j++) {
        sum += counter[j];
    }
    for (code = 0; code < self.CODE_PATTERN.length; code++) {
        error = self._matchPattern(counter, self.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
            bestMatch.code = code;
            bestMatch.error = error;
        }
    }
    if (bestMatch.error < epsilon) {
        return bestMatch;
    }
};

TwoOfFiveReader.prototype._decodePayload = function (counters, result, decodedCodes) {
    var i,
        self = this,
        pos = 0,
        counterLength = counters.length,
        counter = [0, 0, 0, 0, 0],
        code;

    while (pos < counterLength) {
        for (i = 0; i < 5; i++) {
            counter[i] = counters[pos] * this.barSpaceRatio[0];
            pos += 2;
        }
        code = self._decodeCode(counter);
        if (!code) {
            return null;
        }
        result.push(code.code + "");
        decodedCodes.push(code);
    }
    return code;
};

TwoOfFiveReader.prototype._verifyCounterLength = function (counters) {
    return counters.length % 10 === 0;
};

TwoOfFiveReader.prototype._decode = function () {
    var startInfo,
        endInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        counters;

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    decodedCodes.push(startInfo);

    endInfo = self._findEnd();
    if (!endInfo) {
        return null;
    }

    counters = self._fillCounters(startInfo.end, endInfo.start, false);
    if (!self._verifyCounterLength(counters)) {
        return null;
    }
    code = self._decodePayload(counters, result, decodedCodes);
    if (!code) {
        return null;
    }
    if (result.length < 5) {
        return null;
    }

    decodedCodes.push(endInfo);
    return {
        code: result.join(""),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
    };
};

/* harmony default export */ __webpack_exports__["a"] = (TwoOfFiveReader);

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);


function CodabarReader() {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this);
    this._counters = [];
}

var properties = {
    ALPHABETH_STRING: { value: "0123456789-$:/.+ABCD" },
    ALPHABET: { value: [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68] },
    CHARACTER_ENCODINGS: { value: [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E] },
    START_END: { value: [0x01A, 0x029, 0x00B, 0x00E] },
    MIN_ENCODED_CHARS: { value: 4 },
    MAX_ACCEPTABLE: { value: 2.0 },
    PADDING: { value: 1.5 },
    FORMAT: { value: "codabar", writeable: false }
};

CodabarReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
CodabarReader.prototype.constructor = CodabarReader;

CodabarReader.prototype._decode = function () {
    var self = this,
        result = [],
        start,
        decodedChar,
        pattern,
        nextStart,
        end;

    this._counters = self._fillCounters();
    start = self._findStart();
    if (!start) {
        return null;
    }
    nextStart = start.startCounter;

    do {
        pattern = self._toPattern(nextStart);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        nextStart += 8;
        if (result.length > 1 && self._isStartEnd(pattern)) {
            break;
        }
    } while (nextStart < self._counters.length);

    // verify end
    if (result.length - 2 < self.MIN_ENCODED_CHARS || !self._isStartEnd(pattern)) {
        return null;
    }

    // verify end white space
    if (!self._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
    }

    if (!self._validateResult(result, start.startCounter)) {
        return null;
    }

    nextStart = nextStart > self._counters.length ? self._counters.length : nextStart;
    end = start.start + self._sumCounters(start.startCounter, nextStart - 8);

    return {
        code: result.join(""),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result
    };
};

CodabarReader.prototype._verifyWhitespace = function (startCounter, endCounter) {
    if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
            return true;
        }
    }
    return false;
};

CodabarReader.prototype._calculatePatternLength = function (offset) {
    var i,
        sum = 0;

    for (i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
    }

    return sum;
};

CodabarReader.prototype._thresholdResultPattern = function (result, startCounter) {
    var self = this,
        categorization = {
        space: {
            narrow: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE },
            wide: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE }
        },
        bar: {
            narrow: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE },
            wide: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE }
        }
    },
        kind,
        cat,
        i,
        j,
        pos = startCounter,
        pattern;

    for (i = 0; i < result.length; i++) {
        pattern = self._charToPattern(result[i]);
        for (j = 6; j >= 0; j--) {
            kind = (j & 1) === 2 ? categorization.bar : categorization.space;
            cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
            cat.size += self._counters[pos + j];
            cat.counts++;
            pattern >>= 1;
        }
        pos += 8;
    }

    ["space", "bar"].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * self.MAX_ACCEPTABLE + self.PADDING) / newkind.wide.counts);
    });

    return categorization;
};

CodabarReader.prototype._charToPattern = function (char) {
    var self = this,
        charCode = char.charCodeAt(0),
        i;

    for (i = 0; i < self.ALPHABET.length; i++) {
        if (self.ALPHABET[i] === charCode) {
            return self.CHARACTER_ENCODINGS[i];
        }
    }
    return 0x0;
};

CodabarReader.prototype._validateResult = function (result, startCounter) {
    var self = this,
        thresholds = self._thresholdResultPattern(result, startCounter),
        i,
        j,
        kind,
        cat,
        size,
        pos = startCounter,
        pattern;

    for (i = 0; i < result.length; i++) {
        pattern = self._charToPattern(result[i]);
        for (j = 6; j >= 0; j--) {
            kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
            cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
            size = self._counters[pos + j];
            if (size < cat.min || size > cat.max) {
                return false;
            }
            pattern >>= 1;
        }
        pos += 8;
    }
    return true;
};

CodabarReader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

CodabarReader.prototype._computeAlternatingThreshold = function (offset, end) {
    var i,
        min = Number.MAX_VALUE,
        max = 0,
        counter;

    for (i = offset; i < end; i += 2) {
        counter = this._counters[i];
        if (counter > max) {
            max = counter;
        }
        if (counter < min) {
            min = counter;
        }
    }

    return (min + max) / 2.0 | 0;
};

CodabarReader.prototype._toPattern = function (offset) {
    var numCounters = 7,
        end = offset + numCounters,
        barThreshold,
        spaceThreshold,
        bitmask = 1 << numCounters - 1,
        pattern = 0,
        i,
        threshold;

    if (end > this._counters.length) {
        return -1;
    }

    barThreshold = this._computeAlternatingThreshold(offset, end);
    spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

    for (i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;
        if (this._counters[offset + i] > threshold) {
            pattern |= bitmask;
        }
        bitmask >>= 1;
    }

    return pattern;
};

CodabarReader.prototype._isStartEnd = function (pattern) {
    var i;

    for (i = 0; i < this.START_END.length; i++) {
        if (this.START_END[i] === pattern) {
            return true;
        }
    }
    return false;
};

CodabarReader.prototype._sumCounters = function (start, end) {
    var i,
        sum = 0;

    for (i = start; i < end; i++) {
        sum += this._counters[i];
    }
    return sum;
};

CodabarReader.prototype._findStart = function () {
    var self = this,
        i,
        pattern,
        start = self._nextUnset(self._row),
        end;

    for (i = 1; i < this._counters.length; i++) {
        pattern = self._toPattern(i);
        if (pattern !== -1 && self._isStartEnd(pattern)) {
            // TODO: Look for whitespace ahead
            start += self._sumCounters(0, i);
            end = start + self._sumCounters(i, i + 8);
            return {
                start: start,
                end: end,
                startCounter: i,
                endCounter: i + 8
            };
        }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (CodabarReader);

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);


function Code128Reader() {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this);
}

var properties = {
    CODE_SHIFT: { value: 98 },
    CODE_C: { value: 99 },
    CODE_B: { value: 100 },
    CODE_A: { value: 101 },
    START_CODE_A: { value: 103 },
    START_CODE_B: { value: 104 },
    START_CODE_C: { value: 105 },
    STOP_CODE: { value: 106 },
    CODE_PATTERN: { value: [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]] },
    SINGLE_CODE_ERROR: { value: 0.64 },
    AVG_CODE_ERROR: { value: 0.30 },
    FORMAT: { value: "code_128", writeable: false },
    MODULE_INDICES: { value: { bar: [0, 2, 4], space: [1, 3, 5] } }
};

Code128Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
Code128Reader.prototype.constructor = Code128Reader;

Code128Reader.prototype._decodeCode = function (start, correction) {
    var counter = [0, 0, 0, 0, 0, 0],
        i,
        self = this,
        offset = start,
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
            bar: 1,
            space: 1
        }
    },
        code,
        error;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                if (correction) {
                    self._correct(counter, correction);
                }
                for (code = 0; code < self.CODE_PATTERN.length; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                bestMatch.end = i;
                if (bestMatch.code === -1 || bestMatch.error > self.AVG_CODE_ERROR) {
                    return null;
                }
                if (self.CODE_PATTERN[bestMatch.code]) {
                    bestMatch.correction.bar = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
                    bestMatch.correction.space = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
                }
                return bestMatch;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code128Reader.prototype._correct = function (counter, correction) {
    this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);
    this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
};

Code128Reader.prototype._findStart = function () {
    var counter = [0, 0, 0, 0, 0, 0],
        i,
        self = this,
        offset = self._nextSet(self._row),
        isWhite = false,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
            bar: 1,
            space: 1
        }
    },
        code,
        error,
        j,
        sum;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                for (code = self.START_CODE_A; code <= self.START_CODE_C; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                if (bestMatch.error < self.AVG_CODE_ERROR) {
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    bestMatch.correction.bar = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
                    bestMatch.correction.space = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
                    return bestMatch;
                }

                for (j = 0; j < 4; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[4] = 0;
                counter[5] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code128Reader.prototype._decode = function () {
    var self = this,
        startInfo = self._findStart(),
        code = null,
        done = false,
        result = [],
        multiplier = 0,
        checksum = 0,
        codeset,
        rawResult = [],
        decodedCodes = [],
        shiftNext = false,
        unshift,
        removeLastCharacter = true;

    if (startInfo === null) {
        return null;
    }
    code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
            bar: startInfo.correction.bar,
            space: startInfo.correction.space
        }
    };
    decodedCodes.push(code);
    checksum = code.code;
    switch (code.code) {
        case self.START_CODE_A:
            codeset = self.CODE_A;
            break;
        case self.START_CODE_B:
            codeset = self.CODE_B;
            break;
        case self.START_CODE_C:
            codeset = self.CODE_C;
            break;
        default:
            return null;
    }

    while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = self._decodeCode(code.end, code.correction);
        if (code !== null) {
            if (code.code !== self.STOP_CODE) {
                removeLastCharacter = true;
            }

            if (code.code !== self.STOP_CODE) {
                rawResult.push(code.code);
                multiplier++;
                checksum += multiplier * code.code;
            }
            decodedCodes.push(code);

            switch (codeset) {
                case self.CODE_A:
                    if (code.code < 64) {
                        result.push(String.fromCharCode(32 + code.code));
                    } else if (code.code < 96) {
                        result.push(String.fromCharCode(code.code - 64));
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_SHIFT:
                                shiftNext = true;
                                codeset = self.CODE_B;
                                break;
                            case self.CODE_B:
                                codeset = self.CODE_B;
                                break;
                            case self.CODE_C:
                                codeset = self.CODE_C;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
                case self.CODE_B:
                    if (code.code < 96) {
                        result.push(String.fromCharCode(32 + code.code));
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_SHIFT:
                                shiftNext = true;
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_A:
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_C:
                                codeset = self.CODE_C;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
                case self.CODE_C:
                    if (code.code < 100) {
                        result.push(code.code < 10 ? "0" + code.code : code.code);
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_A:
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_B:
                                codeset = self.CODE_B;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
            }
        } else {
            done = true;
        }
        if (unshift) {
            codeset = codeset === self.CODE_A ? self.CODE_B : self.CODE_A;
        }
    }

    if (code === null) {
        return null;
    }

    code.end = self._nextUnset(self._row, code.end);
    if (!self._verifyTrailingWhitespace(code)) {
        return null;
    }

    checksum -= multiplier * rawResult[rawResult.length - 1];
    if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
    }

    if (!result.length) {
        return null;
    }

    // remove last code from result (checksum)
    if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
    }

    return {
        code: result.join(""),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code
    };
};

__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

function calculateCorrection(expected, normalized, indices) {
    var length = indices.length,
        sumNormalized = 0,
        sumExpected = 0;

    while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
    }
    return sumExpected / sumNormalized;
}

/* harmony default export */ __webpack_exports__["a"] = (Code128Reader);

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__code_39_reader__ = __webpack_require__(31);


function Code39VINReader() {
    __WEBPACK_IMPORTED_MODULE_0__code_39_reader__["a" /* default */].call(this);
}

var patterns = {
    IOQ: /[IOQ]/g,
    AZ09: /[A-Z0-9]{17}/
};

Code39VINReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__code_39_reader__["a" /* default */].prototype);
Code39VINReader.prototype.constructor = Code39VINReader;

// Cribbed from:
// https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java
Code39VINReader.prototype._decode = function () {
    var result = __WEBPACK_IMPORTED_MODULE_0__code_39_reader__["a" /* default */].prototype._decode.apply(this);
    if (!result) {
        return null;
    }

    var code = result.code;

    if (!code) {
        return null;
    }

    code = code.replace(patterns.IOQ, '');

    if (!code.match(patterns.AZ09)) {
        if (true) {
            console.log('Failed AZ09 pattern code:', code);
        }
        return null;
    }

    if (!this._checkChecksum(code)) {
        return null;
    }

    result.code = code;
    return result;
};

Code39VINReader.prototype._checkChecksum = function (code) {
    // TODO
    return !!code;
};

/* harmony default export */ __webpack_exports__["a"] = (Code39VINReader);

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__barcode_reader__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_array_helper__ = __webpack_require__(3);



function Code93Reader() {
    __WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].call(this);
}

var ALPHABETH_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*";

var properties = {
    ALPHABETH_STRING: { value: ALPHABETH_STRING },
    ALPHABET: { value: ALPHABETH_STRING.split('').map(function (char) {
            return char.charCodeAt(0);
        }) },
    CHARACTER_ENCODINGS: { value: [0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E] },
    ASTERISK: { value: 0x15E },
    FORMAT: { value: "code_93", writeable: false }
};

Code93Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__barcode_reader__["a" /* default */].prototype, properties);
Code93Reader.prototype.constructor = Code93Reader;

Code93Reader.prototype._decode = function () {
    var self = this,
        counters = [0, 0, 0, 0, 0, 0],
        result = [],
        start = self._findStart(),
        decodedChar,
        lastStart,
        pattern,
        nextStart;

    if (!start) {
        return null;
    }
    nextStart = self._nextSet(self._row, start.end);

    do {
        counters = self._toCounters(nextStart, counters);
        pattern = self._toPattern(counters);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += __WEBPACK_IMPORTED_MODULE_1__common_array_helper__["a" /* default */].sum(counters);
        nextStart = self._nextSet(self._row, nextStart);
    } while (decodedChar !== '*');
    result.pop();

    if (!result.length) {
        return null;
    }

    if (!self._verifyEnd(lastStart, nextStart, counters)) {
        return null;
    }

    if (!self._verifyChecksums(result)) {
        return null;
    }

    result = result.slice(0, result.length - 2);
    if ((result = self._decodeExtended(result)) === null) {
        return null;
    };

    return {
        code: result.join(""),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result
    };
};

Code93Reader.prototype._verifyEnd = function (lastStart, nextStart) {
    if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
    }
    return true;
};

Code93Reader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

Code93Reader.prototype._toPattern = function (counters) {
    var numCounters = counters.length;
    var pattern = 0;
    var sum = 0;
    for (var i = 0; i < numCounters; i++) {
        sum += counters[i];
    }

    for (var _i = 0; _i < numCounters; _i++) {
        var normalized = Math.round(counters[_i] * 9 / sum);
        if (normalized < 1 || normalized > 4) {
            return -1;
        }
        if ((_i & 1) === 0) {
            for (var j = 0; j < normalized; j++) {
                pattern = pattern << 1 | 1;
            }
        } else {
            pattern <<= normalized;
        }
    }

    return pattern;
};

Code93Reader.prototype._findStart = function () {
    var self = this,
        offset = self._nextSet(self._row),
        patternStart = offset,
        counter = [0, 0, 0, 0, 0, 0],
        counterPos = 0,
        isWhite = false,
        i,
        j,
        whiteSpaceMustStart;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                // find start pattern
                if (self._toPattern(counter) === self.ASTERISK) {
                    whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
                    if (self._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                        return {
                            start: patternStart,
                            end: i
                        };
                    }
                }

                patternStart += counter[0] + counter[1];
                for (j = 0; j < 4; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[4] = 0;
                counter[5] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code93Reader.prototype._decodeExtended = function (charArray) {
    var length = charArray.length;
    var result = [];
    for (var i = 0; i < length; i++) {
        var char = charArray[i];
        if (char >= 'a' && char <= 'd') {
            if (i > length - 2) {
                return null;
            }
            var nextChar = charArray[++i];
            var nextCharCode = nextChar.charCodeAt(0);
            var decodedChar = void 0;
            switch (char) {
                case 'a':
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(nextCharCode - 64);
                    } else {
                        return null;
                    }
                    break;
                case 'b':
                    if (nextChar >= 'A' && nextChar <= 'E') {
                        decodedChar = String.fromCharCode(nextCharCode - 38);
                    } else if (nextChar >= 'F' && nextChar <= 'J') {
                        decodedChar = String.fromCharCode(nextCharCode - 11);
                    } else if (nextChar >= 'K' && nextChar <= 'O') {
                        decodedChar = String.fromCharCode(nextCharCode + 16);
                    } else if (nextChar >= 'P' && nextChar <= 'S') {
                        decodedChar = String.fromCharCode(nextCharCode + 43);
                    } else if (nextChar >= 'T' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(127);
                    } else {
                        return null;
                    }
                    break;
                case 'c':
                    if (nextChar >= 'A' && nextChar <= 'O') {
                        decodedChar = String.fromCharCode(nextCharCode - 32);
                    } else if (nextChar === 'Z') {
                        decodedChar = ':';
                    } else {
                        return null;
                    }
                    break;
                case 'd':
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(nextCharCode + 32);
                    } else {
                        return null;
                    }
                    break;
            }
            result.push(decodedChar);
        } else {
            result.push(char);
        }
    }
    return result;
};

Code93Reader.prototype._verifyChecksums = function (charArray) {
    return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
};

Code93Reader.prototype._matchCheckChar = function (charArray, index, maxWeight) {
    var _this = this;

    var arrayToCheck = charArray.slice(0, index);
    var length = arrayToCheck.length;
    var weightedSums = arrayToCheck.reduce(function (sum, char, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = _this.ALPHABET.indexOf(char.charCodeAt(0));
        return sum + weight * value;
    }, 0);

    var checkChar = this.ALPHABET[weightedSums % 47];
    return checkChar === charArray[index].charCodeAt(0);
};

/* harmony default export */ __webpack_exports__["a"] = (Code93Reader);

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function EAN2Reader() {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this);
}

var properties = {
    FORMAT: { value: "ean_2", writeable: false }
};

EAN2Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
EAN2Reader.prototype.constructor = EAN2Reader;

EAN2Reader.prototype.decode = function (row, start) {
    this._row = row;
    var counters = [0, 0, 0, 0],
        codeFrequency = 0,
        i = 0,
        offset = start,
        end = this._row.length,
        code,
        result = [],
        decodedCodes = [];

    for (i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= this.CODE_G_START) {
            codeFrequency |= 1 << 1 - i;
        }
        if (i != 1) {
            offset = this._nextSet(this._row, code.end);
            offset = this._nextUnset(this._row, offset);
        }
    }

    if (result.length != 2 || parseInt(result.join("")) % 4 !== codeFrequency) {
        return null;
    }
    return {
        code: result.join(""),
        decodedCodes: decodedCodes,
        end: code.end
    };
};

/* harmony default export */ __webpack_exports__["a"] = (EAN2Reader);

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function EAN5Reader() {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this);
}

var properties = {
    FORMAT: { value: "ean_5", writeable: false }
};

var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

EAN5Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
EAN5Reader.prototype.constructor = EAN5Reader;

EAN5Reader.prototype.decode = function (row, start) {
    this._row = row;
    var counters = [0, 0, 0, 0],
        codeFrequency = 0,
        i = 0,
        offset = start,
        end = this._row.length,
        code,
        result = [],
        decodedCodes = [];

    for (i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= this.CODE_G_START) {
            codeFrequency |= 1 << 4 - i;
        }
        if (i != 4) {
            offset = this._nextSet(this._row, code.end);
            offset = this._nextUnset(this._row, offset);
        }
    }

    if (result.length != 5) {
        return null;
    }

    if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
    }
    return {
        code: result.join(""),
        decodedCodes: decodedCodes,
        end: code.end
    };
};

function determineCheckDigit(codeFrequency) {
    var i;
    for (i = 0; i < 10; i++) {
        if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
            return i;
        }
    }
    return null;
}

function extensionChecksum(result) {
    var length = result.length,
        sum = 0,
        i;

    for (i = length - 2; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    for (i = length - 1; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    return sum % 10;
}

/* harmony default export */ __webpack_exports__["a"] = (EAN5Reader);

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function EAN8Reader(opts, supplements) {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this, opts, supplements);
}

var properties = {
    FORMAT: { value: "ean_8", writeable: false }
};

EAN8Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
EAN8Reader.prototype.constructor = EAN8Reader;

EAN8Reader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this;

    for (i = 0; i < 4; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }

    code = self._findPattern(self.MIDDLE_PATTERN, code.end, true, false);
    if (code === null) {
        return null;
    }
    decodedCodes.push(code);

    for (i = 0; i < 4; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
    }

    return code;
};

/* harmony default export */ __webpack_exports__["a"] = (EAN8Reader);

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash_merge__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__barcode_reader__ = __webpack_require__(1);




function I2of5Reader(opts) {
    opts = __WEBPACK_IMPORTED_MODULE_0_lodash_merge___default()(getDefaulConfig(), opts);
    __WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].call(this, opts);
    this.barSpaceRatio = [1, 1];
    if (opts.normalizeBarSpaceWidth) {
        this.SINGLE_CODE_ERROR = 0.38;
        this.AVG_CODE_ERROR = 0.09;
    }
}

function getDefaulConfig() {
    var config = {};

    Object.keys(I2of5Reader.CONFIG_KEYS).forEach(function (key) {
        config[key] = I2of5Reader.CONFIG_KEYS[key].default;
    });
    return config;
}

var N = 1,
    W = 3,
    properties = {
    START_PATTERN: { value: [N, N, N, N] },
    STOP_PATTERN: { value: [N, N, W] },
    CODE_PATTERN: { value: [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]] },
    SINGLE_CODE_ERROR: { value: 0.78, writable: true },
    AVG_CODE_ERROR: { value: 0.38, writable: true },
    MAX_CORRECTION_FACTOR: { value: 5 },
    FORMAT: { value: "i2of5" }
};

I2of5Reader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].prototype, properties);
I2of5Reader.prototype.constructor = I2of5Reader;

I2of5Reader.prototype._matchPattern = function (counter, code) {
    if (this.config.normalizeBarSpaceWidth) {
        var i,
            counterSum = [0, 0],
            codeSum = [0, 0],
            correction = [0, 0],
            correctionRatio = this.MAX_CORRECTION_FACTOR,
            correctionRatioInverse = 1 / correctionRatio;

        for (i = 0; i < counter.length; i++) {
            counterSum[i % 2] += counter[i];
            codeSum[i % 2] += code[i];
        }
        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];

        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;
        for (i = 0; i < counter.length; i++) {
            counter[i] *= this.barSpaceRatio[i % 2];
        }
    }
    return __WEBPACK_IMPORTED_MODULE_1__barcode_reader__["a" /* default */].prototype._matchPattern.call(this, counter, code);
};

I2of5Reader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum,
        normalized,
        epsilon = self.AVG_CODE_ERROR;

    isWhite = isWhite || false;
    tryHarder = tryHarder || false;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);
                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

I2of5Reader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo,
        narrowBarWidth = 1;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset, false, true);
        if (!startInfo) {
            return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

I2of5Reader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

I2of5Reader.prototype._findEnd = function () {
    var self = this,
        endInfo,
        tmp;

    self._row.reverse();
    endInfo = self._findPattern(self.STOP_PATTERN);
    self._row.reverse();

    if (endInfo === null) {
        return null;
    }

    // reverse numbers
    tmp = endInfo.start;
    endInfo.start = self._row.length - endInfo.end;
    endInfo.end = self._row.length - tmp;

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

I2of5Reader.prototype._decodePair = function (counterPair) {
    var i,
        code,
        codes = [],
        self = this;

    for (i = 0; i < counterPair.length; i++) {
        code = self._decodeCode(counterPair[i]);
        if (!code) {
            return null;
        }
        codes.push(code);
    }
    return codes;
};

I2of5Reader.prototype._decodeCode = function (counter) {
    var j,
        self = this,
        sum = 0,
        normalized,
        error,
        epsilon = self.AVG_CODE_ERROR,
        code,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    };

    for (j = 0; j < counter.length; j++) {
        sum += counter[j];
    }
    for (code = 0; code < self.CODE_PATTERN.length; code++) {
        error = self._matchPattern(counter, self.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
            bestMatch.code = code;
            bestMatch.error = error;
        }
    }
    if (bestMatch.error < epsilon) {
        return bestMatch;
    }
};

I2of5Reader.prototype._decodePayload = function (counters, result, decodedCodes) {
    var i,
        self = this,
        pos = 0,
        counterLength = counters.length,
        counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
        codes;

    while (pos < counterLength) {
        for (i = 0; i < 5; i++) {
            counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
            counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
            pos += 2;
        }
        codes = self._decodePair(counterPair);
        if (!codes) {
            return null;
        }
        for (i = 0; i < codes.length; i++) {
            result.push(codes[i].code + "");
            decodedCodes.push(codes[i]);
        }
    }
    return codes;
};

I2of5Reader.prototype._verifyCounterLength = function (counters) {
    return counters.length % 10 === 0;
};

I2of5Reader.prototype._decode = function () {
    var startInfo,
        endInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        counters;

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    decodedCodes.push(startInfo);

    endInfo = self._findEnd();
    if (!endInfo) {
        return null;
    }

    counters = self._fillCounters(startInfo.end, endInfo.start, false);
    if (!self._verifyCounterLength(counters)) {
        return null;
    }
    code = self._decodePayload(counters, result, decodedCodes);
    if (!code) {
        return null;
    }
    if (result.length % 2 !== 0 || result.length < 6) {
        return null;
    }

    decodedCodes.push(endInfo);
    return {
        code: result.join(""),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
    };
};

I2of5Reader.CONFIG_KEYS = {
    normalizeBarSpaceWidth: {
        'type': 'boolean',
        'default': false,
        'description': 'If true, the reader tries to normalize the' + 'width-difference between bars and spaces'
    }
};

/* harmony default export */ __webpack_exports__["a"] = (I2of5Reader);

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function UPCEReader(opts, supplements) {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this, opts, supplements);
}

var properties = {
    CODE_FREQUENCY: { value: [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]] },
    STOP_PATTERN: { value: [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7] },
    FORMAT: { value: "upc_e", writeable: false }
};

UPCEReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
UPCEReader.prototype.constructor = UPCEReader;

UPCEReader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this,
        codeFrequency = 0x0;

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end);
        if (!code) {
            return null;
        }
        if (code.code >= self.CODE_G_START) {
            code.code = code.code - self.CODE_G_START;
            codeFrequency |= 1 << 5 - i;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }
    if (!self._determineParity(codeFrequency, result)) {
        return null;
    }

    return code;
};

UPCEReader.prototype._determineParity = function (codeFrequency, result) {
    var i, nrSystem;

    for (nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
            if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
                result.unshift(nrSystem);
                result.push(i);
                return true;
            }
        }
    }
    return false;
};

UPCEReader.prototype._convertToUPCA = function (result) {
    var upca = [result[0]],
        lastDigit = result[result.length - 2];

    if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
    } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
    } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
    } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
    }

    upca.push(result[result.length - 1]);
    return upca;
};

UPCEReader.prototype._checksum = function (result) {
    return __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype._checksum.call(this, this._convertToUPCA(result));
};

UPCEReader.prototype._findEnd = function (offset, isWhite) {
    isWhite = true;
    return __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype._findEnd.call(this, offset, isWhite);
};

UPCEReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (UPCEReader);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ean_reader__ = __webpack_require__(4);


function UPCReader(opts, supplements) {
    __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].call(this, opts, supplements);
}

var properties = {
    FORMAT: { value: "upc_a", writeable: false }
};

UPCReader.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype, properties);
UPCReader.prototype.constructor = UPCReader;

UPCReader.prototype._decode = function () {
    var result = __WEBPACK_IMPORTED_MODULE_0__ean_reader__["a" /* default */].prototype._decode.call(this);

    if (result && result.code && result.code.length === 13 && result.code.charAt(0) === "0") {
        result.code = result.code.substring(1);
        return result;
    }
    return null;
};

/* harmony default export */ __webpack_exports__["a"] = (UPCReader);

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = copy

/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  return out
}


/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = create

/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new Float32Array(4)
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 1
  return out
}


/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = invert

/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  var a0 = a[0]
  var a1 = a[1]
  var a2 = a[2]
  var a3 = a[3]
  var det = a0 * a3 - a2 * a1

  if (!det) return null
  det = 1.0 / det

  out[0] =  a3 * det
  out[1] = -a1 * det
  out[2] = -a2 * det
  out[3] =  a0 * det

  return out
}


/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = scale

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b
    out[1] = a[1] * b
    return out
}

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = transformMat2

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1]
    out[0] = m[0] * x + m[2] * y
    out[1] = m[1] * x + m[3] * y
    return out
}

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = clone;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
    var out = new Float32Array(3)
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(122),
    hashDelete = __webpack_require__(123),
    hashGet = __webpack_require__(124),
    hashHas = __webpack_require__(125),
    hashSet = __webpack_require__(126);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10),
    stackClear = __webpack_require__(149),
    stackDelete = __webpack_require__(150),
    stackGet = __webpack_require__(151),
    stackHas = __webpack_require__(152),
    stackSet = __webpack_require__(153);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 87 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(107),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isBuffer = __webpack_require__(44),
    isIndex = __webpack_require__(15),
    isTypedArray = __webpack_require__(45);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 89 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 90 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(0);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(90),
    isFlattenable = __webpack_require__(128);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(117);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(13),
    toKey = __webpack_require__(23);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 95 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(25),
    isMasked = __webpack_require__(132),
    isObject = __webpack_require__(0),
    toSource = __webpack_require__(155);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isLength = __webpack_require__(26),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(0),
    isPrototype = __webpack_require__(40),
    nativeKeysIn = __webpack_require__(144);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(85),
    assignMergeValue = __webpack_require__(35),
    baseFor = __webpack_require__(93),
    baseMergeDeep = __webpack_require__(101),
    isObject = __webpack_require__(0),
    keysIn = __webpack_require__(46);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(35),
    cloneBuffer = __webpack_require__(111),
    cloneTypedArray = __webpack_require__(112),
    copyArray = __webpack_require__(113),
    initCloneObject = __webpack_require__(127),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isArrayLikeObject = __webpack_require__(159),
    isBuffer = __webpack_require__(44),
    isFunction = __webpack_require__(25),
    isObject = __webpack_require__(0),
    isPlainObject = __webpack_require__(160),
    isTypedArray = __webpack_require__(45),
    toPlainObject = __webpack_require__(164);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(103),
    hasIn = __webpack_require__(158);

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(94),
    baseSet = __webpack_require__(105),
    castPath = __webpack_require__(13);

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(43),
    overRest = __webpack_require__(41),
    setToString = __webpack_require__(42);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(36),
    castPath = __webpack_require__(13),
    isIndex = __webpack_require__(15),
    isObject = __webpack_require__(0),
    toKey = __webpack_require__(23);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(156),
    defineProperty = __webpack_require__(37),
    identity = __webpack_require__(43);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 107 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    arrayMap = __webpack_require__(89),
    isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(27);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 109 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(86);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(5);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(110);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 113 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(36),
    baseAssignValue = __webpack_require__(21);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(104),
    isIterateeCall = __webpack_require__(129);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 117 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(157),
    overRest = __webpack_require__(41),
    setToString = __webpack_require__(42);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 120 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(13),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isIndex = __webpack_require__(15),
    isLength = __webpack_require__(26),
    toKey = __webpack_require__(23);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 123 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(91),
    getPrototype = __webpack_require__(39),
    isPrototype = __webpack_require__(40);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(17),
    isArrayLike = __webpack_require__(24),
    isIndex = __webpack_require__(15),
    isObject = __webpack_require__(0);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(27);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 131 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(115);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 133 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(84),
    ListCache = __webpack_require__(10),
    Map = __webpack_require__(33);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(161);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 144 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(38);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 146 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 148 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 150 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 151 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10),
    Map = __webpack_require__(33),
    MapCache = __webpack_require__(34);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(143);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 155 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(92);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(95),
    hasPath = __webpack_require__(121);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(24),
    isObjectLike = __webpack_require__(6);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    getPrototype = __webpack_require__(39),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(34);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(102),
    flatRest = __webpack_require__(118);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(114),
    keysIn = __webpack_require__(46);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(108);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(48);


/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9teU1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIGM0MTUzNDM1NTc0OTMwMTViYjQxIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2FycmF5X2hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2Vhbl9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8uL34vZ2wtdmVjMi9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2VxLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vY3ZfdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9sb2NhdG9yL3RyYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzlfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL34vZ2wtdmVjMi9kb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX01hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcXVhZ2dhLmpzIiwid2VicGFjazovLy8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9tZWRpYURldmljZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9zdWJJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL3R5cGVkZWZzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLmRldi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGVjb2Rlci9iYXJjb2RlX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9leGlmX2hlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvaW1hZ2VfbG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvMm9mNV9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMTI4X3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvdXBjX2VfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvdXBjX3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsLW1hdDIvY29weS5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsLW1hdDIvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vZ2wtbWF0Mi9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbC12ZWMyL3NjYWxlLmpzIiwid2VicGFjazovLy8uL34vZ2wtdmVjMi90cmFuc2Zvcm1NYXQyLmpzIiwid2VicGFjazovLy8uL34vZ2wtdmVjMy9jbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUGljay5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY29weUFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZmxhdFJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3BpY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3RvUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdG9TdHJpbmcuanMiXSwibmFtZXMiOlsiQmFyY29kZVJlYWRlciIsImNvbmZpZyIsInN1cHBsZW1lbnRzIiwiX3JvdyIsInByb3RvdHlwZSIsIl9uZXh0VW5zZXQiLCJsaW5lIiwic3RhcnQiLCJpIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiX21hdGNoUGF0dGVybiIsImNvdW50ZXIiLCJjb2RlIiwibWF4U2luZ2xlRXJyb3IiLCJlcnJvciIsInNpbmdsZUVycm9yIiwic3VtIiwibW9kdWxvIiwiYmFyV2lkdGgiLCJjb3VudCIsInNjYWxlZCIsIlNJTkdMRV9DT0RFX0VSUk9SIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiTWF0aCIsImFicyIsIl9uZXh0U2V0Iiwib2Zmc2V0IiwiX2NvcnJlY3RCYXJzIiwiY29ycmVjdGlvbiIsImluZGljZXMiLCJ0bXAiLCJfbWF0Y2hUcmFjZSIsImNtcENvdW50ZXIiLCJlcHNpbG9uIiwic2VsZiIsImlzV2hpdGUiLCJjb3VudGVyUG9zIiwiYmVzdE1hdGNoIiwicHVzaCIsImVuZCIsImRlY29kZVBhdHRlcm4iLCJwYXR0ZXJuIiwicmVzdWx0IiwiX2RlY29kZSIsInJldmVyc2UiLCJkaXJlY3Rpb24iLCJESVJFQ1RJT04iLCJSRVZFUlNFIiwiRk9SV0FSRCIsImZvcm1hdCIsIkZPUk1BVCIsIl9tYXRjaFJhbmdlIiwidmFsdWUiLCJfZmlsbENvdW50ZXJzIiwiY291bnRlcnMiLCJfdG9Db3VudGVycyIsIm51bUNvdW50ZXJzIiwiQXJyYXlIZWxwZXIiLCJpbml0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0ZWFibGUiLCJFeGNlcHRpb24iLCJTdGFydE5vdEZvdW5kRXhjZXB0aW9uIiwiQ29kZU5vdEZvdW5kRXhjZXB0aW9uIiwiUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uIiwiQ09ORklHX0tFWVMiLCJhcnIiLCJ2YWwiLCJsIiwic2h1ZmZsZSIsImoiLCJ4IiwiZmxvb3IiLCJyYW5kb20iLCJ0b1BvaW50TGlzdCIsInJvdyIsInJvd3MiLCJqb2luIiwidGhyZXNob2xkIiwic2NvcmVGdW5jIiwicXVldWUiLCJhcHBseSIsIm1heEluZGV4IiwibWF4IiwiRUFOUmVhZGVyIiwib3B0cyIsImdldERlZmF1bENvbmZpZyIsImNhbGwiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImRlZmF1bHQiLCJwcm9wZXJ0aWVzIiwiQ09ERV9MX1NUQVJUIiwiQ09ERV9HX1NUQVJUIiwiU1RBUlRfUEFUVEVSTiIsIlNUT1BfUEFUVEVSTiIsIk1JRERMRV9QQVRURVJOIiwiRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4iLCJDT0RFX1BBVFRFUk4iLCJDT0RFX0ZSRVFVRU5DWSIsIkFWR19DT0RFX0VSUk9SIiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJfZGVjb2RlQ29kZSIsImNvZGVyYW5nZSIsIl9maW5kUGF0dGVybiIsInRyeUhhcmRlciIsIl9maW5kU3RhcnQiLCJsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0Iiwic3RhcnRJbmZvIiwiX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZSIsImVuZEluZm8iLCJ0cmFpbGluZ1doaXRlc3BhY2VFbmQiLCJfZmluZEVuZCIsIl9jYWxjdWxhdGVGaXJzdERpZ2l0IiwiY29kZUZyZXF1ZW5jeSIsIl9kZWNvZGVQYXlsb2FkIiwiZGVjb2RlZENvZGVzIiwiZmlyc3REaWdpdCIsInVuc2hpZnQiLCJyZXN1bHRJbmZvIiwiX2NoZWNrc3VtIiwiZXh0IiwiX2RlY29kZUV4dGVuc2lvbnMiLCJsYXN0Q29kZSIsInN1cHBsZW1lbnQiLCJjb2Rlc2V0IiwiZGVjb2RlIiwiZHJhd1JlY3QiLCJwb3MiLCJzaXplIiwiY3R4Iiwic3R5bGUiLCJzdHJva2VTdHlsZSIsImNvbG9yIiwiZmlsbFN0eWxlIiwibGluZVdpZHRoIiwiYmVnaW5QYXRoIiwic3Ryb2tlUmVjdCIsInkiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJjYW52YXNEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiZGF0YSIsImltYWdlRGF0YVBvcyIsImNhbnZhc0RhdGFQb3MiLCJwdXRJbWFnZURhdGEiLCJ2ZWMyIiwiY2xvbmUiLCJyZXF1aXJlIiwidmVjMyIsImltYWdlUmVmIiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsInJvdW5kIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwid2lkdGgiLCJoZWlnaHQiLCJpbnRlZ3JhbEltYWdlRGF0YSIsInBvc0EiLCJwb3NCIiwicG9zQyIsInBvc0QiLCJjb21wdXRlSW50ZWdyYWxJbWFnZSIsInYiLCJ1IiwidGhyZXNob2xkSW1hZ2UiLCJ0YXJnZXRXcmFwcGVyIiwidGFyZ2V0RGF0YSIsImNvbXB1dGVIaXN0b2dyYW0iLCJiaXRzUGVyUGl4ZWwiLCJiaXRTaGlmdCIsImJ1Y2tldENudCIsImhpc3QiLCJJbnQzMkFycmF5Iiwic2hhcnBlbkxpbmUiLCJsZWZ0IiwiY2VudGVyIiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJrIiwibTEiLCJtMiIsIm0xMiIsIm90c3VUaHJlc2hvbGQiLCJjb21wdXRlQmluYXJ5SW1hZ2UiLCJrZXJuZWwiLCJBIiwiQiIsIkMiLCJEIiwiYXZnIiwiY2x1c3RlciIsInBvaW50cyIsInByb3BlcnR5IiwicG9pbnQiLCJjbHVzdGVycyIsImFkZFRvQ2x1c3RlciIsIm5ld1BvaW50IiwiZm91bmQiLCJmaXRzIiwiYWRkIiwiQ2x1c3RlcjIiLCJjcmVhdGVQb2ludCIsIlRyYWNlciIsInRyYWNlIiwidmVjIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwiZnJvbSIsInRvIiwidG9JZHgiLCJwcmVkaWN0ZWRQb3MiLCJ0aHJlc2hvbGRYIiwidGhyZXNob2xkWSIsIm1hdGNoIiwicHJlZGljdGVkIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwic3VidHJhY3QiLCJhSW1hZ2VXcmFwcGVyIiwiYkltYWdlV3JhcHBlciIsInJlc3VsdEltYWdlV3JhcHBlciIsImFJbWFnZURhdGEiLCJiSW1hZ2VEYXRhIiwiY0ltYWdlRGF0YSIsImJpdHdpc2VPciIsImNvdW50Tm9uWmVybyIsInRvcEdlbmVyaWMiLCJsaXN0IiwibWluSWR4IiwibWluIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiZ3JheUFycmF5RnJvbUltYWdlIiwiaHRtbEltYWdlIiwib2Zmc2V0WCIsImFycmF5IiwiY3R4RGF0YSIsImNvbXB1dGVHcmF5IiwiZ3JheUFycmF5RnJvbUNvbnRleHQiLCJncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJzaW5nbGVDaGFubmVsIiwibG9hZEltYWdlQXJyYXkiLCJzcmMiLCJjYWxsYmFjayIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltZyIsIkltYWdlIiwib25sb2FkIiwiZ2V0Q29udGV4dCIsIlVpbnQ4QXJyYXkiLCJoYWxmU2FtcGxlIiwiaW5JbWdXcmFwcGVyIiwib3V0SW1nV3JhcHBlciIsImluSW1nIiwib3V0SW1nIiwiaHN2MnJnYiIsImhzdiIsInJnYiIsImgiLCJzIiwiYyIsIm0iLCJyIiwiZyIsImIiLCJfY29tcHV0ZURpdmlzb3JzIiwibiIsImxhcmdlRGl2aXNvcnMiLCJkaXZpc29ycyIsInNxcnQiLCJjb25jYXQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJuck9mUGF0Y2hlc0lkeCIsIm1lZGl1bSIsIm5yT2ZQYXRjaGVzIiwiZGVzaXJlZFBhdGNoU2l6ZSIsIm9wdGltYWxQYXRjaFNpemUiLCJmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMiLCJfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXMiLCJkaW1lbnNpb24iLCJwYXJzZUZsb2F0IiwidW5pdCIsImluZGV4T2YiLCJfZGltZW5zaW9uc0NvbnZlcnRlcnMiLCJjb250ZXh0IiwiYm90dG9tIiwiY29tcHV0ZUltYWdlQXJlYSIsImlucHV0V2lkdGgiLCJpbnB1dEhlaWdodCIsImFyZWEiLCJwYXJzZWRBcmVhIiwicmVkdWNlIiwicGFyc2VkIiwiY2FsY3VsYXRlZCIsInN4Iiwic3kiLCJzdyIsInNoIiwiSW1hZ2VXcmFwcGVyIiwiQXJyYXlUeXBlIiwiaW5pdGlhbGl6ZSIsIkFycmF5IiwiaW5JbWFnZVdpdGhCb3JkZXIiLCJpbWdSZWYiLCJib3JkZXIiLCJzYW1wbGUiLCJseCIsImx5IiwidyIsImJhc2UiLCJhIiwiZCIsImUiLCJjbGVhckFycmF5Iiwic3ViSW1hZ2UiLCJzdWJJbWFnZUFzQ29weSIsInNpemVZIiwic2l6ZVgiLCJjb3B5VG8iLCJzcmNEYXRhIiwiZHN0RGF0YSIsImdldCIsImdldFNhZmUiLCJpbmRleE1hcHBpbmciLCJzZXQiLCJ6ZXJvQm9yZGVyIiwiaW52ZXJ0IiwiY29udm9sdmUiLCJreCIsImt5Iiwia1NpemUiLCJhY2N1IiwibW9tZW50cyIsImxhYmVsY291bnQiLCJ5c3EiLCJsYWJlbHN1bSIsImxhYmVsIiwibXUxMSIsIm11MDIiLCJtdTIwIiwieF8iLCJ5XyIsIlBJIiwiUElfNCIsIm0wMCIsIm0wMSIsIm0xMCIsIm0xMSIsIm0wMiIsIm0yMCIsInRoZXRhIiwicmFkIiwiaXNOYU4iLCJhdGFuIiwiY29zIiwic2luIiwic2hvdyIsInNjYWxlIiwiZnJhbWUiLCJjdXJyZW50IiwicGl4ZWwiLCJvdmVybGF5Iiwid2hpdGVSZ2IiLCJibGFja1JnYiIsInNlYXJjaERpcmVjdGlvbnMiLCJsYWJlbFdyYXBwZXIiLCJsYWJlbERhdGEiLCJlZGdlbGFiZWwiLCJjeSIsImRpciIsImN4IiwidmVydGV4MkQiLCJuZXh0IiwicHJldiIsImNvbnRvdXJUcmFjaW5nIiwiRnYiLCJDdiIsIlAiLCJsZGlyIiwiQ29kZTM5UmVhZGVyIiwiQUxQSEFCRVRIX1NUUklORyIsIkFMUEhBQkVUIiwiQ0hBUkFDVEVSX0VOQ09ESU5HUyIsIkFTVEVSSVNLIiwiZGVjb2RlZENoYXIiLCJsYXN0U3RhcnQiLCJuZXh0U3RhcnQiLCJfdG9QYXR0ZXJuIiwiX3BhdHRlcm5Ub0NoYXIiLCJwb3AiLCJwYXR0ZXJuU2l6ZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIl9maW5kTmV4dFdpZHRoIiwibWluV2lkdGgiLCJtYXhOYXJyb3dXaWR0aCIsIm51bVdpZGVCYXJzIiwid2lkZUJhcldpZHRoIiwicGF0dGVyblN0YXJ0Iiwid2hpdGVTcGFjZU11c3RTdGFydCIsIl9pbnB1dFN0cmVhbSIsIl9mcmFtZWdyYWJiZXIiLCJfc3RvcHBlZCIsIl9jYW52YXNDb250YWluZXIiLCJpbWFnZSIsImRvbSIsIl9pbnB1dEltYWdlV3JhcHBlciIsIl9ib3hTaXplIiwiX2RlY29kZXIiLCJfd29ya2VyUG9vbCIsIl9vblVJVGhyZWFkIiwiX3Jlc3VsdENvbGxlY3RvciIsIl9jb25maWciLCJpbml0aWFsaXplRGF0YSIsImluaXRCdWZmZXJzIiwiQmFyY29kZURlY29kZXIiLCJkZWNvZGVyIiwiaW5pdElucHV0U3RyZWFtIiwiY2IiLCJ2aWRlbyIsImlucHV0U3RyZWFtIiwidHlwZSIsIklucHV0U3RyZWFtIiwiY3JlYXRlVmlkZW9TdHJlYW0iLCJjcmVhdGVJbWFnZVN0cmVhbSIsIiR2aWV3cG9ydCIsImdldFZpZXdQb3J0IiwicXVlcnlTZWxlY3RvciIsImFwcGVuZENoaWxkIiwiY3JlYXRlTGl2ZVN0cmVhbSIsIkNhbWVyYUFjY2VzcyIsInJlcXVlc3QiLCJjb25zdHJhaW50cyIsInRoZW4iLCJ0cmlnZ2VyIiwiY2F0Y2giLCJlcnIiLCJzZXRBdHRyaWJ1dGUiLCJzZXRJbnB1dFN0cmVhbSIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYW5SZWNvcmQiLCJiaW5kIiwidGFyZ2V0Iiwibm9kZU5hbWUiLCJub2RlVHlwZSIsInNlbGVjdG9yIiwiQmFyY29kZUxvY2F0b3IiLCJjaGVja0ltYWdlQ29uc3RyYWludHMiLCJsb2NhdG9yIiwiaW5pdENhbnZhcyIsIkZyYW1lR3JhYmJlciIsImFkanVzdFdvcmtlclBvb2wiLCJudW1PZldvcmtlcnMiLCJyZWFkeSIsInBsYXkiLCJjbGFzc05hbWUiLCJnZXRDYW52YXNTaXplIiwiY2xlYXJGaXgiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImNvbnNvbGUiLCJsb2ciLCJnZXRCb3VuZGluZ0JveGVzIiwibG9jYXRlIiwidHJhbnNmb3JtUmVzdWx0IiwidG9wUmlnaHQiLCJnZXRUb3BSaWdodCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiYmFyY29kZXMiLCJtb3ZlTGluZSIsImJveCIsIm1vdmVCb3giLCJib3hlcyIsImNvcm5lciIsImFkZFJlc3VsdCIsImZpbHRlciIsImJhcmNvZGUiLCJjb2RlUmVzdWx0IiwiaGFzQ29kZVJlc3VsdCIsInNvbWUiLCJwdWJsaXNoUmVzdWx0IiwicmVzdWx0VG9QdWJsaXNoIiwiRXZlbnRzIiwicHVibGlzaCIsImxvY2F0ZUFuZERlY29kZSIsImRlY29kZUZyb21Cb3VuZGluZ0JveGVzIiwidXBkYXRlIiwiYXZhaWxhYmxlV29ya2VyIiwid29ya2VyVGhyZWFkIiwiYnVzeSIsImF0dGFjaERhdGEiLCJncmFiIiwid29ya2VyIiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJidWZmZXIiLCJzdGFydENvbnRpbnVvdXNVcGRhdGUiLCJkZWxheSIsImZyZXF1ZW5jeSIsInRpbWVzdGFtcCIsIndpbmRvdyIsInJlcXVlc3RBbmltRnJhbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImluaXRXb3JrZXIiLCJibG9iVVJMIiwiZ2VuZXJhdGVXb3JrZXJCbG9iIiwiV29ya2VyIiwib25tZXNzYWdlIiwiZXZlbnQiLCJVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJtZXNzYWdlIiwiY29uZmlnRm9yV29ya2VyIiwid29ya2VySW50ZXJmYWNlIiwiZmFjdG9yeSIsIlF1YWdnYSIsIm9uUHJvY2Vzc2VkIiwic2V0UmVhZGVycyIsInJlYWRlcnMiLCJibG9iIiwiZmFjdG9yeVNvdXJjZSIsIl9fZmFjdG9yeVNvdXJjZV9fIiwiQmxvYiIsInRvU3RyaW5nIiwiY3JlYXRlT2JqZWN0VVJMIiwiY2FwYWNpdHkiLCJpbmNyZWFzZUJ5Iiwid29ya2Vyc1RvVGVybWluYXRlIiwic2xpY2UiLCJ0ZXJtaW5hdGUiLCJ3b3JrZXJJbml0aWFsaXplZCIsInN0b3AiLCJyZWxlYXNlIiwiY2xlYXJFdmVudEhhbmRsZXJzIiwicGF1c2UiLCJvbkRldGVjdGVkIiwic3Vic2NyaWJlIiwib2ZmRGV0ZWN0ZWQiLCJ1bnN1YnNjcmliZSIsIm9mZlByb2Nlc3NlZCIsInJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yIiwicmVzdWx0Q29sbGVjdG9yIiwiZGVjb2RlU2luZ2xlIiwicmVzdWx0Q2FsbGJhY2siLCJzZXF1ZW5jZSIsImRlYnVnIiwib25jZSIsIkltYWdlRGVidWciLCJSZXN1bHRDb2xsZWN0b3IiLCJjb250YWlucyIsImV2ZXJ5IiwicGFzc2VzRmlsdGVyIiwicmVzdWx0cyIsImNhcHR1cmUiLCJtYXRjaGVzQ29uc3RyYWludHMiLCJibGFja2xpc3QiLCJpbWFnZVNpemUiLCJ0b0RhdGFVUkwiLCJnZXRSZXN1bHRzIiwiZG90IiwicG9pbnRNYXAiLCJ1cGRhdGVDZW50ZXIiLCJwb2ludFRvQWRkIiwiaWQiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImdldFBvaW50cyIsImdldENlbnRlciIsImV2ZW50cyIsImdldEV2ZW50IiwiZXZlbnROYW1lIiwic3Vic2NyaWJlcnMiLCJjbGVhckV2ZW50cyIsInB1Ymxpc2hTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJhc3luYyIsInNldFRpbWVvdXQiLCJzdWJzY3JpYmVyIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImdldFVzZXJNZWRpYSIsIlN1YkltYWdlIiwiSSIsIm9yaWdpbmFsU2l6ZSIsInVwZGF0ZURhdGEiLCJ1cGRhdGVGcm9tIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaW11bCIsImFoIiwiYWwiLCJiaCIsImJsIiwiYXNzaWduIiwiVHlwZUVycm9yIiwiaW5kZXgiLCJhcmd1bWVudHMiLCJuZXh0U291cmNlIiwibmV4dEtleSIsImhhc093blByb3BlcnR5IiwibW9kdWxlIiwiZXhwb3J0cyIsIm5hbWUiLCJmYWNpbmdNb2RlIiwiZHJhd0JvdW5kaW5nQm94Iiwic2hvd0ZyZXF1ZW5jeSIsImRyYXdTY2FubGluZSIsInNob3dQYXR0ZXJuIiwic2hvd0NhbnZhcyIsInNob3dQYXRjaGVzIiwic2hvd0ZvdW5kUGF0Y2hlcyIsInNob3dTa2VsZXRvbiIsInNob3dMYWJlbHMiLCJzaG93UGF0Y2hMYWJlbHMiLCJzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMiLCJib3hGcm9tUGF0Y2hlcyIsInNob3dUcmFuc2Zvcm1lZCIsInNob3dUcmFuc2Zvcm1lZEJveCIsInNob3dCQiIsIkVOViIsIm5vZGUiLCJSRUFERVJTIiwiY29kZV8xMjhfcmVhZGVyIiwiZWFuX3JlYWRlciIsImVhbl81X3JlYWRlciIsImVhbl8yX3JlYWRlciIsImVhbl84X3JlYWRlciIsImNvZGVfMzlfcmVhZGVyIiwiY29kZV8zOV92aW5fcmVhZGVyIiwiY29kYWJhcl9yZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJDb2RlOTNSZWFkZXIiLCJpbnB1dEltYWdlV3JhcHBlciIsIl9jYW52YXMiLCJfYmFyY29kZVJlYWRlcnMiLCJpbml0UmVhZGVycyIsImluaXRDb25maWciLCIkZGVidWciLCJyZWFkZXJDb25maWciLCJyZWFkZXIiLCJjb25maWd1cmF0aW9uIiwibWFwIiwiSlNPTiIsInN0cmluZ2lmeSIsInZpcyIsInByb3AiLCJkaXNwbGF5IiwiZ2V0RXh0ZW5kZWRMaW5lIiwiYW5nbGUiLCJleHRlbmRMaW5lIiwiYW1vdW50IiwiZXh0ZW5zaW9uIiwiY2VpbCIsImdldExpbmUiLCJ0cnlEZWNvZGUiLCJiYXJjb2RlTGluZSIsIkJyZXNlbmhhbSIsImdldEJhcmNvZGVMaW5lIiwicHJpbnRGcmVxdWVuY3kiLCJ0b0JpbmFyeUxpbmUiLCJwcmludFBhdHRlcm4iLCJ0cnlEZWNvZGVCcnV0ZUZvcmNlIiwibGluZUFuZ2xlIiwic2lkZUxlbmd0aCIsInBvdyIsInNsaWNlcyIsInhkaXIiLCJ5ZGlyIiwiZ2V0TGluZUxlbmd0aCIsImRlY29kZUZyb21Cb3VuZGluZ0JveCIsImxpbmVMZW5ndGgiLCJhdGFuMiIsIm11bHRpcGxlIiwiU2xvcGUiLCJESVIiLCJVUCIsIkRPV04iLCJ4MCIsInkwIiwieDEiLCJ5MSIsInN0ZWVwIiwiZGVsdGF4IiwiZGVsdGF5IiwieXN0ZXAiLCJyZWFkIiwic2xvcGUiLCJzbG9wZTIiLCJleHRyZW1hIiwiY3VycmVudERpciIsInJUaHJlc2hvbGQiLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsImZhY2luZ01hdGNoaW5nIiwic3RyZWFtUmVmIiwid2FpdEZvclZpZGVvIiwicmVzb2x2ZSIsImF0dGVtcHRzIiwiY2hlY2tWaWRlbyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImluaXRDYW1lcmEiLCJzdHJlYW0iLCJzcmNPYmplY3QiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibm9ybWFsaXplZCIsIm1pbkFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJmYWNpbmciLCJwaWNrQ29uc3RyYWludHMiLCJub3JtYWxpemVkQ29uc3RyYWludHMiLCJhdWRpbyIsImRldmljZUlkIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiZGV2aWNlcyIsImRldmljZSIsImtpbmQiLCJnZXRBY3RpdmVUcmFjayIsInRyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiZ2V0QWN0aXZlU3RyZWFtTGFiZWwiLCJ0cmFjayIsIkV4aWZUYWdzIiwiQXZhaWxhYmxlVGFncyIsImZpbmRUYWdzSW5PYmplY3RVUkwiLCJ0YWdzIiwidGVzdCIsIm9iamVjdFVSTFRvQmxvYiIsInJlYWRUb0J1ZmZlciIsImZpbmRUYWdzSW5CdWZmZXIiLCJiYXNlNjRUb0FycmF5QnVmZmVyIiwiZGF0YVVybCIsImJhc2U2NCIsInJlcGxhY2UiLCJiaW5hcnkiLCJhdG9iIiwibGVuIiwiQXJyYXlCdWZmZXIiLCJ2aWV3IiwiY2hhckNvZGVBdCIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJ1cmwiLCJodHRwIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJzdGF0dXMiLCJyZXNwb25zZSIsIm9uZXJyb3IiLCJzZW5kIiwiZmlsZSIsInNlbGVjdGVkVGFncyIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJieXRlTGVuZ3RoIiwiZXhpZlRhZ3MiLCJzZWxlY3RlZFRhZyIsImV4aWZUYWciLCJ0YWciLCJtYXJrZXIiLCJnZXRVaW50OCIsInJlYWRFWElGRGF0YSIsImdldFVpbnQxNiIsImdldFN0cmluZ0Zyb21CdWZmZXIiLCJ0aWZmT2Zmc2V0IiwiYmlnRW5kIiwiZmlyc3RJRkRPZmZzZXQiLCJnZXRVaW50MzIiLCJyZWFkVGFncyIsInRpZmZTdGFydCIsImRpclN0YXJ0Iiwic3RyaW5ncyIsImVudHJpZXMiLCJlbnRyeU9mZnNldCIsInJlYWRUYWdWYWx1ZSIsIm51bVZhbHVlcyIsIm91dHN0ciIsIlRPX1JBRElBTlMiLCJhZGp1c3RDYW52YXNTaXplIiwidGFyZ2V0U2l6ZSIsIl90aGF0IiwiX3N0cmVhbUNvbmZpZyIsImdldENvbmZpZyIsIl92aWRlb19zaXplIiwiZ2V0UmVhbFdpZHRoIiwiZ2V0UmVhbEhlaWdodCIsIl9jYW52YXNTaXplIiwiX3NpemUiLCJfc3giLCJfc3kiLCJfY3R4IiwiX2RhdGEiLCJ2aWRlb1NpemUiLCJjYW52YXNTaXplIiwiZ2V0RGF0YSIsImRvSGFsZlNhbXBsZSIsImdldEZyYW1lIiwiZHJhd2FibGUiLCJkcmF3QW5nbGUiLCJvcmllbnRhdGlvbiIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsImdldFNpemUiLCJJbWFnZUxvYWRlciIsImxvYWQiLCJkaXJlY3RvcnkiLCJodG1sSW1hZ2VzU3JjQXJyYXkiLCJodG1sSW1hZ2VzQXJyYXkiLCJudW0iLCJub3RMb2FkZWQiLCJhZGRJbWFnZSIsImxvYWRlZCIsImxvYWRlZEltZyIsIm5vdGxvYWRlZEltZ3MiLCJzcGxpY2UiLCJpbWdOYW1lIiwic3Vic3RyIiwibGFzdEluZGV4T2YiLCJhZGRPbmxvYWRIYW5kbGVyIiwiX2V2ZW50TmFtZXMiLCJfZXZlbnRIYW5kbGVycyIsIl9jYWxjdWxhdGVkV2lkdGgiLCJfY2FsY3VsYXRlZEhlaWdodCIsIl90b3BSaWdodCIsImluaXRTaXplIiwic2V0V2lkdGgiLCJzZXRIZWlnaHQiLCJlbmRlZCIsInNldEN1cnJlbnRUaW1lIiwidGltZSIsImN1cnJlbnRUaW1lIiwiZiIsImJvb2wiLCJoYW5kbGVycyIsImhhbmRsZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYXJncyIsInNldFRvcFJpZ2h0Iiwic2V0Q2FudmFzU2l6ZSIsImZyYW1lSWR4IiwicGF1c2VkIiwiaW1nQXJyYXkiLCJiYXNlVXJsIiwiY2FsY3VsYXRlZFdpZHRoIiwiY2FsY3VsYXRlZEhlaWdodCIsImxvYWRJbWFnZXMiLCJpbWdzIiwicHVibGlzaEV2ZW50IiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJ0cmFuc2Zvcm1NYXQyIiwibWF0MiIsImNvcHkiLCJfY3VycmVudEltYWdlV3JhcHBlciIsIl9za2VsSW1hZ2VXcmFwcGVyIiwiX3N1YkltYWdlV3JhcHBlciIsIl9sYWJlbEltYWdlV3JhcHBlciIsIl9wYXRjaEdyaWQiLCJfcGF0Y2hMYWJlbEdyaWQiLCJfaW1hZ2VUb1BhdGNoR3JpZCIsIl9iaW5hcnlJbWFnZVdyYXBwZXIiLCJfcGF0Y2hTaXplIiwiX251bVBhdGNoZXMiLCJfc2tlbGV0b25pemVyIiwic2tlbGV0b25JbWFnZURhdGEiLCJza2VsZXRvbml6ZXIiLCJnbG9iYWwiLCJ1c2VXb3JrZXIiLCJwYXRjaGVzIiwib3ZlckF2ZyIsInBhdGNoIiwidHJhbnNNYXQiLCJtaW54IiwibWlueSIsIm1heHgiLCJtYXh5IiwiYmluYXJpemVJbWFnZSIsImZpbmRQYXRjaGVzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwiUmFzdGVyaXplciIsInJhc3Rlcml6ZSIsImRlc2NyaWJlUGF0Y2giLCJmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzIiwibWF4TGFiZWwiLCJsYWJlbEhpc3QiLCJ0b3BMYWJlbHMiLCJzb3J0IiwiZWwiLCJmaW5kQm94ZXMiLCJzaW1pbGFyTW9tZW50cyIsInRvcENsdXN0ZXIiLCJwYXRjaFBvcyIsImVsaWdpYmxlTW9tZW50cyIsIm1hdGNoaW5nTW9tZW50cyIsIm1pbkNvbXBvbmVudFdlaWdodCIsInJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5IiwiY3VycklkeCIsIm5vdFlldFByb2Nlc3NlZCIsImN1cnJlbnRJZHgiLCJjdXJyZW50UGF0Y2giLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsInAiLCJjYyIsInNjIiwiY29ubmVjdGVkQ291bnQiLCJkcmF3Q29udG91ciIsImZpcnN0Q29udG91ciIsInBxIiwiaXEiLCJxIiwiU2tlbGV0b25pemVyIiwic3RkbGliIiwiZm9yZWlnbiIsImltYWdlcyIsImluSW1hZ2VQdHIiLCJvdXRJbWFnZVB0ciIsImFJbWFnZVB0ciIsImJJbWFnZVB0ciIsImltYWdlUHRyIiwibWVtY3B5Iiwic3JjSW1hZ2VQdHIiLCJkc3RJbWFnZVB0ciIsInN1YkltYWdlUHRyIiwiZXJvZGVkSW1hZ2VQdHIiLCJ0ZW1wSW1hZ2VQdHIiLCJza2VsSW1hZ2VQdHIiLCJkb25lIiwiVHdvT2ZGaXZlUmVhZGVyIiwiYmFyU3BhY2VSYXRpbyIsIk4iLCJXIiwid3JpdGFibGUiLCJzdGFydFBhdHRlcm5MZW5ndGgiLCJuYXJyb3dCYXJXaWR0aCIsImNvdW50ZXJMZW5ndGgiLCJfdmVyaWZ5Q291bnRlckxlbmd0aCIsIkNvZGFiYXJSZWFkZXIiLCJfY291bnRlcnMiLCJTVEFSVF9FTkQiLCJNSU5fRU5DT0RFRF9DSEFSUyIsIk1BWF9BQ0NFUFRBQkxFIiwiUEFERElORyIsInN0YXJ0Q291bnRlciIsIl9pc1N0YXJ0RW5kIiwiX3ZlcmlmeVdoaXRlc3BhY2UiLCJfdmFsaWRhdGVSZXN1bHQiLCJfc3VtQ291bnRlcnMiLCJlbmRDb3VudGVyIiwiX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgiLCJfdGhyZXNob2xkUmVzdWx0UGF0dGVybiIsImNhdGVnb3JpemF0aW9uIiwic3BhY2UiLCJuYXJyb3ciLCJjb3VudHMiLCJ3aWRlIiwiYmFyIiwiY2F0IiwiX2NoYXJUb1BhdHRlcm4iLCJuZXdraW5kIiwiY2hhciIsImNoYXJDb2RlIiwidGhyZXNob2xkcyIsIl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQiLCJiYXJUaHJlc2hvbGQiLCJzcGFjZVRocmVzaG9sZCIsImJpdG1hc2siLCJDb2RlMTI4UmVhZGVyIiwiQ09ERV9TSElGVCIsIkNPREVfQyIsIkNPREVfQiIsIkNPREVfQSIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQiIsIlNUQVJUX0NPREVfQyIsIlNUT1BfQ09ERSIsIk1PRFVMRV9JTkRJQ0VTIiwiX2NvcnJlY3QiLCJjYWxjdWxhdGVDb3JyZWN0aW9uIiwibXVsdGlwbGllciIsImNoZWNrc3VtIiwicmF3UmVzdWx0Iiwic2hpZnROZXh0IiwicmVtb3ZlTGFzdENoYXJhY3RlciIsImV4cGVjdGVkIiwic3VtTm9ybWFsaXplZCIsInN1bUV4cGVjdGVkIiwiQ29kZTM5VklOUmVhZGVyIiwicGF0dGVybnMiLCJJT1EiLCJBWjA5IiwiX2NoZWNrQ2hlY2tzdW0iLCJzcGxpdCIsIl92ZXJpZnlFbmQiLCJfdmVyaWZ5Q2hlY2tzdW1zIiwiX2RlY29kZUV4dGVuZGVkIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJfbWF0Y2hDaGVja0NoYXIiLCJtYXhXZWlnaHQiLCJhcnJheVRvQ2hlY2siLCJ3ZWlnaHRlZFN1bXMiLCJ3ZWlnaHQiLCJjaGVja0NoYXIiLCJFQU4yUmVhZGVyIiwicGFyc2VJbnQiLCJFQU41UmVhZGVyIiwiQ0hFQ0tfRElHSVRfRU5DT0RJTkdTIiwiZXh0ZW5zaW9uQ2hlY2tzdW0iLCJkZXRlcm1pbmVDaGVja0RpZ2l0IiwiRUFOOFJlYWRlciIsIkkyb2Y1UmVhZGVyIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsIk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiIsImNvdW50ZXJTdW0iLCJjb2RlU3VtIiwiY29ycmVjdGlvblJhdGlvIiwiY29ycmVjdGlvblJhdGlvSW52ZXJzZSIsIl9kZWNvZGVQYWlyIiwiY291bnRlclBhaXIiLCJjb2RlcyIsIlVQQ0VSZWFkZXIiLCJfZGV0ZXJtaW5lUGFyaXR5IiwibnJTeXN0ZW0iLCJfY29udmVydFRvVVBDQSIsInVwY2EiLCJsYXN0RGlnaXQiLCJVUENSZWFkZXIiLCJjaGFyQXQiLCJzdWJzdHJpbmciXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNSQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFh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QzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNwQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2xDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xC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LEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJxdWFnZ2EuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkudG9TdHJpbmcoKSkuZGVmYXVsdDtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlF1YWdnYVwiXSA9IGZhY3RvcnkoZmFjdG9yeS50b1N0cmluZygpKS5kZWZhdWx0O1xuXHRlbHNlXG5cdFx0cm9vdFtcIlF1YWdnYVwiXSA9IGZhY3RvcnkoZmFjdG9yeS50b1N0cmluZygpKS5kZWZhdWx0O1xufSkodGhpcywgZnVuY3Rpb24oX19mYWN0b3J5U291cmNlX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9teU1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNjYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGM0MTUzNDM1NTc0OTMwMTViYjQxIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuZnVuY3Rpb24gQmFyY29kZVJlYWRlcihjb25maWcsIHN1cHBsZW1lbnRzKSB7XG4gICAgdGhpcy5fcm93ID0gW107XG4gICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgdGhpcy5zdXBwbGVtZW50cyA9IHN1cHBsZW1lbnRzO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbmV4dFVuc2V0ID0gZnVuY3Rpb24obGluZSwgc3RhcnQpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghbGluZVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xufTtcblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX21hdGNoUGF0dGVybiA9IGZ1bmN0aW9uKGNvdW50ZXIsIGNvZGUsIG1heFNpbmdsZUVycm9yKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGVycm9yID0gMCxcbiAgICAgICAgc2luZ2xlRXJyb3IgPSAwLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBtb2R1bG8gPSAwLFxuICAgICAgICBiYXJXaWR0aCxcbiAgICAgICAgY291bnQsXG4gICAgICAgIHNjYWxlZDtcblxuICAgIG1heFNpbmdsZUVycm9yID0gbWF4U2luZ2xlRXJyb3IgfHwgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiB8fCAxO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XG4gICAgICAgIG1vZHVsbyArPSBjb2RlW2ldO1xuICAgIH1cbiAgICBpZiAoc3VtIDwgbW9kdWxvKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgICBiYXJXaWR0aCA9IHN1bSAvIG1vZHVsbztcbiAgICBtYXhTaW5nbGVFcnJvciAqPSBiYXJXaWR0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50ID0gY291bnRlcltpXTtcbiAgICAgICAgc2NhbGVkID0gY29kZVtpXSAqIGJhcldpZHRoO1xuICAgICAgICBzaW5nbGVFcnJvciA9IE1hdGguYWJzKGNvdW50IC0gc2NhbGVkKSAvIHNjYWxlZDtcbiAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yICs9IHNpbmdsZUVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3IgLyBtb2R1bG87XG59O1xuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbmV4dFNldCA9IGZ1bmN0aW9uKGxpbmUsIG9mZnNldCkge1xuICAgIHZhciBpO1xuXG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xufTtcblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX2NvcnJlY3RCYXJzID0gZnVuY3Rpb24oY291bnRlciwgY29ycmVjdGlvbiwgaW5kaWNlcykge1xuICAgIHZhciBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgdG1wID0gMDtcbiAgICB3aGlsZShsZW5ndGgtLSkge1xuICAgICAgICB0bXAgPSBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gKiAoMSAtICgoMSAtIGNvcnJlY3Rpb24pIC8gMikpO1xuICAgICAgICBpZiAodG1wID4gMSkge1xuICAgICAgICAgICAgY291bnRlcltpbmRpY2VzW2xlbmd0aF1dID0gdG1wO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbWF0Y2hUcmFjZSA9IGZ1bmN0aW9uKGNtcENvdW50ZXIsIGVwc2lsb24pIHtcbiAgICB2YXIgY291bnRlciA9IFtdLFxuICAgICAgICBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBpc1doaXRlID0gIXNlbGYuX3Jvd1tvZmZzZXRdLFxuICAgICAgICBjb3VudGVyUG9zID0gMCxcbiAgICAgICAgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yO1xuXG4gICAgaWYgKGNtcENvdW50ZXIpIHtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBjbXBDb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgY21wQ291bnRlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvdW50ZXIgPSBjb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudGVyLnB1c2goMCk7XG4gICAgICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgY291bnRlci5wdXNoKDApO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGNtcENvdW50ZXIgd2FzIG5vdCBnaXZlblxuICAgIGJlc3RNYXRjaC5zdGFydCA9IG9mZnNldDtcbiAgICBiZXN0TWF0Y2guZW5kID0gc2VsZi5fcm93Lmxlbmd0aCAtIDE7XG4gICAgYmVzdE1hdGNoLmNvdW50ZXIgPSBjb3VudGVyO1xuICAgIHJldHVybiBiZXN0TWF0Y2g7XG59O1xuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgc2VsZi5fcm93ID0gcGF0dGVybjtcbiAgICByZXN1bHQgPSBzZWxmLl9kZWNvZGUoKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHNlbGYuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuX2RlY29kZSgpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZVJlYWRlci5ESVJFQ1RJT04uUkVWRVJTRTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHNlbGYuX3Jvdy5sZW5ndGggLSByZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuZW5kID0gc2VsZi5fcm93Lmxlbmd0aCAtIHJlc3VsdC5lbmQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZVJlYWRlci5ESVJFQ1RJT04uRk9SV0FSRDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuZm9ybWF0ID0gc2VsZi5GT1JNQVQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbWF0Y2hSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG4gICAgdmFyIGk7XG5cbiAgICBzdGFydCA9IHN0YXJ0IDwgMCA/IDAgOiBzdGFydDtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3dbaV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fZmlsbENvdW50ZXJzID0gZnVuY3Rpb24ob2Zmc2V0LCBlbmQsIGlzV2hpdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBpLFxuICAgICAgICBjb3VudGVycyA9IFtdO1xuXG4gICAgaXNXaGl0ZSA9ICh0eXBlb2YgaXNXaGl0ZSAhPT0gJ3VuZGVmaW5lZCcpID8gaXNXaGl0ZSA6IHRydWU7XG4gICAgb2Zmc2V0ID0gKHR5cGVvZiBvZmZzZXQgIT09ICd1bmRlZmluZWQnKSA/IG9mZnNldCA6IHNlbGYuX25leHRVbnNldChzZWxmLl9yb3cpO1xuICAgIGVuZCA9IGVuZCB8fCBzZWxmLl9yb3cubGVuZ3RoO1xuXG4gICAgY291bnRlcnNbY291bnRlclBvc10gPSAwO1xuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVycztcbn07XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl90b0NvdW50ZXJzID0gZnVuY3Rpb24oc3RhcnQsIGNvdW50ZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIG51bUNvdW50ZXJzID0gY291bnRlci5sZW5ndGgsXG4gICAgICAgIGVuZCA9IHNlbGYuX3Jvdy5sZW5ndGgsXG4gICAgICAgIGlzV2hpdGUgPSAhc2VsZi5fcm93W3N0YXJ0XSxcbiAgICAgICAgaSxcbiAgICAgICAgY291bnRlclBvcyA9IDA7XG5cbiAgICBBcnJheUhlbHBlci5pbml0KGNvdW50ZXIsIDApO1xuXG4gICAgZm9yICggaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBudW1Db3VudGVycykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY291bnRlcjtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXJjb2RlUmVhZGVyLnByb3RvdHlwZSwgXCJGT1JNQVRcIiwge1xuICAgIHZhbHVlOiAndW5rbm93bicsXG4gICAgd3JpdGVhYmxlOiBmYWxzZVxufSk7XG5cbkJhcmNvZGVSZWFkZXIuRElSRUNUSU9OID0ge1xuICAgIEZPUldBUkQ6IDEsXG4gICAgUkVWRVJTRTogLTFcbn07XG5cbkJhcmNvZGVSZWFkZXIuRXhjZXB0aW9uID0ge1xuICAgIFN0YXJ0Tm90Rm91bmRFeGNlcHRpb246IFwiU3RhcnQtSW5mbyB3YXMgbm90IGZvdW5kIVwiLFxuICAgIENvZGVOb3RGb3VuZEV4Y2VwdGlvbjogXCJDb2RlIGNvdWxkIG5vdCBiZSBmb3VuZCFcIixcbiAgICBQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb246IFwiUGF0dGVybiBjb3VsZCBub3QgYmUgZm91bmQhXCJcbn07XG5cbkJhcmNvZGVSZWFkZXIuQ09ORklHX0tFWVMgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgQmFyY29kZVJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0OiBmdW5jdGlvbihhcnIsIHZhbCkge1xuICAgICAgICB2YXIgbCA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgIGFycltsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaHVmZmxlcyB0aGUgY29udGVudCBvZiBhbiBhcnJheVxuICAgICAqIEByZXR1cm4ge0FycmF5fSB0aGUgYXJyYXkgaXRzZWxmIHNodWZmbGVkXG4gICAgICovXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciBpID0gYXJyLmxlbmd0aCAtIDEsIGosIHg7XG4gICAgICAgIGZvciAoaTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKTtcbiAgICAgICAgICAgIHggPSBhcnJbaV07XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgICAgICAgICBhcnJbal0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGksIGosIHJvdyA9IFtdLCByb3dzID0gW107XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgYXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93W2pdID0gYXJyW2ldW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93c1tpXSA9IFwiW1wiICsgcm93LmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiW1wiICsgcm93cy5qb2luKFwiLFxcclxcblwiKSArIFwiXVwiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBlbGVtZW50cyB3aGljaCdzIHNjb3JlIGlzIGJpZ2dlciB0aGFuIHRoZSB0aHJlc2hvbGRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIHJlZHVjZWQgYXJyYXlcbiAgICAgKi9cbiAgICB0aHJlc2hvbGQ6IGZ1bmN0aW9uKGFyciwgdGhyZXNob2xkLCBzY29yZUZ1bmMpIHtcbiAgICAgICAgdmFyIGksIHF1ZXVlID0gW107XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmVGdW5jLmFwcGx5KGFyciwgW2FycltpXV0pID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goYXJyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfSxcblxuICAgIG1heEluZGV4OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGksIG1heCA9IDA7XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gYXJyW21heF0pIHtcbiAgICAgICAgICAgICAgICBtYXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciBpLCBtYXggPSAwO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycltpXSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH0sXG5cbiAgICBzdW06IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIHN1bSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBzdW0gKz0gYXJyW2xlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9hcnJheV9oZWxwZXIuanMiLCJpbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCB7bWVyZ2V9IGZyb20gJ2xvZGFzaCc7XG5cbmZ1bmN0aW9uIEVBTlJlYWRlcihvcHRzLCBzdXBwbGVtZW50cykge1xuICAgIG9wdHMgPSBtZXJnZShnZXREZWZhdWxDb25maWcoKSwgb3B0cyk7XG4gICAgQmFyY29kZVJlYWRlci5jYWxsKHRoaXMsIG9wdHMsIHN1cHBsZW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsQ29uZmlnKCkge1xuICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKEVBTlJlYWRlci5DT05GSUdfS0VZUykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgY29uZmlnW2tleV0gPSBFQU5SZWFkZXIuQ09ORklHX0tFWVNba2V5XS5kZWZhdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiBjb25maWc7XG59XG5cbnZhciBwcm9wZXJ0aWVzID0ge1xuICAgIENPREVfTF9TVEFSVDoge3ZhbHVlOiAwfSxcbiAgICBDT0RFX0dfU1RBUlQ6IHt2YWx1ZTogMTB9LFxuICAgIFNUQVJUX1BBVFRFUk46IHt2YWx1ZTogWzEsIDEsIDFdfSxcbiAgICBTVE9QX1BBVFRFUk46IHt2YWx1ZTogWzEsIDEsIDFdfSxcbiAgICBNSURETEVfUEFUVEVSTjoge3ZhbHVlOiBbMSwgMSwgMSwgMSwgMV19LFxuICAgIEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOOiB7dmFsdWU6IFsxLCAxLCAyXX0sXG4gICAgQ09ERV9QQVRURVJOOiB7dmFsdWU6IFtcbiAgICAgICAgWzMsIDIsIDEsIDFdLFxuICAgICAgICBbMiwgMiwgMiwgMV0sXG4gICAgICAgIFsyLCAxLCAyLCAyXSxcbiAgICAgICAgWzEsIDQsIDEsIDFdLFxuICAgICAgICBbMSwgMSwgMywgMl0sXG4gICAgICAgIFsxLCAyLCAzLCAxXSxcbiAgICAgICAgWzEsIDEsIDEsIDRdLFxuICAgICAgICBbMSwgMywgMSwgMl0sXG4gICAgICAgIFsxLCAyLCAxLCAzXSxcbiAgICAgICAgWzMsIDEsIDEsIDJdLFxuICAgICAgICBbMSwgMSwgMiwgM10sXG4gICAgICAgIFsxLCAyLCAyLCAyXSxcbiAgICAgICAgWzIsIDIsIDEsIDJdLFxuICAgICAgICBbMSwgMSwgNCwgMV0sXG4gICAgICAgIFsyLCAzLCAxLCAxXSxcbiAgICAgICAgWzEsIDMsIDIsIDFdLFxuICAgICAgICBbNCwgMSwgMSwgMV0sXG4gICAgICAgIFsyLCAxLCAzLCAxXSxcbiAgICAgICAgWzMsIDEsIDIsIDFdLFxuICAgICAgICBbMiwgMSwgMSwgM11cbiAgICBdfSxcbiAgICBDT0RFX0ZSRVFVRU5DWToge3ZhbHVlOiBbMCwgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl19LFxuICAgIFNJTkdMRV9DT0RFX0VSUk9SOiB7dmFsdWU6IDAuNzB9LFxuICAgIEFWR19DT0RFX0VSUk9SOiB7dmFsdWU6IDAuNDh9LFxuICAgIEZPUk1BVDoge3ZhbHVlOiBcImVhbl8xM1wiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFyY29kZVJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuRUFOUmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVBTlJlYWRlcjtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlQ29kZSA9IGZ1bmN0aW9uKHN0YXJ0LCBjb2RlcmFuZ2UpIHtcbiAgICB2YXIgY291bnRlciA9IFswLCAwLCAwLCAwXSxcbiAgICAgICAgaSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9mZnNldCA9IHN0YXJ0LFxuICAgICAgICBpc1doaXRlID0gIXNlbGYuX3Jvd1tvZmZzZXRdLFxuICAgICAgICBjb3VudGVyUG9zID0gMCxcbiAgICAgICAgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRcbiAgICAgICAgfSxcbiAgICAgICAgY29kZSxcbiAgICAgICAgZXJyb3I7XG5cbiAgICBpZiAoIWNvZGVyYW5nZSkge1xuICAgICAgICBjb2RlcmFuZ2UgPSBzZWxmLkNPREVfUEFUVEVSTi5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCBjb2RlcmFuZ2U7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBzZWxmLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA+IHNlbGYuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fZmluZFBhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuLCBvZmZzZXQsIGlzV2hpdGUsIHRyeUhhcmRlciwgZXBzaWxvbikge1xuICAgIHZhciBjb3VudGVyID0gW10sXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBpLFxuICAgICAgICBjb3VudGVyUG9zID0gMCxcbiAgICAgICAgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yLFxuICAgICAgICBqLFxuICAgICAgICBzdW07XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3Jvdyk7XG4gICAgfVxuXG4gICAgaWYgKGlzV2hpdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpc1doaXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRyeUhhcmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeUhhcmRlciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCBlcHNpbG9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXBzaWxvbiA9IHNlbGYuQVZHX0NPREVfRVJST1I7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50ZXJbaV0gPSAwO1xuICAgIH1cblxuICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgY291bnRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9maW5kU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsXG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KSxcbiAgICAgICAgc3RhcnRJbmZvO1xuXG4gICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgc3RhcnRJbmZvID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5TVEFSVF9QQVRURVJOLCBvZmZzZXQpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KTtcbiAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICB9XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihlbmRJbmZvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArIChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpO1xuICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2ZpbmRFbmQgPSBmdW5jdGlvbihvZmZzZXQsIGlzV2hpdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVuZEluZm8gPSBzZWxmLl9maW5kUGF0dGVybihzZWxmLlNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBpc1doaXRlLCBmYWxzZSk7XG5cbiAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHNlbGYuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9jYWxjdWxhdGVGaXJzdERpZ2l0ID0gZnVuY3Rpb24oY29kZUZyZXF1ZW5jeSkge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgc2VsZi5DT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gc2VsZi5DT0RFX0ZSRVFVRU5DWVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24oY29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvZGVGcmVxdWVuY3kgPSAweDAsXG4gICAgICAgIGZpcnN0RGlnaXQ7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICBjb2RlID0gc2VsZi5fZGVjb2RlQ29kZShjb2RlLmVuZCk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBzZWxmLkNPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgY29kZS5jb2RlID0gY29kZS5jb2RlIC0gc2VsZi5DT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDUgLSBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMCA8PCAoNSAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIH1cblxuICAgIGZpcnN0RGlnaXQgPSBzZWxmLl9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3kpO1xuICAgIGlmIChmaXJzdERpZ2l0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXN1bHQudW5zaGlmdChmaXJzdERpZ2l0KTtcblxuICAgIGNvZGUgPSBzZWxmLl9maW5kUGF0dGVybihzZWxmLk1JRERMRV9QQVRURVJOLCBjb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBzZWxmLkNPREVfR19TVEFSVCk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGU7XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRJbmZvLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgY29kZSxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIGRlY29kZWRDb2RlcyA9IFtdLFxuICAgICAgICByZXN1bHRJbmZvID0ge307XG5cbiAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kU3RhcnQoKTtcbiAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29kZSA9IHtcbiAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxuICAgIH07XG4gICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgY29kZSA9IHNlbGYuX2RlY29kZVBheWxvYWQoY29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29kZSA9IHNlbGYuX2ZpbmRFbmQoY29kZS5lbmQsIGZhbHNlKTtcbiAgICBpZiAoIWNvZGUpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgIC8vIENoZWNrc3VtXG4gICAgaWYgKCFzZWxmLl9jaGVja3N1bShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGV4dCA9IHRoaXMuX2RlY29kZUV4dGVuc2lvbnMoY29kZS5lbmQpO1xuICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3RDb2RlID0gZXh0LmRlY29kZWRDb2Rlc1tleHQuZGVjb2RlZENvZGVzLmxlbmd0aC0xXSxcbiAgICAgICAgICAgIGVuZEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RDb2RlLnN0YXJ0ICsgKCgobGFzdENvZGUuZW5kIC0gbGFzdENvZGUuc3RhcnQpIC8gMikgfCAwKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGxhc3RDb2RlLmVuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYoIXNlbGYuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0SW5mbyA9IHtcbiAgICAgICAgICAgIHN1cHBsZW1lbnQ6IGV4dCxcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpICsgZXh0LmNvZGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICBjb2Rlc2V0OiBcIlwiLFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgIC4uLnJlc3VsdEluZm9cbiAgICB9O1xufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBpLFxuICAgICAgICBzdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBvZmZzZXQpLFxuICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLkVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLCBzdGFydCwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnN1cHBsZW1lbnRzW2ldLmRlY29kZSh0aGlzLl9yb3csIHN0YXJ0SW5mby5lbmQpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5jb2RlLFxuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgICAgICBlbmQ6IHJlc3VsdC5lbmQsXG4gICAgICAgICAgICAgICAgY29kZXNldDogXCJcIixcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdC5kZWNvZGVkQ29kZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2NoZWNrc3VtID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgdmFyIHN1bSA9IDAsIGk7XG5cbiAgICBmb3IgKCBpID0gcmVzdWx0Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIGZvciAoIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xufTtcblxuRUFOUmVhZGVyLkNPTkZJR19LRVlTID0ge1xuICAgIHN1cHBsZW1lbnRzOiB7XG4gICAgICAgICd0eXBlJzogJ2FycmF5T2Yoc3RyaW5nKScsXG4gICAgICAgICdkZWZhdWx0JzogW10sXG4gICAgICAgICdkZXNjcmlwdGlvbic6ICdBbGxvd2VkIGV4dGVuc2lvbnMgdG8gYmUgZGVjb2RlZCAoMiBhbmQvb3IgNSknXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKEVBTlJlYWRlcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2Vhbl9yZWFkZXIuanMiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19yb290LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC12ZWMyL2Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlR2V0VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3UmVjdDogZnVuY3Rpb24ocG9zLCBzaXplLCBjdHgsIHN0eWxlKXtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24ocGF0aCwgZGVmLCBjdHgsIHN0eWxlKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwYXRoWzBdW2RlZi54XSwgcGF0aFswXVtkZWYueV0pO1xuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHBhdGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocGF0aFtqXVtkZWYueF0sIHBhdGhbal1bZGVmLnldKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9LFxuICAgIGRyYXdJbWFnZTogZnVuY3Rpb24oaW1hZ2VEYXRhLCBzaXplLCBjdHgpIHtcbiAgICAgICAgdmFyIGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KSxcbiAgICAgICAgICAgIGRhdGEgPSBjYW52YXNEYXRhLmRhdGEsXG4gICAgICAgICAgICBpbWFnZURhdGFQb3MgPSBpbWFnZURhdGEubGVuZ3RoLFxuICAgICAgICAgICAgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgaWYgKGNhbnZhc0RhdGFQb3MgLyBpbWFnZURhdGFQb3MgIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW1hZ2VEYXRhUG9zLS0pe1xuICAgICAgICAgICAgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9pbWFnZV9kZWJ1Zy5qcyIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19MaXN0Q2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY2FzdFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRNYXBEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faXNJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2VxLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzQXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQ2x1c3RlcjIgZnJvbSAnLi9jbHVzdGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5jb25zdCB2ZWMyID0ge1xuICAgIGNsb25lOiByZXF1aXJlKCdnbC12ZWMyL2Nsb25lJyksXG59O1xuY29uc3QgdmVjMyA9IHtcbiAgICBjbG9uZTogcmVxdWlyZSgnZ2wtdmVjMy9jbG9uZScpLFxufTtcblxuLyoqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxuICogQHJldHVybiBJbWFnZVJlZmVyZW5jZSB7eCx5fSBDb29yZGluYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gICAgdmFyIHRoYXQgPSB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHRvVmVjMjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVjMi5jbG9uZShbdGhpcy54LCB0aGlzLnldKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9WZWMzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgICAgICB9LFxuICAgICAgICByb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueCArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueCAtIDAuNSk7XG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnkgPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueSArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueSAtIDAuNSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoYXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIGFuIGludGVncmFsIGltYWdlIG9mIGEgZ2l2ZW4gZ3JheXNjYWxlIGltYWdlLlxuICogQHBhcmFtIGltYWdlRGF0YUNvbnRhaW5lciB7SW1hZ2VEYXRhQ29udGFpbmVyfSB0aGUgaW1hZ2UgdG8gYmUgaW50ZWdyYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UyKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XG4gICAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIHZhciB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgdmFyIGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgdmFyIGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHN1bSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMCwgcG9zQyA9IDAsIHBvc0QgPSAwLCB4LCB5O1xuXG4gICAgLy8gc3VtIHVwIGZpcnN0IGNvbHVtblxuICAgIHBvc0IgPSB3aWR0aDtcbiAgICBzdW0gPSAwO1xuICAgIGZvciAoIHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBICs9IHdpZHRoO1xuICAgICAgICBwb3NCICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHBvc0EgPSAwO1xuICAgIHBvc0IgPSAxO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICggeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcbiAgICAgICAgcG9zQSsrO1xuICAgICAgICBwb3NCKys7XG4gICAgfVxuXG4gICAgZm9yICggeSA9IDE7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBwb3NBID0geSAqIHdpZHRoICsgMTtcbiAgICAgICAgcG9zQiA9ICh5IC0gMSkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0MgPSB5ICogd2lkdGg7XG4gICAgICAgIHBvc0QgPSAoeSAtIDEpICogd2lkdGg7XG4gICAgICAgIGZvciAoIHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV0gKz1cbiAgICAgICAgICAgICAgICBpbWFnZURhdGFbcG9zQV0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0NdIC0gaW50ZWdyYWxJbWFnZURhdGFbcG9zRF07XG4gICAgICAgICAgICBwb3NBKys7XG4gICAgICAgICAgICBwb3NCKys7XG4gICAgICAgICAgICBwb3NDKys7XG4gICAgICAgICAgICBwb3NEKys7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICB2YXIgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICB2YXIgc3VtID0gMDtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCByb3dcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtpXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbaV0gPSBzdW07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgdiA9IDE7IHYgPCBoZWlnaHQ7IHYrKykge1xuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpbWFnZURhdGFbdiAqIHdpZHRoICsgdV07XG4gICAgICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSBzdW0gKyBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIDEpICogd2lkdGggKyB1XTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICB0YXJnZXRXcmFwcGVyID0gaW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGEsIGxlbmd0aCA9IGltYWdlRGF0YS5sZW5ndGgsIHRhcmdldERhdGEgPSB0YXJnZXRXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdGFyZ2V0RGF0YVtsZW5ndGhdID0gaW1hZ2VEYXRhW2xlbmd0aF0gPCB0aHJlc2hvbGQgPyAxIDogMDtcbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIGJpdHNQZXJQaXhlbCA9IDg7XG4gICAgfVxuICAgIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgbGVuZ3RoID0gaW1hZ2VEYXRhLmxlbmd0aCxcbiAgICAgICAgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsLFxuICAgICAgICBidWNrZXRDbnQgPSAxIDw8IGJpdHNQZXJQaXhlbCxcbiAgICAgICAgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3Q7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc2hhcnBlbkxpbmUobGluZSkge1xuICAgIHZhciBpLFxuICAgICAgICBsZW5ndGggPSBsaW5lLmxlbmd0aCxcbiAgICAgICAgbGVmdCA9IGxpbmVbMF0sXG4gICAgICAgIGNlbnRlciA9IGxpbmVbMV0sXG4gICAgICAgIHJpZ2h0O1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICByaWdodCA9IGxpbmVbaSArIDFdO1xuICAgICAgICAvLyAgLTEgNCAtMSBrZXJuZWxcbiAgICAgICAgbGluZVtpIC0gMV0gPSAoKChjZW50ZXIgKiAyKSAtIGxlZnQgLSByaWdodCkpICYgMjU1O1xuICAgICAgICBsZWZ0ID0gY2VudGVyO1xuICAgICAgICBjZW50ZXIgPSByaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIGJpdHNQZXJQaXhlbCA9IDg7XG4gICAgfVxuICAgIHZhciBoaXN0LFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbDtcblxuICAgIGZ1bmN0aW9uIHB4KGluaXQsIGVuZCkge1xuICAgICAgICB2YXIgc3VtID0gMCwgaTtcbiAgICAgICAgZm9yICggaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXgoaW5pdCwgZW5kKSB7XG4gICAgICAgIHZhciBpLCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAoIGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaSAqIGhpc3RbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVybWluZVRocmVzaG9sZCgpIHtcbiAgICAgICAgdmFyIHZldCA9IFswXSwgcDEsIHAyLCBwMTIsIGssIG0xLCBtMiwgbTEyLFxuICAgICAgICAgICAgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG5cbiAgICAgICAgaGlzdCA9IGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpO1xuICAgICAgICBmb3IgKCBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcDEyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcbiAgICAgICAgICAgIG0yID0gbXgoayArIDEsIG1heCkgKiBwMTtcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XG4gICAgfVxuXG4gICAgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBvdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIHZhciB0aHJlc2hvbGQgPSBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlcik7XG5cbiAgICB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcik7XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbn07XG5cbi8vIGxvY2FsIHRocmVzaG9sZGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcblxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICB0YXJnZXRXcmFwcGVyID0gaW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXRXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICB2YXIgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICB2YXIgc3VtID0gMCwgdiwgdSwga2VybmVsID0gMywgQSwgQiwgQywgRCwgYXZnLCBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxuICAgIGZvciAoIHYgPSAwOyB2IDw9IGtlcm5lbDsgdisrKSB7XG4gICAgICAgIGZvciAoIHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKChoZWlnaHQgLSAxKSAtIHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgb3V0IGxlZnQgJiByaWdodCBib3JkZXJcbiAgICBmb3IgKCB2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICggdSA9IDA7IHUgPD0ga2VybmVsOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArICh3aWR0aCAtIDEgLSB1KV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICggdiA9IGtlcm5lbCArIDE7IHYgPCBoZWlnaHQgLSBrZXJuZWwgLSAxOyB2KyspIHtcbiAgICAgICAgZm9yICggdSA9IGtlcm5lbCArIDE7IHUgPCB3aWR0aCAtIGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIEMgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XG4gICAgICAgICAgICBhdmcgPSBzdW0gLyAoc2l6ZSk7XG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2x1c3Rlcihwb2ludHMsIHRocmVzaG9sZCwgcHJvcGVydHkpIHtcbiAgICB2YXIgaSwgaywgY2x1c3RlciwgcG9pbnQsIGNsdXN0ZXJzID0gW107XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIHByb3BlcnR5ID0gXCJyYWRcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUb0NsdXN0ZXIobmV3UG9pbnQpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAoIGsgPSAwOyBrIDwgY2x1c3RlcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGNsdXN0ZXIgPSBjbHVzdGVyc1trXTtcbiAgICAgICAgICAgIGlmIChjbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgY2x1c3Rlci5hZGQobmV3UG9pbnQpO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGVhY2ggY2xvdWRcbiAgICBmb3IgKCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWFkZFRvQ2x1c3Rlcihwb2ludCkpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG5leHBvcnQgY29uc3QgVHJhY2VyID0ge1xuICAgIHRyYWNlOiBmdW5jdGlvbihwb2ludHMsIHZlYykge1xuICAgICAgICB2YXIgaXRlcmF0aW9uLCBtYXhJdGVyYXRpb25zID0gMTAsIHRvcCA9IFtdLCByZXN1bHQgPSBbXSwgY2VudGVyUG9zID0gMCwgY3VycmVudFBvcyA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoaWR4LCBmb3J3YXJkKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSwgdG8sIHRvSWR4LCBwcmVkaWN0ZWRQb3MsIHRocmVzaG9sZFggPSAxLCB0aHJlc2hvbGRZID0gTWF0aC5hYnModmVjWzFdIC8gMTApLCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaChwb3MsIHByZWRpY3RlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3MueCA+IChwcmVkaWN0ZWQueCAtIHRocmVzaG9sZFgpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueCA8IChwcmVkaWN0ZWQueCArIHRocmVzaG9sZFgpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueSA+IChwcmVkaWN0ZWQueSAtIHRocmVzaG9sZFkpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBwb3MueSA8IChwcmVkaWN0ZWQueSArIHRocmVzaG9sZFkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBuZXh0IGluZGV4IGlzIHdpdGhpbiB0aGUgdmVjIHNwZWNpZmljYXRpb25zXG4gICAgICAgICAgICAvLyBpZiBub3QsIGNoZWNrIGFzIGxvbmcgYXMgdGhlIHRocmVzaG9sZCBpcyBtZXRcblxuICAgICAgICAgICAgZnJvbSA9IHBvaW50c1tpZHhdO1xuICAgICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCArIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55ICsgdmVjWzFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggLSB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSAtIHZlY1sxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgd2hpbGUgKHRvICYmICggZm91bmQgPSBtYXRjaCh0bywgcHJlZGljdGVkUG9zKSkgIT09IHRydWUgJiYgKE1hdGguYWJzKHRvLnkgLSBmcm9tLnkpIDwgdmVjWzFdKSkge1xuICAgICAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IHRvSWR4ICsgMSA6IHRvSWR4IC0gMTtcbiAgICAgICAgICAgICAgICB0byA9IHBvaW50c1t0b0lkeF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA/IHRvSWR4IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgY2VudGVyUG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB3aGlsZSAoKCBjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgdHJ1ZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZW50ZXJQb3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgICAgICB3aGlsZSAoKCBjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcC5sZW5ndGggPiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IERJTEFURSA9IDE7XG5leHBvcnQgY29uc3QgRVJPREUgPSAyO1xuXG5leHBvcnQgZnVuY3Rpb24gZGlsYXRlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICB2YXIgdixcbiAgICAgICAgdSxcbiAgICAgICAgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55LFxuICAgICAgICB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgc3VtLFxuICAgICAgICB5U3RhcnQxLFxuICAgICAgICB5U3RhcnQyLFxuICAgICAgICB4U3RhcnQxLFxuICAgICAgICB4U3RhcnQyO1xuXG4gICAgZm9yICggdiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcbiAgICAgICAgZm9yICggdSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXSArXG4gICAgICAgICAgICBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XSArXG4gICAgICAgICAgICBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID4gMCA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICB2YXIgdixcbiAgICAgICAgdSxcbiAgICAgICAgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55LFxuICAgICAgICB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgc3VtLFxuICAgICAgICB5U3RhcnQxLFxuICAgICAgICB5U3RhcnQyLFxuICAgICAgICB4U3RhcnQxLFxuICAgICAgICB4U3RhcnQyO1xuXG4gICAgZm9yICggdiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcbiAgICAgICAgZm9yICggdSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXSArXG4gICAgICAgICAgICBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XSArXG4gICAgICAgICAgICBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID09PSA1ID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlV3JhcHBlciwgYkltYWdlV3JhcHBlciwgcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFJbWFnZVdyYXBwZXIuZGF0YS5sZW5ndGgsXG4gICAgICAgIGFJbWFnZURhdGEgPSBhSW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gYUltYWdlV3JhcHBlci5kYXRhLmxlbmd0aCxcbiAgICAgICAgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVdyYXBwZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gaW1hZ2VXcmFwcGVyLmRhdGEubGVuZ3RoLCBkYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGEsIHN1bSA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0b3BHZW5lcmljKGxpc3QsIHRvcCwgc2NvcmVGdW5jKSB7XG4gICAgdmFyIGksIG1pbklkeCA9IDAsIG1pbiA9IDAsIHF1ZXVlID0gW10sIHNjb3JlLCBoaXQsIHBvcztcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0gPSB7XG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGl0ZW06IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICAgICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yICggcG9zID0gMDsgcG9zIDwgdG9wOyBwb3MrKykge1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtwb3NdLnNjb3JlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHF1ZXVlW3Bvc10uc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIG1pbklkeCA9IHBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgY3R4LCBhcnJheSkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpO1xuICAgIHZhciBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21Db250ZXh0KGN0eCwgc2l6ZSwgb2Zmc2V0LCBhcnJheSkge1xuICAgIHZhciBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksIHNpemUueCwgc2l6ZS55KS5kYXRhO1xuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gICAgdmFyIHRvcFJvd0lkeCA9IDA7XG4gICAgdmFyIGJvdHRvbVJvd0lkeCA9IHNpemUueDtcbiAgICB2YXIgZW5kSWR4ID0gTWF0aC5mbG9vcihjYW52YXNEYXRhLmxlbmd0aCAvIDQpO1xuICAgIHZhciBvdXRXaWR0aCA9IHNpemUueCAvIDI7XG4gICAgdmFyIG91dEltZ0lkeCA9IDA7XG4gICAgdmFyIGluV2lkdGggPSBzaXplLng7XG4gICAgdmFyIGk7XG5cbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW1nSWR4XSA9IChcbiAgICAgICAgICAgICAgICAoMC4yOTkgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAwXSArXG4gICAgICAgICAgICAgICAgIDAuNTg3ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMV0gK1xuICAgICAgICAgICAgICAgICAwLjExNCAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDJdKSArXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMF0gK1xuICAgICAgICAgICAgICAgICAwLjU4NyAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDFdICtcbiAgICAgICAgICAgICAgICAgMC4xMTQgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAyXSkgK1xuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMF0gK1xuICAgICAgICAgICAgICAgICAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMV0gK1xuICAgICAgICAgICAgICAgICAwLjExNCAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCkgKiA0ICsgMl0pICtcbiAgICAgICAgICAgICAgICAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAwXSArXG4gICAgICAgICAgICAgICAgIDAuNTg3ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMV0gK1xuICAgICAgICAgICAgICAgICAwLjExNCAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDJdKSkgLyA0O1xuICAgICAgICAgICAgb3V0SW1nSWR4Kys7XG4gICAgICAgICAgICB0b3BSb3dJZHggPSB0b3BSb3dJZHggKyAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ID0gYm90dG9tUm93SWR4ICsgMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggPSB0b3BSb3dJZHggKyBpbldpZHRoO1xuICAgICAgICBib3R0b21Sb3dJZHggPSBib3R0b21Sb3dJZHggKyBpbldpZHRoO1xuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlR3JheShpbWFnZURhdGEsIG91dEFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwLFxuICAgICAgICBpLFxuICAgICAgICBzaW5nbGVDaGFubmVsID0gY29uZmlnICYmIGNvbmZpZy5zaW5nbGVDaGFubmVsID09PSB0cnVlO1xuXG4gICAgaWYgKHNpbmdsZUNoYW5uZWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSBpbWFnZURhdGFbaSAqIDQgKyAwXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG91dEFycmF5W2ldID1cbiAgICAgICAgICAgICAgICAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEltYWdlQXJyYXkoc3JjLCBjYWxsYmFjaywgY2FudmFzKSB7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfVxuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICB2YXIgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLmRhdGE7XG4gICAgICAgIGNvbXB1dGVHcmF5KGRhdGEsIGFycmF5KTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhhcnJheSwge1xuICAgICAgICAgICAgeDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIHk6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgaW1nLnNyYyA9IHNyYztcbn07XG5cbi8qKlxuICogQHBhcmFtIGluSW1nIHtJbWFnZVdyYXBwZXJ9IGlucHV0IGltYWdlIHRvIGJlIHNhbXBsZWRcbiAqIEBwYXJhbSBvdXRJbWcge0ltYWdlV3JhcHBlcn0gdG8gYmUgc3RvcmVkIGluXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYWxmU2FtcGxlKGluSW1nV3JhcHBlciwgb3V0SW1nV3JhcHBlcikge1xuICAgIHZhciBpbkltZyA9IGluSW1nV3JhcHBlci5kYXRhO1xuICAgIHZhciBpbldpZHRoID0gaW5JbWdXcmFwcGVyLnNpemUueDtcbiAgICB2YXIgb3V0SW1nID0gb3V0SW1nV3JhcHBlci5kYXRhO1xuICAgIHZhciB0b3BSb3dJZHggPSAwO1xuICAgIHZhciBib3R0b21Sb3dJZHggPSBpbldpZHRoO1xuICAgIHZhciBlbmRJZHggPSBpbkltZy5sZW5ndGg7XG4gICAgdmFyIG91dFdpZHRoID0gaW5XaWR0aCAvIDI7XG4gICAgdmFyIG91dEltZ0lkeCA9IDA7XG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIG91dEltZ1tvdXRJbWdJZHhdID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAoaW5JbWdbdG9wUm93SWR4XSArIGluSW1nW3RvcFJvd0lkeCArIDFdICsgaW5JbWdbYm90dG9tUm93SWR4XSArIGluSW1nW2JvdHRvbVJvd0lkeCArIDFdKSAvIDQpO1xuICAgICAgICAgICAgb3V0SW1nSWR4Kys7XG4gICAgICAgICAgICB0b3BSb3dJZHggPSB0b3BSb3dJZHggKyAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ID0gYm90dG9tUm93SWR4ICsgMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggPSB0b3BSb3dJZHggKyBpbldpZHRoO1xuICAgICAgICBib3R0b21Sb3dJZHggPSBib3R0b21Sb3dJZHggKyBpbldpZHRoO1xuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBoc3YycmdiKGhzdiwgcmdiKSB7XG4gICAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICAgIHMgPSBoc3ZbMV0sXG4gICAgICAgIHYgPSBoc3ZbMl0sXG4gICAgICAgIGMgPSB2ICogcyxcbiAgICAgICAgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKSxcbiAgICAgICAgbSA9IHYgLSBjLFxuICAgICAgICByID0gMCxcbiAgICAgICAgZyA9IDAsXG4gICAgICAgIGIgPSAwO1xuXG4gICAgcmdiID0gcmdiIHx8IFswLCAwLCAwXTtcblxuICAgIGlmIChoIDwgNjApIHtcbiAgICAgICAgciA9IGM7XG4gICAgICAgIGcgPSB4O1xuICAgIH0gZWxzZSBpZiAoaCA8IDEyMCkge1xuICAgICAgICByID0geDtcbiAgICAgICAgZyA9IGM7XG4gICAgfSBlbHNlIGlmIChoIDwgMTgwKSB7XG4gICAgICAgIGcgPSBjO1xuICAgICAgICBiID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAyNDApIHtcbiAgICAgICAgZyA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDMwMCkge1xuICAgICAgICByID0geDtcbiAgICAgICAgYiA9IGM7XG4gICAgfSBlbHNlIGlmIChoIDwgMzYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBiID0geDtcbiAgICB9XG4gICAgcmdiWzBdID0gKChyICsgbSkgKiAyNTUpIHwgMDtcbiAgICByZ2JbMV0gPSAoKGcgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJnYlsyXSA9ICgoYiArIG0pICogMjU1KSB8IDA7XG4gICAgcmV0dXJuIHJnYjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgICB2YXIgbGFyZ2VEaXZpc29ycyA9IFtdLFxuICAgICAgICBkaXZpc29ycyA9IFtdLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IE1hdGguc3FydChuKSArIDE7IGkrKykge1xuICAgICAgICBpZiAobiAlIGkgPT09IDApIHtcbiAgICAgICAgICAgIGRpdmlzb3JzLnB1c2goaSk7XG4gICAgICAgICAgICBpZiAoaSAhPT0gbiAvIGkpIHtcbiAgICAgICAgICAgICAgICBsYXJnZURpdmlzb3JzLnVuc2hpZnQoTWF0aC5mbG9vcihuIC8gaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXZpc29ycy5jb25jYXQobGFyZ2VEaXZpc29ycyk7XG59O1xuXG5mdW5jdGlvbiBfY29tcHV0ZUludGVyc2VjdGlvbihhcnIxLCBhcnIyKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGFycjEubGVuZ3RoICYmIGogPCBhcnIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBhdGNoU2l6ZShwYXRjaFNpemUsIGltZ1NpemUpIHtcbiAgICB2YXIgZGl2aXNvcnNYID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLngpLFxuICAgICAgICBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSksXG4gICAgICAgIHdpZGVTaWRlID0gTWF0aC5tYXgoaW1nU2l6ZS54LCBpbWdTaXplLnkpLFxuICAgICAgICBjb21tb24gPSBfY29tcHV0ZUludGVyc2VjdGlvbihkaXZpc29yc1gsIGRpdmlzb3JzWSksXG4gICAgICAgIG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXSxcbiAgICAgICAgbnJPZlBhdGNoZXNNYXAgPSB7XG4gICAgICAgICAgICBcIngtc21hbGxcIjogNSxcbiAgICAgICAgICAgIFwic21hbGxcIjogNCxcbiAgICAgICAgICAgIFwibWVkaXVtXCI6IDMsXG4gICAgICAgICAgICBcImxhcmdlXCI6IDIsXG4gICAgICAgICAgICBcIngtbGFyZ2VcIjogMVxuICAgICAgICB9LFxuICAgICAgICBuck9mUGF0Y2hlc0lkeCA9IG5yT2ZQYXRjaGVzTWFwW3BhdGNoU2l6ZV0gfHwgbnJPZlBhdGNoZXNNYXAubWVkaXVtLFxuICAgICAgICBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0sXG4gICAgICAgIGRlc2lyZWRQYXRjaFNpemUgPSBNYXRoLmZsb29yKHdpZGVTaWRlIC8gbnJPZlBhdGNoZXMpLFxuICAgICAgICBvcHRpbWFsUGF0Y2hTaXplO1xuXG4gICAgZnVuY3Rpb24gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGRpdmlzb3JzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbTWF0aC5mbG9vcihkaXZpc29ycy5sZW5ndGggLyAyKV07XG5cbiAgICAgICAgd2hpbGUgKGkgPCAoZGl2aXNvcnMubGVuZ3RoIC0gMSkgJiYgZGl2aXNvcnNbaV0gPCBkZXNpcmVkUGF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGl2aXNvcnNbaV0gLSBkZXNpcmVkUGF0Y2hTaXplKSA+IE1hdGguYWJzKGRpdmlzb3JzW2kgLSAxXSAtIGRlc2lyZWRQYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA8IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCArIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XSAmJlxuICAgICAgICAgICAgZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kID4gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4IC0gMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdICkge1xuICAgICAgICAgICAgcmV0dXJuIHt4OiBmb3VuZCwgeTogZm91bmR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycygoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKSB7XG4gICAgdmFyIGRpbWVuc2lvbiA9IHtcbiAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpLFxuICAgICAgICB1bml0OiB2YWx1ZS5pbmRleE9mKFwiJVwiKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSA/IFwiJVwiIDogXCIlXCJcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbn07XG5cbmV4cG9ydCBjb25zdCBfZGltZW5zaW9uc0NvbnZlcnRlcnMgPSB7XG4gICAgdG9wOiBmdW5jdGlvbihkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbi51bml0ID09PSBcIiVcIikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbihkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbi51bml0ID09PSBcIiVcIikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYm90dG9tOiBmdW5jdGlvbihkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbi51bml0ID09PSBcIiVcIikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY29udGV4dC5oZWlnaHQgLSAoY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsZWZ0OiBmdW5jdGlvbihkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbi51bml0ID09PSBcIiVcIikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW1hZ2VBcmVhKGlucHV0V2lkdGgsIGlucHV0SGVpZ2h0LCBhcmVhKSB7XG4gICAgdmFyIGNvbnRleHQgPSB7d2lkdGg6IGlucHV0V2lkdGgsIGhlaWdodDogaW5wdXRIZWlnaHR9O1xuXG4gICAgdmFyIHBhcnNlZEFyZWEgPSBPYmplY3Qua2V5cyhhcmVhKS5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0LCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJlYVtrZXldLFxuICAgICAgICAgICAgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKSxcbiAgICAgICAgICAgIGNhbGN1bGF0ZWQgPSBfZGltZW5zaW9uc0NvbnZlcnRlcnNba2V5XShwYXJzZWQsIGNvbnRleHQpO1xuXG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsY3VsYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzeTogcGFyc2VkQXJlYS50b3AsXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcFxuICAgIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9jdl91dGlscy5qcyIsImltcG9ydCBTdWJJbWFnZSBmcm9tICcuL3N1YkltYWdlJztcbmltcG9ydCB7aHN2MnJnYn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmNvbnN0IHZlYzIgPSB7XG4gICAgY2xvbmU6IHJlcXVpcmUoJ2dsLXZlYzIvY2xvbmUnKSxcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGJhc2ljIGltYWdlIGNvbWJpbmluZyB0aGUgZGF0YSBhbmQgc2l6ZS5cbiAqIEluIGFkZGl0aW9uLCBzb21lIG1ldGhvZHMgZm9yIG1hbmlwdWxhdGlvbiBhcmUgY29udGFpbmVkLlxuICogQHBhcmFtIHNpemUge3gseX0gVGhlIHNpemUgb2YgdGhlIGltYWdlIGluIHBpeGVsXG4gKiBAcGFyYW0gZGF0YSB7QXJyYXl9IElmIGdpdmVuLCBhIGZsYXQgYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YVxuICogQHBhcmFtIEFycmF5VHlwZSB7VHlwZX0gSWYgZ2l2ZW4sIHRoZSBkZXNpcmVkIERhdGFUeXBlIG9mIHRoZSBBcnJheSAobWF5IGJlIHR5cGVkL25vbi10eXBlZClcbiAqIEBwYXJhbSBpbml0aWFsaXplIHtCb29sZWFufSBJbmRpY2F0aW5nIGlmIHRoZSBhcnJheSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgb24gY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7SW1hZ2VXcmFwcGVyfVxuICovXG5mdW5jdGlvbiBJbWFnZVdyYXBwZXIoc2l6ZSwgZGF0YSwgQXJyYXlUeXBlLCBpbml0aWFsaXplKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGlmIChBcnJheVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheVR5cGUoc2l6ZS54ICogc2l6ZS55KTtcbiAgICAgICAgICAgIGlmIChBcnJheVR5cGUgPT09IEFycmF5ICYmIGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKFVpbnQ4QXJyYXkgPT09IEFycmF5ICYmIGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICB0aGlzLnNpemUgPSBzaXplO1xufVxuXG4vKipcbiAqIHRlc3RzIGlmIGEgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbWFnZSB3aXRoIGEgZ2l2ZW4gb2Zmc2V0XG4gKiBAcGFyYW0gaW1nUmVmIHt4LCB5fSBUaGUgbG9jYXRpb24gdG8gdGVzdFxuICogQHBhcmFtIGJvcmRlciBOdW1iZXIgdGhlIHBhZGRpbmcgdmFsdWUgaW4gcGl4ZWxcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGxvY2F0aW9uIGluc2lkZSB0aGUgaW1hZ2UncyBib3JkZXIsIGZhbHNlIG90aGVyd2lzZVxuICogQHNlZSBjdmQvaW1hZ2UuaFxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLmluSW1hZ2VXaXRoQm9yZGVyID0gZnVuY3Rpb24oaW1nUmVmLCBib3JkZXIpIHtcbiAgICByZXR1cm4gKGltZ1JlZi54ID49IGJvcmRlcilcbiAgICAgICAgJiYgKGltZ1JlZi55ID49IGJvcmRlcilcbiAgICAgICAgJiYgKGltZ1JlZi54IDwgKHRoaXMuc2l6ZS54IC0gYm9yZGVyKSlcbiAgICAgICAgJiYgKGltZ1JlZi55IDwgKHRoaXMuc2l6ZS55IC0gYm9yZGVyKSk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGJpbGluZWFyIHNhbXBsaW5nXG4gKiBAcGFyYW0gaW5JbWcgSW1hZ2UgdG8gZXh0cmFjdCBzYW1wbGUgZnJvbVxuICogQHBhcmFtIHggdGhlIHgtY29vcmRpbmF0ZVxuICogQHBhcmFtIHkgdGhlIHktY29vcmRpbmF0ZVxuICogQHJldHVybnMgdGhlIHNhbXBsZWQgdmFsdWVcbiAqIEBzZWUgY3ZkL3Zpc2lvbi5oXG4gKi9cbkltYWdlV3JhcHBlci5zYW1wbGUgPSBmdW5jdGlvbihpbkltZywgeCwgeSkge1xuICAgIHZhciBseCA9IE1hdGguZmxvb3IoeCk7XG4gICAgdmFyIGx5ID0gTWF0aC5mbG9vcih5KTtcbiAgICB2YXIgdyA9IGluSW1nLnNpemUueDtcbiAgICB2YXIgYmFzZSA9IGx5ICogaW5JbWcuc2l6ZS54ICsgbHg7XG4gICAgdmFyIGEgPSBpbkltZy5kYXRhW2Jhc2UgKyAwXTtcbiAgICB2YXIgYiA9IGluSW1nLmRhdGFbYmFzZSArIDFdO1xuICAgIHZhciBjID0gaW5JbWcuZGF0YVtiYXNlICsgd107XG4gICAgdmFyIGQgPSBpbkltZy5kYXRhW2Jhc2UgKyB3ICsgMV07XG4gICAgdmFyIGUgPSBhIC0gYjtcbiAgICB4IC09IGx4O1xuICAgIHkgLT0gbHk7XG5cbiAgICB2YXIgcmVzdWx0ID0gTWF0aC5mbG9vcih4ICogKHkgKiAoZSAtIGMgKyBkKSAtIGUpICsgeSAqIChjIC0gYSkgKyBhKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGdpdmVuIGFycmF5LiBTZXRzIGVhY2ggZWxlbWVudCB0byB6ZXJvLlxuICogQHBhcmFtIGFycmF5IHtBcnJheX0gVGhlIGFycmF5IHRvIGluaXRpYWxpemVcbiAqL1xuSW1hZ2VXcmFwcGVyLmNsZWFyQXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgYXJyYXlbbF0gPSAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtTdWJJbWFnZX0gZnJvbSB0aGUgY3VycmVudCBpbWFnZSAoe3RoaXN9KS5cbiAqIEBwYXJhbSBmcm9tIHtJbWFnZVJlZn0gVGhlIHBvc2l0aW9uIHdoZXJlIHRvIHN0YXJ0IHRoZSB7U3ViSW1hZ2V9IGZyb20uICh0b3AtbGVmdCBjb3JuZXIpXG4gKiBAcGFyYW0gc2l6ZSB7SW1hZ2VSZWZ9IFRoZSBzaXplIG9mIHRoZSByZXN1bHRpbmcgaW1hZ2VcbiAqIEByZXR1cm5zIHtTdWJJbWFnZX0gQSBzaGFyZWQgcGFydCBvZiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5zdWJJbWFnZSA9IGZ1bmN0aW9uKGZyb20sIHNpemUpIHtcbiAgICByZXR1cm4gbmV3IFN1YkltYWdlKGZyb20sIHNpemUsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIHtJbWFnZVdyYXBwZXIpIGFuZCBjb3BpZXMgdGhlIG5lZWRlZCB1bmRlcmx5aW5nIGltYWdlLWRhdGEgYXJlYVxuICogQHBhcmFtIGltYWdlV3JhcHBlciB7SW1hZ2VXcmFwcGVyfSBUaGUgdGFyZ2V0IHtJbWFnZVdyYXBwZXJ9IHdoZXJlIHRoZSBkYXRhIHNob3VsZCBiZSBjb3BpZWRcbiAqIEBwYXJhbSBmcm9tIHtJbWFnZVJlZn0gVGhlIGxvY2F0aW9uIHdoZXJlIHRvIGNvcHkgZnJvbSAodG9wLWxlZnQgbG9jYXRpb24pXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuc3ViSW1hZ2VBc0NvcHkgPSBmdW5jdGlvbihpbWFnZVdyYXBwZXIsIGZyb20pIHtcbiAgICB2YXIgc2l6ZVkgPSBpbWFnZVdyYXBwZXIuc2l6ZS55LCBzaXplWCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgdmFyIHgsIHk7XG4gICAgZm9yICggeCA9IDA7IHggPCBzaXplWDsgeCsrKSB7XG4gICAgICAgIGZvciAoIHkgPSAwOyB5IDwgc2l6ZVk7IHkrKykge1xuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGFbeSAqIHNpemVYICsgeF0gPSB0aGlzLmRhdGFbKGZyb20ueSArIHkpICogdGhpcy5zaXplLnggKyBmcm9tLnggKyB4XTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuY29weVRvID0gZnVuY3Rpb24oaW1hZ2VXcmFwcGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGgsIHNyY0RhdGEgPSB0aGlzLmRhdGEsIGRzdERhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBkc3REYXRhW2xlbmd0aF0gPSBzcmNEYXRhW2xlbmd0aF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBmcm9tIHRoZSBpbWFnZVxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIHgtcG9zaXRpb25cbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSB5LXBvc2l0aW9uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBwaXhlbC1wb3NpdGlvblxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBmcm9tIHRoZSBpbWFnZVxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIHgtcG9zaXRpb25cbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSB5LXBvc2l0aW9uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBwaXhlbC1wb3NpdGlvblxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLmdldFNhZmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIXRoaXMuaW5kZXhNYXBwaW5nKSB7XG4gICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nID0ge1xuICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICB5OiBbXVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zaXplLng7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpXSA9IGk7XG4gICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2kgKyB0aGlzLnNpemUueF0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNpemUueTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2ldID0gaTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaSArIHRoaXMuc2l6ZS55XSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldKSAqIHRoaXMuc2l6ZS54ICsgdGhpcy5pbmRleE1hcHBpbmcueFt4ICsgdGhpcy5zaXplLnhdXTtcbn07XG5cbi8qKlxuICogU2V0cyBhIGdpdmVuIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBpbWFnZVxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIHgtcG9zaXRpb25cbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSB5LXBvc2l0aW9uXG4gKiBAcGFyYW0gdmFsdWUge051bWJlcn0gVGhlIGdyYXlzY2FsZSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm5zIHtJbWFnZVdyYXBwZXJ9IFRoZSBJbWFnZSBpdHNlbGYgKGZvciBwb3NzaWJsZSBjaGFpbmluZylcbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBib3JkZXIgb2YgdGhlIGltYWdlICgxIHBpeGVsKSB0byB6ZXJvXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuemVyb0JvcmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLCB3aWR0aCA9IHRoaXMuc2l6ZS54LCBoZWlnaHQgPSB0aGlzLnNpemUueSwgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBmb3IgKCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IGRhdGFbKGhlaWdodCAtIDEpICogd2lkdGggKyBpXSA9IDA7XG4gICAgfVxuICAgIGZvciAoIGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICAgIGRhdGFbaSAqIHdpZHRoXSA9IGRhdGFbaSAqIHdpZHRoICsgKHdpZHRoIC0gMSldID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBiaW5hcnkgaW1hZ2UgaW4gcGxhY2VcbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSwgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgZGF0YVtsZW5ndGhdID0gZGF0YVtsZW5ndGhdID8gMCA6IDE7XG4gICAgfVxufTtcblxuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5jb252b2x2ZSA9IGZ1bmN0aW9uKGtlcm5lbCkge1xuICAgIHZhciB4LCB5LCBreCwga3ksIGtTaXplID0gKGtlcm5lbC5sZW5ndGggLyAyKSB8IDAsIGFjY3UgPSAwO1xuICAgIGZvciAoIHkgPSAwOyB5IDwgdGhpcy5zaXplLnk7IHkrKykge1xuICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHRoaXMuc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgIGFjY3UgPSAwO1xuICAgICAgICAgICAgZm9yICgga3kgPSAta1NpemU7IGt5IDw9IGtTaXplOyBreSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICgga3ggPSAta1NpemU7IGt4IDw9IGtTaXplOyBreCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3UgKz0ga2VybmVsW2t5ICsga1NpemVdW2t4ICsga1NpemVdICogdGhpcy5nZXRTYWZlKHggKyBreCwgeSArIGt5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF0gPSBhY2N1O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5tb21lbnRzID0gZnVuY3Rpb24obGFiZWxjb3VudCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBoZWlnaHQgPSB0aGlzLnNpemUueSxcbiAgICAgICAgd2lkdGggPSB0aGlzLnNpemUueCxcbiAgICAgICAgdmFsLFxuICAgICAgICB5c3EsXG4gICAgICAgIGxhYmVsc3VtID0gW10sXG4gICAgICAgIGksXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBtdTExLFxuICAgICAgICBtdTAyLFxuICAgICAgICBtdTIwLFxuICAgICAgICB4XyxcbiAgICAgICAgeV8sXG4gICAgICAgIHRtcCxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIFBJID0gTWF0aC5QSSxcbiAgICAgICAgUElfNCA9IFBJIC8gNDtcblxuICAgIGlmIChsYWJlbGNvdW50IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGxhYmVsY291bnQ7IGkrKykge1xuICAgICAgICBsYWJlbHN1bVtpXSA9IHtcbiAgICAgICAgICAgIG0wMDogMCxcbiAgICAgICAgICAgIG0wMTogMCxcbiAgICAgICAgICAgIG0xMDogMCxcbiAgICAgICAgICAgIG0xMTogMCxcbiAgICAgICAgICAgIG0wMjogMCxcbiAgICAgICAgICAgIG0yMDogMCxcbiAgICAgICAgICAgIHRoZXRhOiAwLFxuICAgICAgICAgICAgcmFkOiAwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yICggeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICB5c3EgPSB5ICogeTtcbiAgICAgICAgZm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICB2YWwgPSBkYXRhW3kgKiB3aWR0aCArIHhdO1xuICAgICAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsc3VtW3ZhbCAtIDFdO1xuICAgICAgICAgICAgICAgIGxhYmVsLm0wMCArPSAxO1xuICAgICAgICAgICAgICAgIGxhYmVsLm0wMSArPSB5O1xuICAgICAgICAgICAgICAgIGxhYmVsLm0xMCArPSB4O1xuICAgICAgICAgICAgICAgIGxhYmVsLm0xMSArPSB4ICogeTtcbiAgICAgICAgICAgICAgICBsYWJlbC5tMDIgKz0geXNxO1xuICAgICAgICAgICAgICAgIGxhYmVsLm0yMCArPSB4ICogeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoIGkgPSAwOyBpIDwgbGFiZWxjb3VudDsgaSsrKSB7XG4gICAgICAgIGxhYmVsID0gbGFiZWxzdW1baV07XG4gICAgICAgIGlmICghaXNOYU4obGFiZWwubTAwKSAmJiBsYWJlbC5tMDAgIT09IDApIHtcbiAgICAgICAgICAgIHhfID0gbGFiZWwubTEwIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgeV8gPSBsYWJlbC5tMDEgLyBsYWJlbC5tMDA7XG4gICAgICAgICAgICBtdTExID0gbGFiZWwubTExIC8gbGFiZWwubTAwIC0geF8gKiB5XztcbiAgICAgICAgICAgIG11MDIgPSBsYWJlbC5tMDIgLyBsYWJlbC5tMDAgLSB5XyAqIHlfO1xuICAgICAgICAgICAgbXUyMCA9IGxhYmVsLm0yMCAvIGxhYmVsLm0wMCAtIHhfICogeF87XG4gICAgICAgICAgICB0bXAgPSAobXUwMiAtIG11MjApIC8gKDIgKiBtdTExKTtcbiAgICAgICAgICAgIHRtcCA9IDAuNSAqIE1hdGguYXRhbih0bXApICsgKG11MTEgPj0gMCA/IFBJXzQgOiAtUElfNCApICsgUEk7XG4gICAgICAgICAgICBsYWJlbC50aGV0YSA9ICh0bXAgKiAxODAgLyBQSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgICAgICAgICAgaWYgKGxhYmVsLnRoZXRhIDwgMCkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhICs9IDE4MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhYmVsLnJhZCA9IHRtcCA+IFBJID8gdG1wIC0gUEkgOiB0bXA7XG4gICAgICAgICAgICBsYWJlbC52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUge0ltYWdlV3JhcHBlcn0gaW4gYSBnaXZlbiBjYW52YXNcbiAqIEBwYXJhbSBjYW52YXMge0NhbnZhc30gVGhlIGNhbnZhcyBlbGVtZW50IHRvIHdyaXRlIHRvXG4gKiBAcGFyYW0gc2NhbGUge051bWJlcn0gU2NhbGUgd2hpY2ggaXMgYXBwbGllZCB0byBlYWNoIHBpeGVsLXZhbHVlXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKGNhbnZhcywgc2NhbGUpIHtcbiAgICB2YXIgY3R4LFxuICAgICAgICBmcmFtZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgcGl4ZWwsXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBpZiAoIXNjYWxlKSB7XG4gICAgICAgIHNjYWxlID0gMS4wO1xuICAgIH1cbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMud2lkdGggPSB0aGlzLnNpemUueDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgZGF0YSA9IGZyYW1lLmRhdGE7XG4gICAgY3VycmVudCA9IDA7XG4gICAgZm9yICh5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHRoaXMuc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgIHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldCh4LCB5KSAqIHNjYWxlO1xuICAgICAgICAgICAgZGF0YVtwaXhlbCAqIDQgKyAwXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBkYXRhW3BpeGVsICogNCArIDFdID0gY3VycmVudDtcbiAgICAgICAgICAgIGRhdGFbcGl4ZWwgKiA0ICsgMl0gPSBjdXJyZW50O1xuICAgICAgICAgICAgZGF0YVtwaXhlbCAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2ZyYW1lLmRhdGEgPSBkYXRhO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoZnJhbWUsIDAsIDApO1xufTtcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUge1N1YkltYWdlfSBpbiBhIGdpdmVuIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB7Q2FudmFzfSBUaGUgY2FudmFzIGVsZW1lbnQgdG8gd3JpdGUgdG9cbiAqIEBwYXJhbSBzY2FsZSB7TnVtYmVyfSBTY2FsZSB3aGljaCBpcyBhcHBsaWVkIHRvIGVhY2ggcGl4ZWwtdmFsdWVcbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5vdmVybGF5ID0gZnVuY3Rpb24oY2FudmFzLCBzY2FsZSwgZnJvbSkge1xuICAgIGlmICghc2NhbGUgfHwgc2NhbGUgPCAwIHx8IHNjYWxlID4gMzYwKSB7XG4gICAgICAgIHNjYWxlID0gMzYwO1xuICAgIH1cbiAgICB2YXIgaHN2ID0gWzAsIDEsIDFdO1xuICAgIHZhciByZ2IgPSBbMCwgMCwgMF07XG4gICAgdmFyIHdoaXRlUmdiID0gWzI1NSwgMjU1LCAyNTVdO1xuICAgIHZhciBibGFja1JnYiA9IFswLCAwLCAwXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoZnJvbS54LCBmcm9tLnksIHRoaXMuc2l6ZS54LCB0aGlzLnNpemUueSk7XG4gICAgdmFyIGRhdGEgPSBmcmFtZS5kYXRhO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIHNjYWxlO1xuICAgICAgICByZXN1bHQgPSBoc3ZbMF0gPD0gMCA/IHdoaXRlUmdiIDogaHN2WzBdID49IDM2MCA/IGJsYWNrUmdiIDogaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgIGRhdGFbbGVuZ3RoICogNCArIDBdID0gcmVzdWx0WzBdO1xuICAgICAgICBkYXRhW2xlbmd0aCAqIDQgKyAxXSA9IHJlc3VsdFsxXTtcbiAgICAgICAgZGF0YVtsZW5ndGggKiA0ICsgMl0gPSByZXN1bHRbMl07XG4gICAgICAgIGRhdGFbbGVuZ3RoICogNCArIDNdID0gMjU1O1xuICAgIH1cbiAgICBjdHgucHV0SW1hZ2VEYXRhKGZyYW1lLCBmcm9tLngsIGZyb20ueSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVdyYXBwZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL2ltYWdlX3dyYXBwZXIuanMiLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXROYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL190b0tleS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzQXJyYXlMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzTGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvbWVyZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbnZhciBUcmFjZXIgPSB7XG4gICAgc2VhcmNoRGlyZWN0aW9uczogW1swLCAxXSwgWzEsIDFdLCBbMSwgMF0sIFsxLCAtMV0sIFswLCAtMV0sIFstMSwgLTFdLCBbLTEsIDBdLCBbLTEsIDFdXSxcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhLFxuICAgICAgICAgICAgc2VhcmNoRGlyZWN0aW9ucyA9IHRoaXMuc2VhcmNoRGlyZWN0aW9ucyxcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgICAgIHBvcztcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB4O1xuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LmN5ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMF07XG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQuY3ggKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBwb3MgPSB5ICogd2lkdGggKyB4O1xuICAgICAgICAgICAgICAgIGlmICgoaW1hZ2VEYXRhW3Bvc10gPT09IGNvbG9yKSAmJiAoKGxhYmVsRGF0YVtwb3NdID09PSAwKSB8fCAobGFiZWxEYXRhW3Bvc10gPT09IGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gZWRnZWxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgMSkgJSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZlcnRleDJEKHgsIHksIGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXI6IGRpcixcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmV2OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgdmFyIEZ2ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBDdixcbiAgICAgICAgICAgICAgICBQLFxuICAgICAgICAgICAgICAgIGxkaXIsXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3g6IHN4LFxuICAgICAgICAgICAgICAgICAgICBjeTogc3ksXG4gICAgICAgICAgICAgICAgICAgIGRpcjogMFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICBGdiA9IHZlcnRleDJEKHN4LCBzeSwgY3VycmVudC5kaXIpO1xuICAgICAgICAgICAgICAgIEN2ID0gRnY7XG4gICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgICAgICBQLnByZXYgPSBDdjtcbiAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIEN2ID0gUDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgNikgJSA4O1xuICAgICAgICAgICAgICAgICAgICB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZGlyICE9PSBjdXJyZW50LmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBQLnByZXYgPSBDdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGxkaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi54ID0gY3VycmVudC5jeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnkgPSBjdXJyZW50LmN5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50LmN4ICE9PSBzeCB8fCBjdXJyZW50LmN5ICE9PSBzeSk7XG4gICAgICAgICAgICAgICAgRnYucHJldiA9IEN2LnByZXY7XG4gICAgICAgICAgICAgICAgQ3YucHJldi5uZXh0ID0gRnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRnY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhY2U6IGZ1bmN0aW9uKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250b3VyVHJhY2luZzogZnVuY3Rpb24oc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoVHJhY2VyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2NhdG9yL3RyYWNlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5mdW5jdGlvbiBDb2RlMzlSZWFkZXIoKSB7XG4gICAgQmFyY29kZVJlYWRlci5jYWxsKHRoaXMpO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBBTFBIQUJFVEhfU1RSSU5HOiB7dmFsdWU6IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gKiQvKyVcIn0sXG4gICAgQUxQSEFCRVQ6IHt2YWx1ZTogWzQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA2NSwgNjYsIDY3LCA2OCwgNjksIDcwLCA3MSwgNzIsIDczLCA3NCwgNzUsIDc2LCA3NywgNzgsXG4gICAgICAgIDc5LCA4MCwgODEsIDgyLCA4MywgODQsIDg1LCA4NiwgODcsIDg4LCA4OSwgOTAsIDQ1LCA0NiwgMzIsIDQyLCAzNiwgNDcsIDQzLCAzN119LFxuICAgIENIQVJBQ1RFUl9FTkNPRElOR1M6IHt2YWx1ZTogWzB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LCAweDEwOSwgMHgwNDksXG4gICAgICAgIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQywgMHgxMDMsIDB4MDQzLCAweDE0MiwgMHgwMTMsIDB4MTEyLCAweDA1MiwgMHgwMDcsIDB4MTA2LFxuICAgICAgICAweDA0NiwgMHgwMTYsIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MDk0LCAweDBBOCwgMHgwQTIsIDB4MDhBLCAweDAyQVxuICAgIF19LFxuICAgIEFTVEVSSVNLOiB7dmFsdWU6IDB4MDk0fSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJjb2RlXzM5XCIsIHdyaXRlYWJsZTogZmFsc2V9XG59O1xuXG5Db2RlMzlSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXJjb2RlUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5Db2RlMzlSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29kZTM5UmVhZGVyO1xuXG5Db2RlMzlSZWFkZXIucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvdW50ZXJzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgc3RhcnQgPSBzZWxmLl9maW5kU3RhcnQoKSxcbiAgICAgICAgZGVjb2RlZENoYXIsXG4gICAgICAgIGxhc3RTdGFydCxcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgbmV4dFN0YXJ0O1xuXG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbmV4dFN0YXJ0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICBkbyB7XG4gICAgICAgIGNvdW50ZXJzID0gc2VsZi5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKTtcbiAgICAgICAgcGF0dGVybiA9IHNlbGYuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENoYXIgPSBzZWxmLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICBpZiAoZGVjb2RlZENoYXIgPCAwKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3csIG5leHRTdGFydCk7XG4gICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghc2VsZi5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0XG4gICAgfTtcbn07XG5cbkNvZGUzOVJlYWRlci5wcm90b3R5cGUuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykge1xuICAgIHZhciB0cmFpbGluZ1doaXRlc3BhY2VFbmQsXG4gICAgICAgIHBhdHRlcm5TaXplID0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcblxuICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xuICAgIGlmICgodHJhaWxpbmdXaGl0ZXNwYWNlRW5kICogMykgPj0gcGF0dGVyblNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkNvZGUzOVJlYWRlci5wcm90b3R5cGUuX3BhdHRlcm5Ub0NoYXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5DSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmLkFMUEhBQkVUW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5Db2RlMzlSZWFkZXIucHJvdG90eXBlLl9maW5kTmV4dFdpZHRoID0gZnVuY3Rpb24oY291bnRlcnMsIGN1cnJlbnQpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbWluV2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb3VudGVyc1tpXSA8IG1pbldpZHRoICYmIGNvdW50ZXJzW2ldID4gY3VycmVudCkge1xuICAgICAgICAgICAgbWluV2lkdGggPSBjb3VudGVyc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW5XaWR0aDtcbn07XG5cbkNvZGUzOVJlYWRlci5wcm90b3R5cGUuX3RvUGF0dGVybiA9IGZ1bmN0aW9uKGNvdW50ZXJzKSB7XG4gICAgdmFyIG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoLFxuICAgICAgICBtYXhOYXJyb3dXaWR0aCA9IDAsXG4gICAgICAgIG51bVdpZGVCYXJzID0gbnVtQ291bnRlcnMsXG4gICAgICAgIHdpZGVCYXJXaWR0aCA9IDAsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKG51bVdpZGVCYXJzID4gMykge1xuICAgICAgICBtYXhOYXJyb3dXaWR0aCA9IHNlbGYuX2ZpbmROZXh0V2lkdGgoY291bnRlcnMsIG1heE5hcnJvd1dpZHRoKTtcbiAgICAgICAgbnVtV2lkZUJhcnMgPSAwO1xuICAgICAgICBwYXR0ZXJuID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICBudW1XaWRlQmFycysrO1xuICAgICAgICAgICAgICAgIHdpZGVCYXJXaWR0aCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1XaWRlQmFycyA9PT0gMykge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bUNvdW50ZXJzICYmIG51bVdpZGVCYXJzID4gMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudGVyc1tpXSAqIDIpID49IHdpZGVCYXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5fZmluZFN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3JvdyksXG4gICAgICAgIHBhdHRlcm5TdGFydCA9IG9mZnNldCxcbiAgICAgICAgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGlzV2hpdGUgPSBmYWxzZSxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgd2hpdGVTcGFjZU11c3RTdGFydDtcblxuICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBzZWxmLkFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtICgoaSAtIHBhdHRlcm5TdGFydCkgLyA0KSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcls3XSA9IDA7XG4gICAgICAgICAgICAgICAgY291bnRlcls4XSA9IDA7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzOVJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGRvdFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC12ZWMyL2RvdC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX01hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX01hcENhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2ZyZWVHbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fb3ZlclJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zZXRUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaWRlbnRpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNCdWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gva2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBUeXBlRGVmcyBmcm9tICcuL2NvbW1vbi90eXBlZGVmcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vY29tbW9uL2V2ZW50cyc7XG5pbXBvcnQgQ2FtZXJhQWNjZXNzIGZyb20gJy4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmVzdWx0Q29sbGVjdG9yIGZyb20gJy4vYW5hbHl0aWNzL3Jlc3VsdF9jb2xsZWN0b3InO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL2NvbmZpZy9jb25maWcnO1xuaW1wb3J0IElucHV0U3RyZWFtIGZyb20gJ2lucHV0X3N0cmVhbSc7XG5pbXBvcnQgRnJhbWVHcmFiYmVyIGZyb20gJ2ZyYW1lX2dyYWJiZXInO1xuaW1wb3J0IHttZXJnZX0gZnJvbSAnbG9kYXNoJztcbmNvbnN0IHZlYzIgPSB7XG4gICAgY2xvbmU6IHJlcXVpcmUoJ2dsLXZlYzIvY2xvbmUnKVxufTtcblxudmFyIF9pbnB1dFN0cmVhbSxcbiAgICBfZnJhbWVncmFiYmVyLFxuICAgIF9zdG9wcGVkLFxuICAgIF9jYW52YXNDb250YWluZXIgPSB7XG4gICAgICAgIGN0eDoge1xuICAgICAgICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICAgICAgICBvdmVybGF5OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGRvbToge1xuICAgICAgICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICAgICAgICBvdmVybGF5OiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9pbnB1dEltYWdlV3JhcHBlcixcbiAgICBfYm94U2l6ZSxcbiAgICBfZGVjb2RlcixcbiAgICBfd29ya2VyUG9vbCA9IFtdLFxuICAgIF9vblVJVGhyZWFkID0gdHJ1ZSxcbiAgICBfcmVzdWx0Q29sbGVjdG9yLFxuICAgIF9jb25maWcgPSB7fTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyKSB7XG4gICAgaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKTtcbiAgICBfZGVjb2RlciA9IEJhcmNvZGVEZWNvZGVyLmNyZWF0ZShfY29uZmlnLmRlY29kZXIsIF9pbnB1dEltYWdlV3JhcHBlcik7XG59XG5cbmZ1bmN0aW9uIGluaXRJbnB1dFN0cmVhbShjYikge1xuICAgIHZhciB2aWRlbztcbiAgICBpZiAoX2NvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSBcIlZpZGVvU3RyZWFtXCIpIHtcbiAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICAgIF9pbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtLmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTtcbiAgICB9IGVsc2UgaWYgKF9jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gXCJJbWFnZVN0cmVhbVwiKSB7XG4gICAgICAgIF9pbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtLmNyZWF0ZUltYWdlU3RyZWFtKCk7XG4gICAgfSBlbHNlIGlmIChfY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09IFwiTGl2ZVN0cmVhbVwiKSB7XG4gICAgICAgIHZhciAkdmlld3BvcnQgPSBnZXRWaWV3UG9ydCgpO1xuICAgICAgICBpZiAoJHZpZXdwb3J0KSB7XG4gICAgICAgICAgICB2aWRlbyA9ICR2aWV3cG9ydC5xdWVyeVNlbGVjdG9yKFwidmlkZW9cIik7XG4gICAgICAgICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICAgICAgICAgICAgJHZpZXdwb3J0LmFwcGVuZENoaWxkKHZpZGVvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfaW5wdXRTdHJlYW0gPSBJbnB1dFN0cmVhbS5jcmVhdGVMaXZlU3RyZWFtKHZpZGVvKTtcbiAgICAgICAgQ2FtZXJhQWNjZXNzLnJlcXVlc3QodmlkZW8sIF9jb25maWcuaW5wdXRTdHJlYW0uY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIF9pbnB1dFN0cmVhbS50cmlnZ2VyKFwiY2FucmVjb3JkXCIpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2lucHV0U3RyZWFtLnNldEF0dHJpYnV0ZShcInByZWxvYWRcIiwgXCJhdXRvXCIpO1xuICAgIF9pbnB1dFN0cmVhbS5zZXRJbnB1dFN0cmVhbShfY29uZmlnLmlucHV0U3RyZWFtKTtcbiAgICBfaW5wdXRTdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcihcImNhbnJlY29yZFwiLCBjYW5SZWNvcmQuYmluZCh1bmRlZmluZWQsIGNiKSk7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdQb3J0KCkge1xuICAgIHZhciB0YXJnZXQgPSBfY29uZmlnLmlucHV0U3RyZWFtLnRhcmdldDtcbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYWxyZWFkeSBhIERPTSBlbGVtZW50XG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlICcjaW50ZXJhY3RpdmUudmlld3BvcnQnIGFzIGEgZmFsbGJhY2sgc2VsZWN0b3IgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6ICcjaW50ZXJhY3RpdmUudmlld3BvcnQnO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5SZWNvcmQoY2IpIHtcbiAgICBCYXJjb2RlTG9jYXRvci5jaGVja0ltYWdlQ29uc3RyYWludHMoX2lucHV0U3RyZWFtLCBfY29uZmlnLmxvY2F0b3IpO1xuICAgIGluaXRDYW52YXMoX2NvbmZpZyk7XG4gICAgX2ZyYW1lZ3JhYmJlciA9IEZyYW1lR3JhYmJlci5jcmVhdGUoX2lucHV0U3RyZWFtLCBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSk7XG5cbiAgICBhZGp1c3RXb3JrZXJQb29sKF9jb25maWcubnVtT2ZXb3JrZXJzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF9jb25maWcubnVtT2ZXb3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlYWR5KGNiKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZHkoY2Ipe1xuICAgIF9pbnB1dFN0cmVhbS5wbGF5KCk7XG4gICAgY2IoKTtcbn1cblxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciAkdmlld3BvcnQgPSBnZXRWaWV3UG9ydCgpO1xuICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXMuaW1nQnVmZmVyXCIpO1xuICAgICAgICBpZiAoIV9jYW52YXNDb250YWluZXIuZG9tLmltYWdlKSB7XG4gICAgICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZS5jbGFzc05hbWUgPSBcImltZ0J1ZmZlclwiO1xuICAgICAgICAgICAgaWYgKCR2aWV3cG9ydCAmJiBfY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09IFwiSW1hZ2VTdHJlYW1cIikge1xuICAgICAgICAgICAgICAgICR2aWV3cG9ydC5hcHBlbmRDaGlsZChfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2NhbnZhc0NvbnRhaW5lci5jdHguaW1hZ2UgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlLndpZHRoID0gX2lucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKS54O1xuICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZS5oZWlnaHQgPSBfaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLnk7XG5cbiAgICAgICAgX2NhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXMuZHJhd2luZ0J1ZmZlclwiKTtcbiAgICAgICAgaWYgKCFfY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5KSB7XG4gICAgICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkuY2xhc3NOYW1lID0gXCJkcmF3aW5nQnVmZmVyXCI7XG4gICAgICAgICAgICBpZiAoJHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgJHZpZXdwb3J0LmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsZWFyRml4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgICAgICAgY2xlYXJGaXguc2V0QXR0cmlidXRlKFwiY2xlYXJcIiwgXCJhbGxcIik7XG4gICAgICAgICAgICBpZiAoJHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgJHZpZXdwb3J0LmFwcGVuZENoaWxkKGNsZWFyRml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5vdmVybGF5ID0gX2NhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkud2lkdGggPSBfaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLng7XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkuaGVpZ2h0ID0gX2lucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKS55O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKSB7XG4gICAgaWYgKGltYWdlV3JhcHBlcikge1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2lucHV0SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICB4OiBfaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIHk6IF9pbnB1dFN0cmVhbS5nZXRIZWlnaHQoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKF9pbnB1dEltYWdlV3JhcHBlci5zaXplKTtcbiAgICB9XG4gICAgX2JveFNpemUgPSBbXG4gICAgICAgIHZlYzIuY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgdmVjMi5jbG9uZShbMCwgX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICB2ZWMyLmNsb25lKFtfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgIHZlYzIuY2xvbmUoW19pbnB1dEltYWdlV3JhcHBlci5zaXplLngsIDBdKVxuICAgIF07XG4gICAgQmFyY29kZUxvY2F0b3IuaW5pdChfaW5wdXRJbWFnZVdyYXBwZXIsIF9jb25maWcubG9jYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQm94ZXMoKSB7XG4gICAgaWYgKF9jb25maWcubG9jYXRlKSB7XG4gICAgICAgIHJldHVybiBCYXJjb2RlTG9jYXRvci5sb2NhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1tcbiAgICAgICAgICAgIHZlYzIuY2xvbmUoX2JveFNpemVbMF0pLFxuICAgICAgICAgICAgdmVjMi5jbG9uZShfYm94U2l6ZVsxXSksXG4gICAgICAgICAgICB2ZWMyLmNsb25lKF9ib3hTaXplWzJdKSxcbiAgICAgICAgICAgIHZlYzIuY2xvbmUoX2JveFNpemVbM10pXV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0KSB7XG4gICAgdmFyIHRvcFJpZ2h0ID0gX2lucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCksXG4gICAgICAgIHhPZmZzZXQgPSB0b3BSaWdodC54LFxuICAgICAgICB5T2Zmc2V0ID0gdG9wUmlnaHQueSxcbiAgICAgICAgaTtcblxuICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5iYXJjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNmb3JtUmVzdWx0KHJlc3VsdC5iYXJjb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmxpbmUgJiYgcmVzdWx0LmxpbmUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1vdmVMaW5lKHJlc3VsdC5saW5lKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmJveCkge1xuICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3gpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuYm94ZXMgJiYgcmVzdWx0LmJveGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94ZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZUJveChib3gpIHtcbiAgICAgICAgdmFyIGNvcm5lciA9IGJveC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGNvcm5lci0tKSB7XG4gICAgICAgICAgICBib3hbY29ybmVyXVswXSArPSB4T2Zmc2V0O1xuICAgICAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmVMaW5lKGxpbmUpIHtcbiAgICAgICAgbGluZVswXS54ICs9IHhPZmZzZXQ7XG4gICAgICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xuICAgICAgICBsaW5lWzFdLnggKz0geE9mZnNldDtcbiAgICAgICAgbGluZVsxXS55ICs9IHlPZmZzZXQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRSZXN1bHQgKHJlc3VsdCwgaW1hZ2VEYXRhKSB7XG4gICAgaWYgKCFpbWFnZURhdGEgfHwgIV9yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgcmVzdWx0LmJhcmNvZGVzLmZpbHRlcihiYXJjb2RlID0+IGJhcmNvZGUuY29kZVJlc3VsdClcbiAgICAgICAgICAgIC5mb3JFYWNoKGJhcmNvZGUgPT4gYWRkUmVzdWx0KGJhcmNvZGUsIGltYWdlRGF0YSkpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgX3Jlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQoaW1hZ2VEYXRhLCBfaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLCByZXN1bHQuY29kZVJlc3VsdCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb2RlUmVzdWx0IChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0ICYmIChyZXN1bHQuYmFyY29kZXMgP1xuICAgICAgcmVzdWx0LmJhcmNvZGVzLnNvbWUoYmFyY29kZSA9PiBiYXJjb2RlLmNvZGVSZXN1bHQpIDpcbiAgICAgIHJlc3VsdC5jb2RlUmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlc3VsdChyZXN1bHQsIGltYWdlRGF0YSkge1xuICAgIGxldCByZXN1bHRUb1B1Ymxpc2ggPSByZXN1bHQ7XG5cbiAgICBpZiAocmVzdWx0ICYmIF9vblVJVGhyZWFkKSB7XG4gICAgICAgIHRyYW5zZm9ybVJlc3VsdChyZXN1bHQpO1xuICAgICAgICBhZGRSZXN1bHQocmVzdWx0LCBpbWFnZURhdGEpO1xuICAgICAgICByZXN1bHRUb1B1Ymxpc2ggPSByZXN1bHQuYmFyY29kZXMgfHwgcmVzdWx0O1xuICAgIH1cblxuICAgIEV2ZW50cy5wdWJsaXNoKFwicHJvY2Vzc2VkXCIsIHJlc3VsdFRvUHVibGlzaCk7XG4gICAgaWYgKGhhc0NvZGVSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBFdmVudHMucHVibGlzaChcImRldGVjdGVkXCIsIHJlc3VsdFRvUHVibGlzaCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhdGVBbmREZWNvZGUoKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgYm94ZXM7XG5cbiAgICBib3hlcyA9IGdldEJvdW5kaW5nQm94ZXMoKTtcbiAgICBpZiAoYm94ZXMpIHtcbiAgICAgICAgcmVzdWx0ID0gX2RlY29kZXIuZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwge307XG4gICAgICAgIHJlc3VsdC5ib3hlcyA9IGJveGVzO1xuICAgICAgICBwdWJsaXNoUmVzdWx0KHJlc3VsdCwgX2lucHV0SW1hZ2VXcmFwcGVyLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHB1Ymxpc2hSZXN1bHQoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgYXZhaWxhYmxlV29ya2VyO1xuXG4gICAgaWYgKF9vblVJVGhyZWFkKSB7XG4gICAgICAgIGlmIChfd29ya2VyUG9vbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIgPSBfd29ya2VyUG9vbC5maWx0ZXIoZnVuY3Rpb24od29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF3b3JrZXJUaHJlYWQuYnVzeTtcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVdvcmtlcikge1xuICAgICAgICAgICAgICAgIF9mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YShhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBhbGwgd29ya2VycyBhcmUgYnVzeVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2ZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKF9pbnB1dEltYWdlV3JhcHBlci5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVXb3JrZXIpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIuYnVzeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGFcbiAgICAgICAgICAgICAgICB9LCBbYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YS5idWZmZXJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhdGVBbmREZWNvZGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpIHtcbiAgICB2YXIgbmV4dCA9IG51bGwsXG4gICAgICAgIGRlbGF5ID0gMTAwMCAvIChfY29uZmlnLmZyZXF1ZW5jeSB8fCA2MCk7XG5cbiAgICBfc3RvcHBlZCA9IGZhbHNlO1xuICAgIChmdW5jdGlvbiBmcmFtZSh0aW1lc3RhbXApIHtcbiAgICAgICAgbmV4dCA9IG5leHQgfHwgdGltZXN0YW1wO1xuICAgICAgICBpZiAoIV9zdG9wcGVkKSB7XG4gICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG5leHQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ICs9IGRlbGF5O1xuICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltRnJhbWUoZnJhbWUpO1xuICAgICAgICB9XG4gICAgfShwZXJmb3JtYW5jZS5ub3coKSkpO1xufVxuXG5mdW5jdGlvbiBzdGFydCgpIHtcbiAgICBpZiAoX29uVUlUaHJlYWQgJiYgX2NvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSBcIkxpdmVTdHJlYW1cIikge1xuICAgICAgICBzdGFydENvbnRpbnVvdXNVcGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXb3JrZXIoY2IpIHtcbiAgICB2YXIgYmxvYlVSTCxcbiAgICAgICAgd29ya2VyVGhyZWFkID0ge1xuICAgICAgICAgICAgd29ya2VyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbWFnZURhdGE6IG5ldyBVaW50OEFycmF5KF9pbnB1dFN0cmVhbS5nZXRXaWR0aCgpICogX2lucHV0U3RyZWFtLmdldEhlaWdodCgpKSxcbiAgICAgICAgICAgIGJ1c3k6IHRydWVcbiAgICAgICAgfTtcblxuICAgIGJsb2JVUkwgPSBnZW5lcmF0ZVdvcmtlckJsb2IoKTtcbiAgICB3b3JrZXJUaHJlYWQud29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmV2ZW50ID09PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldvcmtlciBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYih3b3JrZXJUaHJlYWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICBwdWJsaXNoUmVzdWx0KGUuZGF0YS5yZXN1bHQsIHdvcmtlclRocmVhZC5pbWFnZURhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIGVycm9yOiBcIiArIGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgIHNpemU6IHt4OiBfaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgeTogX2lucHV0U3RyZWFtLmdldEhlaWdodCgpfSxcbiAgICAgICAgaW1hZ2VEYXRhOiB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLFxuICAgICAgICBjb25maWc6IGNvbmZpZ0ZvcldvcmtlcihfY29uZmlnKVxuICAgIH0sIFt3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xufVxuXG5mdW5jdGlvbiBjb25maWdGb3JXb3JrZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgLi4uY29uZmlnLmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2UoZmFjdG9yeSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmKi9cbiAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICB2YXIgUXVhZ2dhID0gZmFjdG9yeSgpLmRlZmF1bHQ7XG4gICAgICAgIGlmICghUXVhZ2dhKSB7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsnZXZlbnQnOiAnZXJyb3InLCBtZXNzYWdlOiAnUXVhZ2dhIGNvdWxkIG5vdCBiZSBjcmVhdGVkJ30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBpbWFnZVdyYXBwZXI7XG5cbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5jbWQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGUuZGF0YS5jb25maWc7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgICAgIGltYWdlV3JhcHBlciA9IG5ldyBRdWFnZ2EuSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgICAgICB4OiBlLmRhdGEuc2l6ZS54LFxuICAgICAgICAgICAgICAgIHk6IGUuZGF0YS5zaXplLnlcbiAgICAgICAgICAgIH0sIG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIFF1YWdnYS5pbml0KGNvbmZpZywgcmVhZHksIGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBRdWFnZ2Eub25Qcm9jZXNzZWQob25Qcm9jZXNzZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdwcm9jZXNzJykge1xuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIFF1YWdnYS5zdGFydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xuICAgICAgICAgICAgUXVhZ2dhLnNldFJlYWRlcnMoZS5kYXRhLnJlYWRlcnMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uUHJvY2Vzc2VkKHJlc3VsdCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdwcm9jZXNzZWQnLFxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkeSgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsnZXZlbnQnOiAnaW5pdGlhbGl6ZWQnLCBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVXb3JrZXJCbG9iKCkge1xuICAgIHZhciBibG9iLFxuICAgICAgICBmYWN0b3J5U291cmNlO1xuXG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgIGlmICh0eXBlb2YgX19mYWN0b3J5U291cmNlX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZhY3RvcnlTb3VyY2UgPSBfX2ZhY3RvcnlTb3VyY2VfXzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgYmxvYiA9IG5ldyBCbG9iKFsnKCcgKyB3b3JrZXJJbnRlcmZhY2UudG9TdHJpbmcoKSArICcpKCcgKyBmYWN0b3J5U291cmNlICsgJyk7J10sXG4gICAgICAgIHt0eXBlOiAndGV4dC9qYXZhc2NyaXB0J30pO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG5mdW5jdGlvbiBzZXRSZWFkZXJzKHJlYWRlcnMpIHtcbiAgICBpZiAoX2RlY29kZXIpIHtcbiAgICAgICAgX2RlY29kZXIuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9IGVsc2UgaWYgKF9vblVJVGhyZWFkICYmIF93b3JrZXJQb29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX3dvcmtlclBvb2wuZm9yRWFjaChmdW5jdGlvbih3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe2NtZDogJ3NldFJlYWRlcnMnLCByZWFkZXJzOiByZWFkZXJzfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRqdXN0V29ya2VyUG9vbChjYXBhY2l0eSwgY2IpIHtcbiAgICBjb25zdCBpbmNyZWFzZUJ5ID0gY2FwYWNpdHkgLSBfd29ya2VyUG9vbC5sZW5ndGg7XG4gICAgaWYgKGluY3JlYXNlQnkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgfVxuICAgIGlmIChpbmNyZWFzZUJ5IDwgMCkge1xuICAgICAgICBjb25zdCB3b3JrZXJzVG9UZXJtaW5hdGUgPSBfd29ya2VyUG9vbC5zbGljZShpbmNyZWFzZUJ5KTtcbiAgICAgICAgd29ya2Vyc1RvVGVybWluYXRlLmZvckVhY2goZnVuY3Rpb24od29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIHRlcm1pbmF0ZWQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3dvcmtlclBvb2wgPSBfd29ya2VyUG9vbC5zbGljZSgwLCBpbmNyZWFzZUJ5KTtcbiAgICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNyZWFzZUJ5OyBpKyspIHtcbiAgICAgICAgICAgIGluaXRXb3JrZXIod29ya2VySW5pdGlhbGl6ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd29ya2VySW5pdGlhbGl6ZWQod29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICBfd29ya2VyUG9vbC5wdXNoKHdvcmtlclRocmVhZCk7XG4gICAgICAgICAgICBpZiAoX3dvcmtlclBvb2wubGVuZ3RoID49IGNhcGFjaXR5KXtcbiAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdDogZnVuY3Rpb24oY29uZmlnLCBjYiwgaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIF9jb25maWcgPSBtZXJnZSh7fSwgQ29uZmlnLCBjb25maWcpO1xuICAgICAgICBpZiAoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBfb25VSVRocmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5pdElucHV0U3RyZWFtKGNiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGFydCgpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIF9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgYWRqdXN0V29ya2VyUG9vbCgwKTtcbiAgICAgICAgaWYgKF9jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gXCJMaXZlU3RyZWFtXCIpIHtcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICBfaW5wdXRTdHJlYW0uY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3N0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25EZXRlY3RlZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZShcImRldGVjdGVkXCIsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9mZkRldGVjdGVkOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoXCJkZXRlY3RlZFwiLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvblByb2Nlc3NlZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZShcInByb2Nlc3NlZFwiLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmZQcm9jZXNzZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZShcInByb2Nlc3NlZFwiLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbihyZWFkZXJzKSB7XG4gICAgICAgIHNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgfSxcbiAgICByZWdpc3RlclJlc3VsdENvbGxlY3RvcjogZnVuY3Rpb24ocmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChyZXN1bHRDb2xsZWN0b3IgJiYgdHlwZW9mIHJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9yZXN1bHRDb2xsZWN0b3IgPSByZXN1bHRDb2xsZWN0b3I7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbnZhczogX2NhbnZhc0NvbnRhaW5lcixcbiAgICBkZWNvZGVTaW5nbGU6IGZ1bmN0aW9uKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgY29uZmlnID0gbWVyZ2Uoe1xuICAgICAgICAgICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkltYWdlU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgICAgICAgICBzcmM6IGNvbmZpZy5zcmNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxuICAgICAgICAgICAgbG9jYXRvcjoge1xuICAgICAgICAgICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuaW5pdChjb25maWcsICgpID0+IHtcbiAgICAgICAgICAgIEV2ZW50cy5vbmNlKFwicHJvY2Vzc2VkXCIsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjay5jYWxsKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgSW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIsXG4gICAgSW1hZ2VEZWJ1ZzogSW1hZ2VEZWJ1ZyxcbiAgICBSZXN1bHRDb2xsZWN0b3I6IFJlc3VsdENvbGxlY3RvcixcbiAgICBDYW1lcmFBY2Nlc3M6IENhbWVyYUFjY2Vzcyxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcXVhZ2dhLmpzIiwiaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcblxuZnVuY3Rpb24gY29udGFpbnMoY29kZVJlc3VsdCwgbGlzdCkge1xuICAgIGlmIChsaXN0KSB7XG4gICAgICAgIHJldHVybiBsaXN0LnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1ba2V5XSA9PT0gY29kZVJlc3VsdFtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBhc3Nlc0ZpbHRlcihjb2RlUmVzdWx0LCBmaWx0ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyKGNvZGVSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgIGNhcGFjaXR5ID0gY29uZmlnLmNhcGFjaXR5IHx8IDIwLFxuICAgICAgICAgICAgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwYWNpdHlcbiAgICAgICAgICAgICAgICAmJiBjb2RlUmVzdWx0XG4gICAgICAgICAgICAgICAgJiYgIWNvbnRhaW5zKGNvZGVSZXN1bHQsIGNvbmZpZy5ibGFja2xpc3QpXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGNvbmZpZy5maWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFJlc3VsdDogZnVuY3Rpb24oZGF0YSwgaW1hZ2VTaXplLCBjb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eS0tO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCA9IGNvZGVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZVNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZVNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd0ltYWdlKGRhdGEsIGltYWdlU2l6ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdWx0czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci5qcyIsImNvbnN0IHZlYzIgPSB7XG4gICAgY2xvbmU6IHJlcXVpcmUoJ2dsLXZlYzIvY2xvbmUnKSxcbiAgICBkb3Q6IHJlcXVpcmUoJ2dsLXZlYzIvZG90Jylcbn1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2x1c3RlciBmb3IgZ3JvdXBpbmcgc2ltaWxhciBvcmllbnRhdGlvbnMgb2YgZGF0YXBvaW50c1xuICAgICAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24ocG9pbnQsIHRocmVzaG9sZCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gW10sXG4gICAgICAgICAgICBjZW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbMCwgMF0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnRNYXAgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgYWRkKHBvaW50KTtcbiAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgIHBvaW50TWFwW3BvaW50VG9BZGQuaWRdID0gcG9pbnRUb0FkZDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50VG9BZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xuICAgICAgICAgICAgdmFyIGksIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBwb2ludHNbaV0ucmFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VudGVyLnJhZCA9IHN1bSAvIHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBjZW50ZXIudmVjID0gdmVjMi5jbG9uZShbTWF0aC5jb3MoY2VudGVyLnJhZCksIE1hdGguc2luKGNlbnRlci5yYWQpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24ocG9pbnRUb0FkZCkge1xuICAgICAgICAgICAgICAgIGlmICghcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0czogZnVuY3Rpb24ob3RoZXJQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvc2luZSBzaW1pbGFyaXR5IHRvIGNlbnRlci1hbmdsZVxuICAgICAgICAgICAgICAgIHZhciBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3Qob3RoZXJQb2ludC5wb2ludC52ZWMsIGNlbnRlci52ZWMpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVQb2ludDogZnVuY3Rpb24obmV3UG9pbnQsIGlkLCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFkOiBuZXdQb2ludFtwcm9wZXJ0eV0sXG4gICAgICAgICAgICBwb2ludDogbmV3UG9pbnQsXG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9jbHVzdGVyLmpzIiwiZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBldmVudHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIWV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50c1tldmVudE5hbWVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyRXZlbnRzKCl7XG4gICAgICAgIGV2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBkYXRhKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfSwgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmUoZXZlbnQsIGNhbGxiYWNrLCBhc3luYykge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuXG4gICAgICAgIGlmICggdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmM6IGFzeW5jXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbi5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IFwiQ2FsbGJhY2sgd2FzIG5vdCBzcGVjaWZpZWQgb24gb3B0aW9uc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0RXZlbnQoZXZlbnQpLnN1YnNjcmliZXJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUoZXZlbnQsIGNhbGxiYWNrLCBhc3luYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1Ymxpc2g6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKSxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVycyA9IGV2ZW50LnN1YnNjcmliZXJzO1xuXG4gICAgICAgICAgICAvLyBQdWJsaXNoIG9uZS10aW1lIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbihzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhc3Vic2NyaWJlci5vbmNlO1xuICAgICAgICAgICAgfSkuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc3Vic2NyaWJlclxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24oc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc3Vic2NyaWJlci5vbmNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIHJlc3RcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2U6IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZShldmVudCwge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYzogYXN5bmMsXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQ7XG5cbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gZXZlbnQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uKHN1YnNjcmliZXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIuY2FsbGJhY2sgIT09IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJFdmVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9ldmVudHMuanMiLCJcbmV4cG9ydCBmdW5jdGlvbiBlbnVtZXJhdGVEZXZpY2VzKCkge1xuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gICAgICAgICAgICAmJiB0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignZW51bWVyYXRlRGV2aWNlcyBpcyBub3QgZGVmaW5lZCcpKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpIHtcbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xuICAgICAgICAgICAgJiYgdHlwZW9mIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gICAgICAgICAgICAuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignZ2V0VXNlck1lZGlhIGlzIG5vdCBkZWZpbmVkJykpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi9tZWRpYURldmljZXMuanMiLCIvKipcbiAqIENvbnN0cnVjdCByZXByZXNlbnRpbmcgYSBwYXJ0IG9mIGFub3RoZXIge0ltYWdlV3JhcHBlcn0uIFNoYXJlcyBkYXRhXG4gKiBiZXR3ZWVuIHRoZSBwYXJlbnQgYW5kIHRoZSBjaGlsZC5cbiAqIEBwYXJhbSBmcm9tIHtJbWFnZVJlZn0gVGhlIHBvc2l0aW9uIHdoZXJlIHRvIHN0YXJ0IHRoZSB7U3ViSW1hZ2V9IGZyb20uICh0b3AtbGVmdCBjb3JuZXIpXG4gKiBAcGFyYW0gc2l6ZSB7SW1hZ2VSZWZ9IFRoZSBzaXplIG9mIHRoZSByZXN1bHRpbmcgaW1hZ2VcbiAqIEBwYXJhbSBJIHtJbWFnZVdyYXBwZXJ9IFRoZSB7SW1hZ2VXcmFwcGVyfSB0byBzaGFyZSBmcm9tXG4gKiBAcmV0dXJucyB7U3ViSW1hZ2V9IEEgc2hhcmVkIHBhcnQgb2YgdGhlIG9yaWdpbmFsIGltYWdlXG4gKi9cbmZ1bmN0aW9uIFN1YkltYWdlKGZyb20sIHNpemUsIEkpIHtcbiAgICBpZiAoIUkpIHtcbiAgICAgICAgSSA9IHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZGF0YSA9IEkuZGF0YTtcbiAgICB0aGlzLm9yaWdpbmFsU2l6ZSA9IEkuc2l6ZTtcbiAgICB0aGlzLkkgPSBJO1xuXG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xufVxuXG4vKipcbiAqIERpc3BsYXlzIHRoZSB7U3ViSW1hZ2V9IGluIGEgZ2l2ZW4gY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCB0byB3cml0ZSB0b1xuICogQHBhcmFtIHNjYWxlIHtOdW1iZXJ9IFNjYWxlIHdoaWNoIGlzIGFwcGxpZWQgdG8gZWFjaCBwaXhlbC12YWx1ZVxuICovXG5TdWJJbWFnZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKGNhbnZhcywgc2NhbGUpIHtcbiAgICB2YXIgY3R4LFxuICAgICAgICBmcmFtZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgeSxcbiAgICAgICAgeCxcbiAgICAgICAgcGl4ZWw7XG5cbiAgICBpZiAoIXNjYWxlKSB7XG4gICAgICAgIHNjYWxlID0gMS4wO1xuICAgIH1cbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMud2lkdGggPSB0aGlzLnNpemUueDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgZGF0YSA9IGZyYW1lLmRhdGE7XG4gICAgY3VycmVudCA9IDA7XG4gICAgZm9yICh5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHRoaXMuc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgIHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldCh4LCB5KSAqIHNjYWxlO1xuICAgICAgICAgICAgZGF0YVtwaXhlbCAqIDQgKyAwXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBkYXRhW3BpeGVsICogNCArIDFdID0gY3VycmVudDtcbiAgICAgICAgICAgIGRhdGFbcGl4ZWwgKiA0ICsgMl0gPSBjdXJyZW50O1xuICAgICAgICAgICAgZGF0YVtwaXhlbCAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcmFtZS5kYXRhID0gZGF0YTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGZyYW1lLCAwLCAwKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gZnJvbSB0aGUge1N1YkltYWdlfVxuICogQHBhcmFtIHgge051bWJlcn0gVGhlIHgtcG9zaXRpb25cbiAqIEBwYXJhbSB5IHtOdW1iZXJ9IFRoZSB5LXBvc2l0aW9uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBwaXhlbC1wb3NpdGlvblxuICovXG5TdWJJbWFnZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbKHRoaXMuZnJvbS55ICsgeSkgKiB0aGlzLm9yaWdpbmFsU2l6ZS54ICsgdGhpcy5mcm9tLnggKyB4XTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdW5kZXJseWluZyBkYXRhIGZyb20gYSBnaXZlbiB7SW1hZ2VXcmFwcGVyfVxuICogQHBhcmFtIGltYWdlIHtJbWFnZVdyYXBwZXJ9IFRoZSB1cGRhdGVkIGltYWdlXG4gKi9cblN1YkltYWdlLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICB0aGlzLm9yaWdpbmFsU2l6ZSA9IGltYWdlLnNpemU7XG4gICAgdGhpcy5kYXRhID0gaW1hZ2UuZGF0YTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHNoYXJlZCBhcmVhXG4gKiBAcGFyYW0gZnJvbSB7eCx5fSBUaGUgbmV3IGxvY2F0aW9uXG4gKiBAcmV0dXJucyB7U3ViSW1hZ2V9IHJldHVybnMge3RoaXN9IGZvciBwb3NzaWJsZSBjaGFpbmluZ1xuICovXG5TdWJJbWFnZS5wcm90b3R5cGUudXBkYXRlRnJvbSA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgKFN1YkltYWdlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vc3ViSW1hZ2UuanMiLCIvKlxuICogdHlwZWRlZnMuanNcbiAqIE5vcm1hbGl6ZXMgYnJvd3Nlci1zcGVjaWZpYyBwcmVmaXhlc1xuICovXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgvKiBmdW5jdGlvbiBGcmFtZVJlcXVlc3RDYWxsYmFjayAqLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgfTtcbiAgICB9KSgpO1xufVxuTWF0aC5pbXVsID0gTWF0aC5pbXVsIHx8IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgYWggPSAoYSA+Pj4gMTYpICYgMHhmZmZmLFxuICAgICAgICBhbCA9IGEgJiAweGZmZmYsXG4gICAgICAgIGJoID0gKGIgPj4+IDE2KSAmIDB4ZmZmZixcbiAgICAgICAgYmwgPSBiICYgMHhmZmZmO1xuICAgIC8vIHRoZSBzaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnRcbiAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcbiAgICByZXR1cm4gKChhbCAqIGJsKSArICgoKGFoICogYmwgKyBhbCAqIGJoKSA8PCAxNikgPj4+IDApIHwgMCk7XG59O1xuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24odGFyZ2V0KSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxuICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHsgLy8gVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlICE9PSBudWxsKSB7IC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gbmV4dFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0U291cmNlLCBuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbW1vbi90eXBlZGVmcy5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6IFwiTGl2ZVwiLFxuICAgICAgICB0eXBlOiBcIkxpdmVTdHJlYW1cIixcbiAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgICAgICAgIC8vIGFzcGVjdFJhdGlvOiA2NDAvNDgwLCAvLyBvcHRpb25hbFxuICAgICAgICAgICAgZmFjaW5nTW9kZTogXCJlbnZpcm9ubWVudFwiLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogXCIwJVwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiMCVcIixcbiAgICAgICAgICAgIGxlZnQ6IFwiMCVcIixcbiAgICAgICAgICAgIGJvdHRvbTogXCIwJVwiXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJ1xuICAgICAgICBdLFxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgZHJhd0JvdW5kaW5nQm94OiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGcmVxdWVuY3k6IGZhbHNlLFxuICAgICAgICAgICAgZHJhd1NjYW5saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXR0ZXJuOiBmYWxzZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogXCJtZWRpdW1cIiwgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIHNob3dDYW52YXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0ZvdW5kUGF0Y2hlczogZmFsc2UsXG4gICAgICAgICAgICBzaG93U2tlbGV0b246IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0xhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGJveEZyb21QYXRjaGVzOiB7XG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWRCb3g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCQjogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29uZmlnL2NvbmZpZy5kZXYuanMiLCJsZXQgY29uZmlnO1xuXG5pZiAoRU5WLmRldmVsb3BtZW50KXtcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy5kZXYuanMnKTtcbn0gZWxzZSBpZiAoRU5WLm5vZGUpIHtcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy5ub2RlLmpzJyk7XG59IGVsc2Uge1xuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnLnByb2QuanMnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uZmlnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy9jb25maWcuanMiLCJpbXBvcnQgQnJlc2VuaGFtIGZyb20gJy4vYnJlc2VuaGFtJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgQ29kZTEyOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8xMjhfcmVhZGVyJztcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVZJTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyJztcbmltcG9ydCBDb2RhYmFyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RhYmFyX3JlYWRlcic7XG5pbXBvcnQgVVBDUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfcmVhZGVyJztcbmltcG9ydCBFQU44UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fOF9yZWFkZXInO1xuaW1wb3J0IEVBTjJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl8yX3JlYWRlcic7XG5pbXBvcnQgRUFONVJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzVfcmVhZGVyJztcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfZV9yZWFkZXInO1xuaW1wb3J0IEkyb2Y1UmVhZGVyIGZyb20gJy4uL3JlYWRlci9pMm9mNV9yZWFkZXInO1xuaW1wb3J0IFR3b09mRml2ZVJlYWRlciBmcm9tICcuLi9yZWFkZXIvMm9mNV9yZWFkZXInO1xuaW1wb3J0IENvZGU5M1JlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV85M19yZWFkZXInO1xuXG5jb25zdCBSRUFERVJTID0ge1xuICAgIGNvZGVfMTI4X3JlYWRlcjogQ29kZTEyOFJlYWRlcixcbiAgICBlYW5fcmVhZGVyOiBFQU5SZWFkZXIsXG4gICAgZWFuXzVfcmVhZGVyOiBFQU41UmVhZGVyLFxuICAgIGVhbl8yX3JlYWRlcjogRUFOMlJlYWRlcixcbiAgICBlYW5fOF9yZWFkZXI6IEVBTjhSZWFkZXIsXG4gICAgY29kZV8zOV9yZWFkZXI6IENvZGUzOVJlYWRlcixcbiAgICBjb2RlXzM5X3Zpbl9yZWFkZXI6IENvZGUzOVZJTlJlYWRlcixcbiAgICBjb2RhYmFyX3JlYWRlcjogQ29kYWJhclJlYWRlcixcbiAgICB1cGNfcmVhZGVyOiBVUENSZWFkZXIsXG4gICAgdXBjX2VfcmVhZGVyOiBVUENFUmVhZGVyLFxuICAgIGkyb2Y1X3JlYWRlcjogSTJvZjVSZWFkZXIsXG4gICAgJzJvZjVfcmVhZGVyJzogVHdvT2ZGaXZlUmVhZGVyLFxuICAgIGNvZGVfOTNfcmVhZGVyOiBDb2RlOTNSZWFkZXJcbn07XG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbihjb25maWcsIGlucHV0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIHZhciBfY2FudmFzID0ge1xuICAgICAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRvbToge1xuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzID0gW107XG5cbiAgICAgICAgaW5pdENhbnZhcygpO1xuICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICBpbml0Q29uZmlnKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciAkZGVidWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2RlYnVnLmRldGVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiY2FudmFzLmZyZXF1ZW5jeVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLmZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kuY2xhc3NOYW1lID0gXCJmcmVxdWVuY3lcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHguZnJlcXVlbmN5ID0gX2NhbnZhcy5kb20uZnJlcXVlbmN5LmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiY2FudmFzLnBhdHRlcm5CdWZmZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuLmNsYXNzTmFtZSA9IFwicGF0dGVybkJ1ZmZlclwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgucGF0dGVybiA9IF9jYW52YXMuZG9tLnBhdHRlcm4uZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ub3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXMuZHJhd2luZ0J1ZmZlclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoX2NhbnZhcy5kb20ub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5vdmVybGF5ID0gX2NhbnZhcy5kb20ub3ZlcmxheS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFJlYWRlcnMoKSB7XG4gICAgICAgICAgICBjb25maWcucmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHJlYWRlckNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciByZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgc3VwcGxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWcuZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uID0gcmVhZGVyQ29uZmlnLmNvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkJlZm9yZSByZWdpc3RlcmluZyByZWFkZXI6IFwiLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5zdXBwbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdXBwbGVtZW50cy5tYXAoKHN1cHBsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJFQURFUlNbc3VwcGxlbWVudF0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMucHVzaChuZXcgUkVBREVSU1tyZWFkZXJdKGNvbmZpZ3VyYXRpb24sIHN1cHBsZW1lbnRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlZ2lzdGVyZWQgUmVhZGVyczogXCIgKyBfYmFyY29kZVJlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVhZGVyKSA9PiBKU09OLnN0cmluZ2lmeSh7Zm9ybWF0OiByZWFkZXIuRk9STUFULCBjb25maWc6IHJlYWRlci5jb25maWd9KSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENvbmZpZygpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgICAgICB2aXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20uZnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3lcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVyblxuICAgICAgICAgICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc1tpXS5wcm9wID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4dGVuZCB0aGUgbGluZSBvbiBib3RoIGVuZHNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkTGluZShsaW5lLCBhbmdsZSwgZXh0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBleHRlbmRMaW5lKGFtb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGFtb3VudCAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgeDogYW1vdW50ICogTWF0aC5jb3MoYW5nbGUpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaW5zaWRlIGltYWdlXG4gICAgICAgICAgICBleHRlbmRMaW5lKGV4dCk7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ID4gMSAmJiAoIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMF0sIDApXG4gICAgICAgICAgICAgICAgICAgIHx8ICFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzFdLCAwKSkpIHtcbiAgICAgICAgICAgICAgICBleHQgLT0gTWF0aC5jZWlsKGV4dCAvIDIpO1xuICAgICAgICAgICAgICAgIGV4dGVuZExpbmUoLWV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmUoYm94KSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICB4OiAoYm94WzFdWzBdIC0gYm94WzBdWzBdKSAvIDIgKyBib3hbMF1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogKGJveFszXVswXSAtIGJveFsyXVswXSkgLyAyICsgYm94WzJdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbM11bMV0gLSBib3hbMl1bMV0pIC8gMiArIGJveFsyXVsxXVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGUobGluZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZSA9IEJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZShpbnB1dEltYWdlV3JhcHBlciwgbGluZVswXSwgbGluZVsxXSk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHt4OiAneCcsIHk6ICd5J30sIF9jYW52YXMuY3R4Lm92ZXJsYXksIHtjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogM30pO1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludEZyZXF1ZW5jeShiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBCcmVzZW5oYW0udG9CaW5hcnlMaW5lKGJhcmNvZGVMaW5lKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IF9iYXJjb2RlUmVhZGVycy5sZW5ndGggJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlUGF0dGVybihiYXJjb2RlTGluZS5saW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgYmFyY29kZUxpbmU6IGJhcmNvZGVMaW5lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNsaWNlcyB0aGUgZ2l2ZW4gYXJlYSBhcGFydCBhbmQgdHJpZXMgdG8gZGV0ZWN0IGEgYmFyY29kZS1wYXR0ZXJuXG4gICAgICAgICAqIGZvciBlYWNoIHNsaWNlLiBJdCByZXR1cm5zIHRoZSBkZWNvZGVkIGJhcmNvZGUsIG9yIG51bGwgaWYgbm90aGluZyB3YXMgZm91bmRcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYm94XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSkge1xuICAgICAgICAgICAgdmFyIHNpZGVMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coYm94WzFdWzBdIC0gYm94WzBdWzBdLCAyKSArIE1hdGgucG93KChib3hbMV1bMV0gLSBib3hbMF1bMV0pLCAyKSksXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBzbGljZXMgPSAxNixcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsLFxuICAgICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAgICAgeGRpciA9IE1hdGguc2luKGxpbmVBbmdsZSksXG4gICAgICAgICAgICAgICAgeWRpciA9IE1hdGguY29zKGxpbmVBbmdsZSk7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAxOyBpIDwgc2xpY2VzICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBsaW5lIHBlcnBlbmRpY3VsYXIgdG8gYW5nbGVcbiAgICAgICAgICAgICAgICBkaXIgPSBzaWRlTGVuZ3RoIC8gc2xpY2VzICogaSAqIChpICUgMiA9PT0gMCA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBkaXIgKiB4ZGlyLFxuICAgICAgICAgICAgICAgICAgICB4OiBkaXIgKiB5ZGlyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggLT0gZXh0ZW5zaW9uLnk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGUobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSksIDIpICtcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnggLSBsaW5lWzBdLngpLCAyKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCB0aGUgaGVscCBvZiB0aGUgY29uZmlndXJlZCByZWFkZXJzIChDb2RlMTI4IG9yIEVBTikgdGhpcyBmdW5jdGlvbiB0cmllcyB0byBkZXRlY3QgYVxuICAgICAgICAgKiB2YWxpZCBiYXJjb2RlIHBhdHRlcm4gd2l0aGluIHRoZSBnaXZlbiBhcmVhLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYm94IFRoZSBhcmVhIHRvIHNlYXJjaCBpblxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVzdWx0IHtjb2RlUmVzdWx0LCBsaW5lLCBhbmdsZSwgcGF0dGVybiwgdGhyZXNob2xkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgdmFyIGxpbmUsXG4gICAgICAgICAgICAgICAgbGluZUFuZ2xlLFxuICAgICAgICAgICAgICAgIGN0eCA9IF9jYW52YXMuY3R4Lm92ZXJsYXksXG4gICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgIGxpbmVMZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnLmRyYXdCb3VuZGluZ0JveCAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHt4OiAwLCB5OiAxfSwgY3R4LCB7Y29sb3I6IFwiYmx1ZVwiLCBsaW5lV2lkdGg6IDJ9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUgPSBnZXRMaW5lKGJveCk7XG4gICAgICAgICAgICBsaW5lTGVuZ3RoID0gZ2V0TGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgICAgIGxpbmVBbmdsZSA9IE1hdGguYXRhbjIobGluZVsxXS55IC0gbGluZVswXS55LCBsaW5lWzFdLnggLSBsaW5lWzBdLngpO1xuICAgICAgICAgICAgbGluZSA9IGdldEV4dGVuZGVkTGluZShsaW5lLCBsaW5lQW5nbGUsIE1hdGguZmxvb3IobGluZUxlbmd0aCAqIDAuMSkpO1xuICAgICAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGUobGluZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiByZXN1bHQgJiYgY29uZmlnLmRlYnVnLmRyYXdTY2FubGluZSAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHt4OiAneCcsIHk6ICd5J30sIGN0eCwge2NvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LmNvZGVSZXN1bHQsXG4gICAgICAgICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICAgICAgICBhbmdsZTogbGluZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHJlc3VsdC5iYXJjb2RlTGluZS5saW5lLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogcmVzdWx0LmJhcmNvZGVMaW5lLnRocmVzaG9sZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3g6IGZ1bmN0aW9uKGJveCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3hlczogZnVuY3Rpb24oYm94ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSA9IGNvbmZpZy5tdWx0aXBsZTtcblxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94ID0gYm94ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm94ID0gYm94O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2Rlc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbihyZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMgPSByZWFkZXJzO1xuICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlci5qcyIsImltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuXG52YXIgQnJlc2VuaGFtID0ge307XG5cbnZhciBTbG9wZSA9IHtcbiAgICBESVI6IHtcbiAgICAgICAgVVA6IDEsXG4gICAgICAgIERPV046IC0xXG4gICAgfVxufTtcbi8qKlxuICogU2NhbnMgYSBsaW5lIG9mIHRoZSBnaXZlbiBpbWFnZSBmcm9tIHBvaW50IHAxIHRvIHAyIGFuZCByZXR1cm5zIGEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nXG4gKiBncmF5LXNjYWxlIHZhbHVlcyAoMC0yNTUpIG9mIHRoZSB1bmRlcmx5aW5nIHBpeGVscyBpbiBhZGRpdGlvbiB0byB0aGUgbWluXG4gKiBhbmQgbWF4IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVdyYXBwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSBUaGUgc3RhcnQgcG9pbnQge3gseX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiBUaGUgZW5kIHBvaW50IHt4LHl9XG4gKiBAcmV0dXJucyB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZSA9IGZ1bmN0aW9uKGltYWdlV3JhcHBlciwgcDEsIHAyKSB7XG4gICAgdmFyIHgwID0gcDEueCB8IDAsXG4gICAgICAgIHkwID0gcDEueSB8IDAsXG4gICAgICAgIHgxID0gcDIueCB8IDAsXG4gICAgICAgIHkxID0gcDIueSB8IDAsXG4gICAgICAgIHN0ZWVwID0gTWF0aC5hYnMoeTEgLSB5MCkgPiBNYXRoLmFicyh4MSAtIHgwKSxcbiAgICAgICAgZGVsdGF4LFxuICAgICAgICBkZWx0YXksXG4gICAgICAgIGVycm9yLFxuICAgICAgICB5c3RlcCxcbiAgICAgICAgeSxcbiAgICAgICAgdG1wLFxuICAgICAgICB4LFxuICAgICAgICBsaW5lID0gW10sXG4gICAgICAgIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLngsXG4gICAgICAgIHN1bSA9IDAsXG4gICAgICAgIHZhbCxcbiAgICAgICAgbWluID0gMjU1LFxuICAgICAgICBtYXggPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVhZChhLCBiKSB7XG4gICAgICAgIHZhbCA9IGltYWdlRGF0YVtiICogd2lkdGggKyBhXTtcbiAgICAgICAgc3VtICs9IHZhbDtcbiAgICAgICAgbWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuICAgICAgICBtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG4gICAgICAgIGxpbmUucHVzaCh2YWwpO1xuICAgIH1cblxuICAgIGlmIChzdGVlcCkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB5MDtcbiAgICAgICAgeTAgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geDE7XG4gICAgICAgIHgxID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBpZiAoeDAgPiB4MSkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgeDEgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geTA7XG4gICAgICAgIHkwID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBkZWx0YXggPSB4MSAtIHgwO1xuICAgIGRlbHRheSA9IE1hdGguYWJzKHkxIC0geTApO1xuICAgIGVycm9yID0gKGRlbHRheCAvIDIpIHwgMDtcbiAgICB5ID0geTA7XG4gICAgeXN0ZXAgPSB5MCA8IHkxID8gMSA6IC0xO1xuICAgIGZvciAoIHggPSB4MDsgeCA8IHgxOyB4KyspIHtcbiAgICAgICAgaWYgKHN0ZWVwKXtcbiAgICAgICAgICAgIHJlYWQoeSwgeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFkKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyb3IgLSBkZWx0YXk7XG4gICAgICAgIGlmIChlcnJvciA8IDApIHtcbiAgICAgICAgICAgIHkgPSB5ICsgeXN0ZXA7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yICsgZGVsdGF4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4XG4gICAgfTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHJlc3VsdCBmcm9tIGdldEJhcmNvZGVMaW5lIGludG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAqIGFsc28gY29uc2lkZXJpbmcgdGhlIGZyZXF1ZW5jeSBhbmQgc2xvcGUgb2YgdGhlIHNpZ25hbCBmb3IgbW9yZSByb2J1c3QgcmVzdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS50b0JpbmFyeUxpbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB2YXIgbWluID0gcmVzdWx0Lm1pbixcbiAgICAgICAgbWF4ID0gcmVzdWx0Lm1heCxcbiAgICAgICAgbGluZSA9IHJlc3VsdC5saW5lLFxuICAgICAgICBzbG9wZSxcbiAgICAgICAgc2xvcGUyLFxuICAgICAgICBjZW50ZXIgPSBtaW4gKyAobWF4IC0gbWluKSAvIDIsXG4gICAgICAgIGV4dHJlbWEgPSBbXSxcbiAgICAgICAgY3VycmVudERpcixcbiAgICAgICAgZGlyLFxuICAgICAgICB0aHJlc2hvbGQgPSAobWF4IC0gbWluKSAvIDEyLFxuICAgICAgICByVGhyZXNob2xkID0gLXRocmVzaG9sZCxcbiAgICAgICAgaSxcbiAgICAgICAgajtcblxuICAgIC8vIDEuIGZpbmQgZXh0cmVtYVxuICAgIGN1cnJlbnREaXIgPSBsaW5lWzBdID4gY2VudGVyID8gU2xvcGUuRElSLlVQIDogU2xvcGUuRElSLkRPV047XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICB2YWw6IGxpbmVbMF1cbiAgICB9KTtcbiAgICBmb3IgKCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgIHNsb3BlID0gKGxpbmVbaSArIDFdIC0gbGluZVtpXSk7XG4gICAgICAgIHNsb3BlMiA9IChsaW5lW2kgKyAyXSAtIGxpbmVbaSArIDFdKTtcbiAgICAgICAgaWYgKChzbG9wZSArIHNsb3BlMikgPCByVGhyZXNob2xkICYmIGxpbmVbaSArIDFdIDwgKGNlbnRlciAqIDEuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5ET1dOO1xuICAgICAgICB9IGVsc2UgaWYgKChzbG9wZSArIHNsb3BlMikgPiB0aHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPiAoY2VudGVyICogMC41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLlVQO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlyID0gY3VycmVudERpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGlyICE9PSBkaXIpIHtcbiAgICAgICAgICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgIHZhbDogbGluZVtpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50RGlyID0gZGlyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgIHBvczogbGluZS5sZW5ndGgsXG4gICAgICAgIHZhbDogbGluZVtsaW5lLmxlbmd0aCAtIDFdXG4gICAgfSk7XG5cbiAgICBmb3IgKCBqID0gZXh0cmVtYVswXS5wb3M7IGogPCBleHRyZW1hWzFdLnBvczsgaisrKSB7XG4gICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gY2VudGVyID8gMCA6IDE7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGV4dHJlbWEgYW5kIGNvbnZlcnQgdG8gYmluYXJ5IGJhc2VkIG9uIGF2ZyBiZXR3ZWVuIG1pbm1heFxuICAgIGZvciAoIGkgPSAxOyBpIDwgZXh0cmVtYS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGV4dHJlbWFbaSArIDFdLnZhbCA+IGV4dHJlbWFbaV0udmFsKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpXS52YWwgKyAoKGV4dHJlbWFbaSArIDFdLnZhbCAtIGV4dHJlbWFbaV0udmFsKSAvIDMpICogMikgfCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaSArIDFdLnZhbCArICgoZXh0cmVtYVtpXS52YWwgLSBleHRyZW1hW2kgKyAxXS52YWwpIC8gMykpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIGogPSBleHRyZW1hW2ldLnBvczsgaiA8IGV4dHJlbWFbaSArIDFdLnBvczsgaisrKSB7XG4gICAgICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IHRocmVzaG9sZCA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgdGhyZXNob2xkOiB0aHJlc2hvbGRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBVc2VkIGZvciBkZXZlbG9wbWVudCBvbmx5XG4gKi9cbkJyZXNlbmhhbS5kZWJ1ZyA9IHtcbiAgICBwcmludEZyZXF1ZW5jeTogZnVuY3Rpb24obGluZSwgY2FudmFzKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyNTY7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImJsdWVcIjtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGksIDI1NSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGksIDI1NSAtIGxpbmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBwcmludFBhdHRlcm46IGZ1bmN0aW9uKGxpbmUsIGNhbnZhcykge1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSwgaTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgY3R4LmZpbGxDb2xvciA9IFwiYmxhY2tcIjtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChpLCAwLCAxLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnJlc2VuaGFtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwiaW1wb3J0IHtvbWl0LCBwaWNrfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtnZXRVc2VyTWVkaWEsIGVudW1lcmF0ZURldmljZXN9IGZyb20gJ21lZGlhRGV2aWNlcyc7XG5cbmNvbnN0IGZhY2luZ01hdGNoaW5nID0ge1xuICAgIFwidXNlclwiOiAvZnJvbnQvaSxcbiAgICBcImVudmlyb25tZW50XCI6IC9iYWNrL2lcbn07XG5cbnZhciBzdHJlYW1SZWY7XG5cbmZ1bmN0aW9uIHdhaXRGb3JWaWRlbyh2aWRlbykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDEwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrVmlkZW8oKSB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvLnZpZGVvV2lkdGggPiAxMCAmJiB2aWRlby52aWRlb0hlaWdodCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHZpZGVvLnZpZGVvV2lkdGggKyBcInB4IHggXCIgKyB2aWRlby52aWRlb0hlaWdodCArIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrVmlkZW8sIDUwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdVbmFibGUgdG8gcGxheSB2aWRlbyBzdHJlYW0uIElzIHdlYmNhbSB3b3JraW5nPycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dGVtcHRzLS07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWaWRlbygpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY2FtZXJhLXN0cmVhbSB0byBhIGdpdmVuIHZpZGVvLWVsZW1lbnRcbiAqIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgY29udGVudCBpcyByZWFkeVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9cbiAqL1xuZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbywgY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgIC50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbVJlZiA9IHN0cmVhbTtcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShcImF1dG9wbGF5XCIsIHRydWUpO1xuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdtdXRlZCcsIHRydWUpO1xuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsIHRydWUpO1xuICAgICAgICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC50aGVuKHdhaXRGb3JWaWRlby5iaW5kKG51bGwsIHZpZGVvKSk7XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHBpY2sodmlkZW9Db25zdHJhaW50cywgW1wid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJmYWNpbmdNb2RlXCIsXG4gICAgICAgICAgICBcImFzcGVjdFJhdGlvXCIsIFwiZGV2aWNlSWRcIl0pO1xuXG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbyA+IDApIHtcbiAgICAgICAgbm9ybWFsaXplZC5hc3BlY3RSYXRpbyA9IHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW87XG4gICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogQ29uc3RyYWludCAnbWluQXNwZWN0UmF0aW8nIGlzIGRlcHJlY2F0ZWQ7IFVzZSAnYXNwZWN0UmF0aW8nIGluc3RlYWRcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5mYWNpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuZmFjaW5nTW9kZSA9IHZpZGVvQ29uc3RyYWludHMuZmFjaW5nO1xuICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IENvbnN0cmFpbnQgJ2ZhY2luZycgaXMgZGVwcmVjYXRlZC4gVXNlICdmYWNpbmdNb2RlJyBpbnN0ZWFkJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRDb25zdHJhaW50cyA9IHtcbiAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICB2aWRlbzogZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpXG4gICAgfTtcblxuICAgIGlmIChub3JtYWxpemVkQ29uc3RyYWludHMudmlkZW8uZGV2aWNlSWRcbiAgICAgICAgICAgICYmIG5vcm1hbGl6ZWRDb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlKSB7XG4gICAgICAgIGRlbGV0ZSBub3JtYWxpemVkQ29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShub3JtYWxpemVkQ29uc3RyYWludHMpO1xufVxuXG5mdW5jdGlvbiBlbnVtZXJhdGVWaWRlb0RldmljZXMoKSB7XG4gICAgcmV0dXJuIGVudW1lcmF0ZURldmljZXMoKVxuICAgIC50aGVuKGRldmljZXMgPT4gZGV2aWNlcy5maWx0ZXIoZGV2aWNlID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlVHJhY2soKSB7XG4gICAgaWYgKHN0cmVhbVJlZikge1xuICAgICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKHRyYWNrcyAmJiB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2tzWzBdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcmVxdWVzdDogZnVuY3Rpb24odmlkZW8sIHZpZGVvQ29uc3RyYWludHMpIHtcbiAgICAgICAgcmV0dXJuIHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKVxuICAgICAgICAgICAgLnRoZW4oaW5pdENhbWVyYS5iaW5kKG51bGwsIHZpZGVvKSk7XG4gICAgfSxcbiAgICByZWxlYXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRyYWNrcyA9IHN0cmVhbVJlZiAmJiBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKHRyYWNrcyAmJiB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmFja3NbMF0uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVJlZiA9IG51bGw7XG4gICAgfSxcbiAgICBlbnVtZXJhdGVWaWRlb0RldmljZXMsXG4gICAgZ2V0QWN0aXZlU3RyZWFtTGFiZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XG4gICAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmxhYmVsIDogJyc7XG4gICAgfSxcbiAgICBnZXRBY3RpdmVUcmFja1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLmpzIiwiLy8gU2NyYXBlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanNcblxuY29uc3QgRXhpZlRhZ3MgPSB7MHgwMTEyOiBcIm9yaWVudGF0aW9uXCJ9O1xuZXhwb3J0IGNvbnN0IEF2YWlsYWJsZVRhZ3MgPSBPYmplY3Qua2V5cyhFeGlmVGFncykubWFwKGtleSA9PiBFeGlmVGFnc1trZXldKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5PYmplY3RVUkwoc3JjLCB0YWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGlmICgvXmJsb2JcXDovaS50ZXN0KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFVSTFRvQmxvYihzcmMpXG4gICAgICAgICAgICAudGhlbihyZWFkVG9CdWZmZXIpXG4gICAgICAgICAgICAudGhlbihidWZmZXIgPT4gZmluZFRhZ3NJbkJ1ZmZlcihidWZmZXIsIHRhZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoZGF0YVVybCkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGRhdGFVcmwucmVwbGFjZSgvXmRhdGFcXDooW15cXDtdKylcXDtiYXNlNjQsL2dtaSwgJycpLFxuICAgICAgICBiaW5hcnkgPSBhdG9iKGJhc2U2NCksXG4gICAgICAgIGxlbiA9IGJpbmFyeS5sZW5ndGgsXG4gICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pLFxuICAgICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmlld1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiByZWFkVG9CdWZmZXIoYmxvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VVJMVG9CbG9iKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgaHR0cC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gICAgICAgIGh0dHAucmVzcG9uc2VUeXBlID0gXCJibG9iXCI7XG4gICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGh0dHAucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiAoaHR0cC5zdGF0dXMgPT09IDIwMCB8fCBodHRwLnN0YXR1cyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBodHRwLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGh0dHAuc2VuZCgpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbkJ1ZmZlcihmaWxlLCBzZWxlY3RlZFRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSksXG4gICAgICAgIGxlbmd0aCA9IGZpbGUuYnl0ZUxlbmd0aCxcbiAgICAgICAgZXhpZlRhZ3MgPSBzZWxlY3RlZFRhZ3MucmVkdWNlKChyZXN1bHQsIHNlbGVjdGVkVGFnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlmVGFnID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLmZpbHRlcih0YWcgPT4gRXhpZlRhZ3NbdGFnXSA9PT0gc2VsZWN0ZWRUYWcpWzBdO1xuICAgICAgICAgICAgaWYgKGV4aWZUYWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbZXhpZlRhZ10gPSBzZWxlY3RlZFRhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIHt9KTtcbiAgICBsZXQgb2Zmc2V0ID0gMixcbiAgICAgICAgbWFya2VyO1xuXG4gICAgaWYgKChkYXRhVmlldy5nZXRVaW50OCgwKSAhPT0gMHhGRikgfHwgKGRhdGFWaWV3LmdldFVpbnQ4KDEpICE9PSAweEQ4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4RTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRVhJRkRhdGEoZGF0YVZpZXcsIG9mZnNldCArIDQsIGV4aWZUYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCArPSAyICsgZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkRVhJRkRhdGEoZmlsZSwgc3RhcnQsIGV4aWZUYWdzKSB7XG4gICAgaWYgKGdldFN0cmluZ0Zyb21CdWZmZXIoZmlsZSwgc3RhcnQsIDQpICE9PSBcIkV4aWZcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGlmZk9mZnNldCA9IHN0YXJ0ICsgNjtcbiAgICBsZXQgYmlnRW5kLFxuICAgICAgICB0YWdzO1xuXG4gICAgaWYgKGZpbGUuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0RDREKSB7XG4gICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyQSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBmaWxlLmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGFncyA9IHJlYWRUYWdzKGZpbGUsIHRpZmZPZmZzZXQsIHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldCwgZXhpZlRhZ3MsIGJpZ0VuZCk7XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdzKGZpbGUsIHRpZmZTdGFydCwgZGlyU3RhcnQsIHN0cmluZ3MsIGJpZ0VuZCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmaWxlLmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCksXG4gICAgICAgIHRhZ3MgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5T2Zmc2V0ID0gZGlyU3RhcnQgKyBpICogMTIgKyAyLFxuICAgICAgICAgICAgdGFnID0gc3RyaW5nc1tmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCwgIWJpZ0VuZCldO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICB0YWdzW3RhZ10gPSByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdWYWx1ZShmaWxlLCBlbnRyeU9mZnNldCwgdGlmZlN0YXJ0LCBkaXJTdGFydCwgYmlnRW5kKSB7XG4gICAgY29uc3QgdHlwZSA9IGZpbGUuZ2V0VWludDE2KGVudHJ5T2Zmc2V0ICsgMiwgIWJpZ0VuZCksXG4gICAgICAgIG51bVZhbHVlcyA9IGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIDM6XG4gICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBvdXRzdHIgPSBcIlwiO1xuICAgIGZvciAobGV0IG4gPSBzdGFydDsgbiA8IHN0YXJ0ICsgbGVuZ3RoOyBuKyspIHtcbiAgICAgICAgb3V0c3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyLmdldFVpbnQ4KG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHN0cjtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbnB1dC9leGlmX2hlbHBlci5qcyIsImltcG9ydCB7XG4gICAgaW1hZ2VSZWYsXG4gICAgZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YSxcbiAgICBjb21wdXRlR3JheVxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuXG5jb25zdCBUT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShjYW52YXMsIHRhcmdldFNpemUpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSB0YXJnZXRTaXplLngpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRTaXplLng7XG4gICAgfVxuICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9PSB0YXJnZXRTaXplLnkpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGFyZ2V0U2l6ZS55O1xuICAgIH1cbn1cblxudmFyIEZyYW1lR3JhYmJlciA9IHt9O1xuXG5GcmFtZUdyYWJiZXIuY3JlYXRlID0gZnVuY3Rpb24oaW5wdXRTdHJlYW0sIGNhbnZhcykge1xuICAgIHZhciBfdGhhdCA9IHt9LFxuICAgICAgICBfc3RyZWFtQ29uZmlnID0gaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCksXG4gICAgICAgIF92aWRlb19zaXplID0gaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0UmVhbFdpZHRoKCksIGlucHV0U3RyZWFtLmdldFJlYWxIZWlnaHQoKSksXG4gICAgICAgIF9jYW52YXNTaXplID0gaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICBfc2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFdpZHRoKCksIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKSxcbiAgICAgICAgdG9wUmlnaHQgPSBpbnB1dFN0cmVhbS5nZXRUb3BSaWdodCgpLFxuICAgICAgICBfc3ggPSB0b3BSaWdodC54LFxuICAgICAgICBfc3kgPSB0b3BSaWdodC55LFxuICAgICAgICBfY2FudmFzLFxuICAgICAgICBfY3R4ID0gbnVsbCxcbiAgICAgICAgX2RhdGEgPSBudWxsO1xuXG4gICAgX2NhbnZhcyA9IGNhbnZhcyA/IGNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgX2NhbnZhcy53aWR0aCA9IF9jYW52YXNTaXplLng7XG4gICAgX2NhbnZhcy5oZWlnaHQgPSBfY2FudmFzU2l6ZS55O1xuICAgIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBfZGF0YSA9IG5ldyBVaW50OEFycmF5KF9zaXplLnggKiBfc2l6ZS55KTtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRnJhbWVHcmFiYmVyXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNpemU6IF9zaXplLFxuICAgICAgICAgICAgdG9wUmlnaHQ6IHRvcFJpZ2h0LFxuICAgICAgICAgICAgdmlkZW9TaXplOiBfdmlkZW9fc2l6ZSxcbiAgICAgICAgICAgIGNhbnZhc1NpemU6IF9jYW52YXNTaXplXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBnaXZlbiBhcnJheSBhcyBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5hdHRhY2hEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBfZGF0YSA9IGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVzZWQgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmcmFtZSBmcm9tIHRoZSBpbnB1dC1zdHJlYW0gYW5kIHB1dHMgaW50byB0aGUgZnJhbWUtYnVmZmVyLlxuICAgICAqIFRoZSBpbWFnZS1kYXRhIGlzIGNvbnZlcnRlZCB0byBncmF5LXNjYWxlIGFuZCB0aGVuIGhhbGYtc2FtcGxlZCBpZiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvSGFsZlNhbXBsZSA9IF9zdHJlYW1Db25maWcuaGFsZlNhbXBsZSxcbiAgICAgICAgICAgIGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKSxcbiAgICAgICAgICAgIGRyYXdhYmxlID0gZnJhbWUsXG4gICAgICAgICAgICBkcmF3QW5nbGUgPSAwLFxuICAgICAgICAgICAgY3R4RGF0YTtcbiAgICAgICAgaWYgKGRyYXdhYmxlKSB7XG4gICAgICAgICAgICBhZGp1c3RDYW52YXNTaXplKF9jYW52YXMsIF9jYW52YXNTaXplKTtcbiAgICAgICAgICAgIGlmIChfc3RyZWFtQ29uZmlnLnR5cGUgPT09ICdJbWFnZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZSA9IGZyYW1lLmltZztcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUudGFncyAmJiBmcmFtZS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSA5MCAqIFRPX1JBRElBTlM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gLTkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJhd0FuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgICAgICBfY3R4LnJvdGF0ZShkcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAtX2NhbnZhc1NpemUueSAvIDIsIC1fY2FudmFzU2l6ZS54IC8gMiwgX2NhbnZhc1NpemUueSwgX2NhbnZhc1NpemUueCk7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoLWRyYXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoLV9jYW52YXNTaXplLnggLyAyLCAtX2NhbnZhc1NpemUueSAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgMCwgMCwgX2NhbnZhc1NpemUueCwgX2NhbnZhc1NpemUueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eERhdGEgPSBfY3R4LmdldEltYWdlRGF0YShfc3gsIF9zeSwgX3NpemUueCwgX3NpemUueSkuZGF0YTtcbiAgICAgICAgICAgIGlmIChkb0hhbGZTYW1wbGUpe1xuICAgICAgICAgICAgICAgIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEoY3R4RGF0YSwgX3NpemUsIF9kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgX2RhdGEsIF9zdHJlYW1Db25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoYXQuZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhhdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZyYW1lR3JhYmJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbnB1dC9mcmFtZV9ncmFiYmVyLmpzIiwiaW1wb3J0IHtmaW5kVGFnc0luT2JqZWN0VVJMfSBmcm9tICcuL2V4aWZfaGVscGVyJztcblxudmFyIEltYWdlTG9hZGVyID0ge307XG5JbWFnZUxvYWRlci5sb2FkID0gZnVuY3Rpb24oZGlyZWN0b3J5LCBjYWxsYmFjaywgb2Zmc2V0LCBzaXplLCBzZXF1ZW5jZSkge1xuICAgIHZhciBodG1sSW1hZ2VzU3JjQXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSksXG4gICAgICAgIGh0bWxJbWFnZXNBcnJheSA9IG5ldyBBcnJheShodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoKSxcbiAgICAgICAgaSxcbiAgICAgICAgaW1nLFxuICAgICAgICBudW07XG5cbiAgICBpZiAoc2VxdWVuY2UgPT09IGZhbHNlKSB7XG4gICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVswXSA9IGRpcmVjdG9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbnVtID0gKG9mZnNldCArIGkpO1xuICAgICAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5W2ldID0gZGlyZWN0b3J5ICsgXCJpbWFnZS1cIiArIChcIjAwXCIgKyBudW0pLnNsaWNlKC0zKSArIFwiLmpwZ1wiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQgPSBbXTtcbiAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UgPSBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkLnB1c2goaW1hZ2UpO1xuICAgIH07XG4gICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCA9IGZ1bmN0aW9uKGxvYWRlZEltZykge1xuICAgICAgICB2YXIgbm90bG9hZGVkSW1ncyA9IGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQ7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbm90bG9hZGVkSW1ncy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3NbeF0gPT09IGxvYWRlZEltZykge1xuICAgICAgICAgICAgICAgIG5vdGxvYWRlZEltZ3Muc3BsaWNlKHgsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWdOYW1lID0gaHRtbEltYWdlc1NyY0FycmF5W3ldLnN1YnN0cihodG1sSW1hZ2VzU3JjQXJyYXlbeV0ubGFzdEluZGV4T2YoXCIvXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZEltZy5zcmMubGFzdEluZGV4T2YoaW1nTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbeV0gPSB7aW1nOiBsb2FkZWRJbWd9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbWFnZXMgbG9hZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZpbmRUYWdzSW5PYmplY3RVUkwoZGlyZWN0b3J5LCBbJ29yaWVudGF0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRhZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5WzBdLnRhZ3MgPSB0YWdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoIGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UoaW1nKTtcbiAgICAgICAgYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgIGltZy5zcmMgPSBodG1sSW1hZ2VzU3JjQXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSkge1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCh0aGlzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCAoSW1hZ2VMb2FkZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2lucHV0L2ltYWdlX2xvYWRlci5qcyIsImltcG9ydCBJbWFnZUxvYWRlciBmcm9tICcuL2ltYWdlX2xvYWRlcic7XG5cbnZhciBJbnB1dFN0cmVhbSA9IHt9O1xuSW5wdXRTdHJlYW0uY3JlYXRlVmlkZW9TdHJlYW0gPSBmdW5jdGlvbih2aWRlbykge1xuICAgIHZhciB0aGF0ID0ge30sXG4gICAgICAgIF9jb25maWcgPSBudWxsLFxuICAgICAgICBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ10sXG4gICAgICAgIF9ldmVudEhhbmRsZXJzID0ge30sXG4gICAgICAgIF9jYWxjdWxhdGVkV2lkdGgsXG4gICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0LFxuICAgICAgICBfdG9wUmlnaHQgPSB7eDogMCwgeTogMH0sXG4gICAgICAgIF9jYW52YXNTaXplID0ge3g6IDAsIHk6IDB9O1xuXG4gICAgZnVuY3Rpb24gaW5pdFNpemUoKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodDtcblxuICAgICAgICBfY2FsY3VsYXRlZFdpZHRoID1cbiAgICAgICAgICAgIF9jb25maWcuc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgX2NhbGN1bGF0ZWRIZWlnaHQgPVxuICAgICAgICAgICAgX2NvbmZpZy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gTWF0aC5mbG9vcigoaGVpZ2h0IC8gd2lkdGgpICogX2NvbmZpZy5zaXplKSA6IF9jb25maWcuc2l6ZSA6IGhlaWdodDtcblxuICAgICAgICBfY2FudmFzU2l6ZS54ID0gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgX2NhbnZhc1NpemUueSA9IF9jYWxjdWxhdGVkSGVpZ2h0O1xuICAgIH1cblxuICAgIHRoYXQuZ2V0UmVhbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2aWRlby52aWRlb1dpZHRoO1xuICAgIH07XG5cbiAgICB0aGF0LmdldFJlYWxIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZpZGVvLnZpZGVvSGVpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY2FsY3VsYXRlZFdpZHRoO1xuICAgIH07XG5cbiAgICB0aGF0LmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0V2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICBfY2FsY3VsYXRlZFdpZHRoID0gd2lkdGg7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LnNldElucHV0U3RyZWFtID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgIHZpZGVvLnNyYyA9ICh0eXBlb2YgY29uZmlnLnNyYyAhPT0gJ3VuZGVmaW5lZCcpID8gY29uZmlnLnNyYyA6ICcnO1xuICAgIH07XG5cbiAgICB0aGF0LmVuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2aWRlby5lbmRlZDtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgdGhhdC5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgIH07XG5cbiAgICB0aGF0LnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgIH07XG5cbiAgICB0aGF0LnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICBpZiAoX2NvbmZpZy50eXBlICE9PSBcIkxpdmVTdHJlYW1cIikge1xuICAgICAgICAgICAgdmlkZW8uY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoYXQuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmLCBib29sKSB7XG4gICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYsIGJvb2wpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoYXQuY2xlYXJFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9ldmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhhdC50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgIHZhciBqLFxuICAgICAgICAgICAgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjYW5yZWNvcmQnKSB7XG4gICAgICAgICAgICBpbml0U2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkodGhhdCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhhdC5zZXRUb3BSaWdodCA9IGZ1bmN0aW9uKHRvcFJpZ2h0KSB7XG4gICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgIH07XG5cbiAgICB0aGF0LmdldFRvcFJpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0Q2FudmFzU2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgX2NhbnZhc1NpemUueCA9IHNpemUueDtcbiAgICAgICAgX2NhbnZhc1NpemUueSA9IHNpemUueTtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRDYW52YXNTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmlkZW87XG4gICAgfTtcblxuICAgIHJldHVybiB0aGF0O1xufTtcblxuSW5wdXRTdHJlYW0uY3JlYXRlTGl2ZVN0cmVhbSA9IGZ1bmN0aW9uKHZpZGVvKSB7XG4gICAgdmlkZW8uc2V0QXR0cmlidXRlKFwiYXV0b3BsYXlcIiwgdHJ1ZSk7XG4gICAgdmFyIHRoYXQgPSBJbnB1dFN0cmVhbS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk7XG5cbiAgICB0aGF0LmVuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoYXQ7XG59O1xuXG5JbnB1dFN0cmVhbS5jcmVhdGVJbWFnZVN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0ge307XG4gICAgdmFyIF9jb25maWcgPSBudWxsO1xuXG4gICAgdmFyIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgZnJhbWVJZHggPSAwLFxuICAgICAgICBwYXVzZWQgPSB0cnVlLFxuICAgICAgICBsb2FkZWQgPSBmYWxzZSxcbiAgICAgICAgaW1nQXJyYXkgPSBudWxsLFxuICAgICAgICBzaXplID0gMCxcbiAgICAgICAgb2Zmc2V0ID0gMSxcbiAgICAgICAgYmFzZVVybCA9IG51bGwsXG4gICAgICAgIGVuZGVkID0gZmFsc2UsXG4gICAgICAgIGNhbGN1bGF0ZWRXaWR0aCxcbiAgICAgICAgY2FsY3VsYXRlZEhlaWdodCxcbiAgICAgICAgX2V2ZW50TmFtZXMgPSBbJ2NhbnJlY29yZCcsICdlbmRlZCddLFxuICAgICAgICBfZXZlbnRIYW5kbGVycyA9IHt9LFxuICAgICAgICBfdG9wUmlnaHQgPSB7eDogMCwgeTogMH0sXG4gICAgICAgIF9jYW52YXNTaXplID0ge3g6IDAsIHk6IDB9O1xuXG4gICAgZnVuY3Rpb24gbG9hZEltYWdlcygpIHtcbiAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIEltYWdlTG9hZGVyLmxvYWQoYmFzZVVybCwgZnVuY3Rpb24oaW1ncykge1xuICAgICAgICAgICAgaW1nQXJyYXkgPSBpbWdzO1xuICAgICAgICAgICAgaWYgKGltZ3NbMF0udGFncyAmJiBpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGltZ3NbMF0udGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPVxuICAgICAgICAgICAgICAgIF9jb25maWcuc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPVxuICAgICAgICAgICAgICAgIF9jb25maWcuc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG4gICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgZnJhbWVJZHggPSAwO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoXCJjYW5yZWNvcmRcIiwgW10pO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0sIG9mZnNldCwgc2l6ZSwgX2NvbmZpZy5zZXF1ZW5jZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgICB2YXIgaixcbiAgICAgICAgICAgIGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB0aGF0LnRyaWdnZXIgPSBwdWJsaXNoRXZlbnQ7XG5cbiAgICB0aGF0LmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVkV2lkdGg7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LnNldFdpZHRoID0gZnVuY3Rpb24obmV3V2lkdGgpIHtcbiAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gbmV3V2lkdGg7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0SGVpZ2h0ID0gZnVuY3Rpb24obmV3SGVpZ2h0KSB7XG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0UmVhbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRSZWFsSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0SW5wdXRTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgX2NvbmZpZyA9IHN0cmVhbTtcbiAgICAgICAgaWYgKHN0cmVhbS5zZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJhc2VVcmwgPSBzdHJlYW0uc3JjO1xuICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgIHNpemUgPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRJbWFnZXMoKTtcbiAgICB9O1xuXG4gICAgdGhhdC5lbmRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIHRoYXQuZ2V0Q29uZmlnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgIH07XG5cbiAgICB0aGF0LnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIHRoYXQucGxheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhhdC5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgIH07XG5cbiAgICB0aGF0LmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZikge1xuICAgICAgICBpZiAoX2V2ZW50TmFtZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhhdC5zZXRUb3BSaWdodCA9IGZ1bmN0aW9uKHRvcFJpZ2h0KSB7XG4gICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgIH07XG5cbiAgICB0aGF0LmdldFRvcFJpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0Q2FudmFzU2l6ZSA9IGZ1bmN0aW9uKGNhbnZhc1NpemUpIHtcbiAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbnZhc1NpemUueTtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRDYW52YXNTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZnJhbWU7XG5cbiAgICAgICAgaWYgKCFsb2FkZWQpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgIGZyYW1lID0gaW1nQXJyYXlbZnJhbWVJZHhdO1xuICAgICAgICAgICAgaWYgKGZyYW1lSWR4IDwgKHNpemUgLSAxKSkge1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaEV2ZW50KFwiZW5kZWRcIiwgW10pO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoYXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBJbnB1dFN0cmVhbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW0uanMiLCJpbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlUGF0Y2hTaXplLFxuICAgIG90c3VUaHJlc2hvbGQsXG4gICAgaHN2MnJnYixcbiAgICBjbHVzdGVyLFxuICAgIHRvcEdlbmVyaWMsXG4gICAgaW1hZ2VSZWYsXG4gICAgaGFsZlNhbXBsZSxcbiAgICBjb21wdXRlSW1hZ2VBcmVhXG59IGZyb20gJy4uL2NvbW1vbi9jdl91dGlscyc7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IFJhc3Rlcml6ZXIgZnJvbSAnLi9yYXN0ZXJpemVyJztcbmltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuaW1wb3J0IHNrZWxldG9uaXplciBmcm9tICcuL3NrZWxldG9uaXplcic7XG5jb25zdCB2ZWMyID0ge1xuICAgIGNsb25lOiByZXF1aXJlKCdnbC12ZWMyL2Nsb25lJyksXG4gICAgZG90OiAgcmVxdWlyZSgnZ2wtdmVjMi9kb3QnKSxcbiAgICBzY2FsZTogcmVxdWlyZSgnZ2wtdmVjMi9zY2FsZScpLFxuICAgIHRyYW5zZm9ybU1hdDI6IHJlcXVpcmUoJ2dsLXZlYzIvdHJhbnNmb3JtTWF0MicpXG59O1xuY29uc3QgbWF0MiA9IHtcbiAgICBjb3B5OiByZXF1aXJlKCdnbC1tYXQyL2NvcHknKSxcbiAgICBjcmVhdGU6IHJlcXVpcmUoJ2dsLW1hdDIvY3JlYXRlJyksXG4gICAgaW52ZXJ0OiByZXF1aXJlKCdnbC1tYXQyL2ludmVydCcpXG59XG5cbnZhciBfY29uZmlnLFxuICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyLFxuICAgIF9za2VsSW1hZ2VXcmFwcGVyLFxuICAgIF9zdWJJbWFnZVdyYXBwZXIsXG4gICAgX2xhYmVsSW1hZ2VXcmFwcGVyLFxuICAgIF9wYXRjaEdyaWQsXG4gICAgX3BhdGNoTGFiZWxHcmlkLFxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkLFxuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIsXG4gICAgX3BhdGNoU2l6ZSxcbiAgICBfY2FudmFzQ29udGFpbmVyID0ge1xuICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgIGJpbmFyeTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBkb206IHtcbiAgICAgICAgICAgIGJpbmFyeTogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBfbnVtUGF0Y2hlcyA9IHt4OiAwLCB5OiAwfSxcbiAgICBfaW5wdXRJbWFnZVdyYXBwZXIsXG4gICAgX3NrZWxldG9uaXplcjtcblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoKSB7XG4gICAgdmFyIHNrZWxldG9uSW1hZ2VEYXRhO1xuXG4gICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgeDogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCAvIDIgfCAwLFxuICAgICAgICAgICAgeTogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueSAvIDIgfCAwXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gX2lucHV0SW1hZ2VXcmFwcGVyO1xuICAgIH1cblxuICAgIF9wYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoX2NvbmZpZy5wYXRjaFNpemUsIF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUpO1xuXG4gICAgX251bVBhdGNoZXMueCA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueCAvIF9wYXRjaFNpemUueCB8IDA7XG4gICAgX251bVBhdGNoZXMueSA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9wYXRjaFNpemUueSB8IDA7XG5cbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcblxuICAgIF9sYWJlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG5cbiAgICBza2VsZXRvbkltYWdlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcig2NCAqIDEwMjQpO1xuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCAwLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpKTtcbiAgICBfc2tlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXG4gICAgICAgIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3NrZWxldG9uaXplciA9IHNrZWxldG9uaXplcigodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgPyBzZWxmIDogZ2xvYmFsLCB7XG4gICAgICAgIHNpemU6IF9wYXRjaFNpemUueFxuICAgIH0sIHNrZWxldG9uSW1hZ2VEYXRhKTtcblxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxuICAgICAgICB5OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkpIHwgMFxuICAgIH0sIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuICAgIF9wYXRjaEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBfcGF0Y2hMYWJlbEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgSW50MzJBcnJheSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XG4gICAgaWYgKF9jb25maWcudXNlV29ya2VyIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5jbGFzc05hbWUgPSBcImJpbmFyeUJ1ZmZlclwiO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZGVidWdcIikuYXBwZW5kQ2hpbGQoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5KTtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5ID0gX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkud2lkdGggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG1pbmltYWwgYm91bmRpbmcgYm94XG4gKi9cbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcbiAgICB2YXIgb3ZlckF2ZyxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgcGF0Y2gsXG4gICAgICAgIHRyYW5zTWF0LFxuICAgICAgICBtaW54ID1cbiAgICAgICAgX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLngsXG4gICAgICAgIG1pbnkgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueSxcbiAgICAgICAgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueSxcbiAgICAgICAgYm94LFxuICAgICAgICBzY2FsZTtcblxuICAgIC8vIGRyYXcgYWxsIHBhdGNoZXMgd2hpY2ggYXJlIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICAgIG92ZXJBdmcgPSAwO1xuICAgIGZvciAoIGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIG92ZXJBdmcgKz0gcGF0Y2gucmFkO1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoZXMpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwge2NvbG9yOiBcInJlZFwifSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvdmVyQXZnIC89IHBhdGNoZXMubGVuZ3RoO1xuICAgIG92ZXJBdmcgPSAob3ZlckF2ZyAqIDE4MCAvIE1hdGguUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICBpZiAob3ZlckF2ZyA8IDApIHtcbiAgICAgICAgb3ZlckF2ZyArPSAxODA7XG4gICAgfVxuXG4gICAgb3ZlckF2ZyA9ICgxODAgLSBvdmVyQXZnKSAqIE1hdGguUEkgLyAxODA7XG4gICAgdHJhbnNNYXQgPSBtYXQyLmNvcHkobWF0Mi5jcmVhdGUoKSwgW01hdGguY29zKG92ZXJBdmcpLCBNYXRoLnNpbihvdmVyQXZnKSwgLU1hdGguc2luKG92ZXJBdmcpLCBNYXRoLmNvcyhvdmVyQXZnKV0pO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBhdGNoZXMgYW5kIHJvdGF0ZSBieSBhbmdsZVxuICAgIGZvciAoIGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoIGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIocGF0Y2guYm94W2pdLCBwYXRjaC5ib3hbal0sIHRyYW5zTWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgocGF0Y2guYm94LCB7eDogMCwgeTogMX0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwge2NvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMn0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluZCBib3VuZGluZyBib3hcbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVswXSA8IG1pbngpIHtcbiAgICAgICAgICAgICAgICBtaW54ID0gcGF0Y2guYm94W2pdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVswXSA+IG1heHgpIHtcbiAgICAgICAgICAgICAgICBtYXh4ID0gcGF0Y2guYm94W2pdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVsxXSA8IG1pbnkpIHtcbiAgICAgICAgICAgICAgICBtaW55ID0gcGF0Y2guYm94W2pdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVsxXSA+IG1heHkpIHtcbiAgICAgICAgICAgICAgICBtYXh5ID0gcGF0Y2guYm94W2pdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYm94ID0gW1ttaW54LCBtaW55XSwgW21heHgsIG1pbnldLCBbbWF4eCwgbWF4eV0sIFttaW54LCBtYXh5XV07XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd1RyYW5zZm9ybWVkQm94KSB7XG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7eDogMCwgeTogMX0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwge2NvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMn0pO1xuICAgIH1cblxuICAgIHNjYWxlID0gX2NvbmZpZy5oYWxmU2FtcGxlID8gMiA6IDE7XG4gICAgLy8gcmV2ZXJzZSByb3RhdGlvbjtcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XG4gICAgZm9yICggaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi50cmFuc2Zvcm1NYXQyKGJveFtqXSwgYm94W2pdLCB0cmFuc01hdCk7XG4gICAgfVxuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dCQikge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwge3g6IDAsIHk6IDF9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHtjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDJ9KTtcbiAgICB9XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICB2ZWMyLnNjYWxlKGJveFtqXSwgYm94W2pdLCBzY2FsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJveDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmluYXJ5IGltYWdlIG9mIHRoZSBjdXJyZW50IGltYWdlXG4gKi9cbmZ1bmN0aW9uIGJpbmFyaXplSW1hZ2UoKSB7XG4gICAgb3RzdVRocmVzaG9sZChfY3VycmVudEltYWdlV3JhcHBlciwgX2JpbmFyeUltYWdlV3JhcHBlcik7XG4gICAgX2JpbmFyeUltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dDYW52YXMpIHtcbiAgICAgICAgX2JpbmFyeUltYWdlV3JhcHBlci5zaG93KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMjU1KTtcbiAgICB9XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgaW1hZ2VcbiAqIGV4dHJhY3QgcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBmaW5kUGF0Y2hlcygpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgbW9tZW50cyxcbiAgICAgICAgcGF0Y2hlc0ZvdW5kID0gW10sXG4gICAgICAgIHJhc3Rlcml6ZXIsXG4gICAgICAgIHJhc3RlclJlc3VsdCxcbiAgICAgICAgcGF0Y2g7XG4gICAgZm9yIChpID0gMDsgaSA8IF9udW1QYXRjaGVzLng7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX251bVBhdGNoZXMueTsgaisrKSB7XG4gICAgICAgICAgICB4ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnggKiBpO1xuICAgICAgICAgICAgeSA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55ICogajtcblxuICAgICAgICAgICAgLy8gc2VwZXJhdGUgcGFydHNcbiAgICAgICAgICAgIHNrZWxldG9uaXplKHgsIHkpO1xuXG4gICAgICAgICAgICAvLyBSYXN0ZXJpemUsIGZpbmQgaW5kaXZpZHVhbCBiYXJzXG4gICAgICAgICAgICBfc2tlbEltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XG4gICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KF9sYWJlbEltYWdlV3JhcHBlci5kYXRhLCAwKTtcbiAgICAgICAgICAgIHJhc3Rlcml6ZXIgPSBSYXN0ZXJpemVyLmNyZWF0ZShfc2tlbEltYWdlV3JhcHBlciwgX2xhYmVsSW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIHJhc3RlclJlc3VsdCA9IHJhc3Rlcml6ZXIucmFzdGVyaXplKDApO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0xhYmVscykge1xuICAgICAgICAgICAgICAgIF9sYWJlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgTWF0aC5mbG9vcigzNjAgLyByYXN0ZXJSZXN1bHQuY291bnQpLFxuICAgICAgICAgICAgICAgICAgICB7eDogeCwgeTogeX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgbW9tZW50cyBmcm9tIHRoZSBza2VsZXRvbml6ZWQgcGF0Y2hcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGVsaWdpYmxlIHBhdGNoZXNcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Rm91bmRQYXRjaGVzKSB7XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtpXTtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICB7Y29sb3I6IFwiIzk5ZmYwMFwiLCBsaW5lV2lkdGg6IDJ9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhvc2UgY29ubmVjdGVkIGFyZWFzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3QgNiBwYXRjaGVzXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcbiAqL1xuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCl7XG4gICAgdmFyIGksXG4gICAgICAgIHN1bSxcbiAgICAgICAgbGFiZWxIaXN0ID0gW10sXG4gICAgICAgIHRvcExhYmVscyA9IFtdO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XG4gICAgICAgIGxhYmVsSGlzdC5wdXNoKDApO1xuICAgIH1cbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID4gMCkge1xuICAgICAgICAgICAgbGFiZWxIaXN0W19wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gLSAxXSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGFiZWxIaXN0ID0gbGFiZWxIaXN0Lm1hcChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICBsYWJlbDogaWR4ICsgMVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgbGFiZWxIaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYi52YWwgLSBhLnZhbDtcbiAgICB9KTtcblxuICAgIC8vIGV4dHJhY3QgdG9wIGFyZWFzIHdpdGggYXQgbGVhc3QgNiBwYXRjaGVzIHByZXNlbnRcbiAgICB0b3BMYWJlbHMgPSBsYWJlbEhpc3QuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC52YWwgPj0gNTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0b3BMYWJlbHM7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgc3VtLFxuICAgICAgICBwYXRjaGVzID0gW10sXG4gICAgICAgIHBhdGNoLFxuICAgICAgICBib3gsXG4gICAgICAgIGJveGVzID0gW10sXG4gICAgICAgIGhzdiA9IFswLCAxLCAxXSxcbiAgICAgICAgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCB0b3BMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgICAgICBwYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHdoaWxlIChzdW0tLSkge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPT09IHRvcExhYmVsc1tpXS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtzdW1dO1xuICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm94ID0gYm94RnJvbVBhdGNoZXMocGF0Y2hlcyk7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICAgIGJveGVzLnB1c2goYm94KTtcblxuICAgICAgICAgICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaHN2WzBdID0gKHRvcExhYmVsc1tpXS5sYWJlbCAvIChtYXhMYWJlbCArIDEpKSAqIDM2MDtcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvcjogXCJyZ2IoXCIgKyByZ2Iuam9pbihcIixcIikgKyBcIilcIiwgbGluZVdpZHRoOiAyfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlcztcbn1cblxuLyoqXG4gKiBGaW5kIHNpbWlsYXIgbW9tZW50cyAodmlhIGNsdXN0ZXIpXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xuICovXG5mdW5jdGlvbiBzaW1pbGFyTW9tZW50cyhtb21lbnRzKSB7XG4gICAgdmFyIGNsdXN0ZXJzID0gY2x1c3Rlcihtb21lbnRzLCAwLjkwKTtcbiAgICB2YXIgdG9wQ2x1c3RlciA9IHRvcEdlbmVyaWMoY2x1c3RlcnMsIDEsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuZ2V0UG9pbnRzKCkubGVuZ3RoO1xuICAgIH0pO1xuICAgIHZhciBwb2ludHMgPSBbXSwgcmVzdWx0ID0gW107XG4gICAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBvaW50cyA9IHRvcENsdXN0ZXJbMF0uaXRlbS5nZXRQb2ludHMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpXS5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc3ViSW1hZ2VBc0NvcHkoX3N1YkltYWdlV3JhcHBlciwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcblxuICAgIC8vIFNob3cgc2tlbGV0b24gaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xuICAgICAgICBfc2tlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMzYwLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaFBvcyxcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xuICAgIHZhciBrLFxuICAgICAgICBhdmcsXG4gICAgICAgIGVsaWdpYmxlTW9tZW50cyA9IFtdLFxuICAgICAgICBtYXRjaGluZ01vbWVudHMsXG4gICAgICAgIHBhdGNoLFxuICAgICAgICBwYXRjaGVzRm91bmQgPSBbXSxcbiAgICAgICAgbWluQ29tcG9uZW50V2VpZ2h0ID0gTWF0aC5jZWlsKF9wYXRjaFNpemUueCAvIDMpO1xuXG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgLy8gb25seSBjb2xsZWN0IG1vbWVudHMgd2hpY2gncyBhcmVhIGNvdmVycyBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHQgcGl4ZWxzLlxuICAgICAgICBmb3IgKCBrID0gMDsgayA8IG1vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2tdLm0wMCA+IG1pbkNvbXBvbmVudFdlaWdodCkge1xuICAgICAgICAgICAgICAgIGVsaWdpYmxlTW9tZW50cy5wdXNoKG1vbWVudHNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXQgbGVhc3QgMiBtb21lbnRzIGFyZSBmb3VuZCB3aGljaCBoYXZlIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodHMgY292ZXJlZFxuICAgICAgICBpZiAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBtYXRjaGluZ01vbWVudHMgPSBzaW1pbGFyTW9tZW50cyhlbGlnaWJsZU1vbWVudHMpO1xuICAgICAgICAgICAgYXZnID0gMDtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgc2ltaWxhcml0eSBvZiB0aGUgbW9tZW50c1xuICAgICAgICAgICAgZm9yICggayA9IDA7IGsgPCBtYXRjaGluZ01vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBhdmcgKz0gbWF0Y2hpbmdNb21lbnRzW2tdLnJhZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSB0d28gb2YgdGhlIG1vbWVudHMgYXJlIGFsbG93ZWQgbm90IHRvIGZpdCBpbnRvIHRoZSBlcXVhdGlvblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBwYXRjaCB0byB0aGUgc2V0XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+PSAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCAvIDQpICogM1xuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gbW9tZW50cy5sZW5ndGggLyA0KSB7XG4gICAgICAgICAgICAgICAgYXZnIC89IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXRjaFBvc1sxXSAqIF9udW1QYXRjaGVzLnggKyBwYXRjaFBvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3g6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcmFkOiBhdmcsXG4gICAgICAgICAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbTWF0aC5jb3MoYXZnKSwgTWF0aC5zaW4oYXZnKV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzRm91bmQucHVzaChwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBmaW5kcyBwYXRjaGVzIHdoaWNoIGFyZSBjb25uZWN0ZWQgYW5kIHNoYXJlIHRoZSBzYW1lIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hlc0ZvdW5kXG4gKi9cbmZ1bmN0aW9uIHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCkge1xuICAgIHZhciBsYWJlbCA9IDAsXG4gICAgICAgIHRocmVzaG9sZCA9IDAuOTUsXG4gICAgICAgIGN1cnJJZHggPSAwLFxuICAgICAgICBqLFxuICAgICAgICBwYXRjaCxcbiAgICAgICAgaHN2ID0gWzAsIDEsIDFdLFxuICAgICAgICByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmdW5jdGlvbiBub3RZZXRQcm9jZXNzZWQoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wYXRjaExhYmVsR3JpZC5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xuICAgICAgICB2YXIgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBjdXJyZW50UGF0Y2gsXG4gICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICBjdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIHg6IGN1cnJlbnRJZHggJSBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54LFxuICAgICAgICAgICAgICAgIHk6IChjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCkgfCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2ltaWxhcml0eTtcblxuICAgICAgICBpZiAoY3VycmVudElkeCA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtjdXJyZW50SWR4XTtcbiAgICAgICAgICAgIC8vIGFzc2lnbiBsYWJlbFxuICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbY3VycmVudElkeF0gPSBsYWJlbDtcbiAgICAgICAgICAgIGZvciAoIGRpciA9IDA7IGRpciA8IFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgZGlyKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC55ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC54ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBpZHggPSB5ICogX3BhdGNoTGFiZWxHcmlkLnNpemUueCArIHg7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBpZiBwYXRjaCBlbXB0eVxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbaWR4XS52ZWMsIGN1cnJlbnRQYXRjaC52ZWMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGZvciBmaW5kaW5nIHRoZSByaWdodCBwYXRjaGVzXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoTGFiZWxHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YSwgbnVsbCk7XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtqXTtcbiAgICAgICAgX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSBwYXRjaDtcbiAgICAgICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgLy8gcmFzdGVyaXplIHRoZSBwYXRjaGVzIGZvdW5kIHRvIGRldGVybWluZSBhcmVhXG4gICAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XG5cbiAgICB3aGlsZSAoKCBjdXJySWR4ID0gbm90WWV0UHJvY2Vzc2VkKCkpIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGxhYmVsKys7XG4gICAgICAgIHRyYWNlKGN1cnJJZHgpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hMYWJlbHMpIHtcbiAgICAgICAgZm9yICggaiA9IDA7IGogPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdID4gMCAmJiBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA8PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtqXTtcbiAgICAgICAgICAgICAgICBoc3ZbMF0gPSAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gLyAobGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICB7Y29sb3I6IFwicmdiKFwiICsgcmdiLmpvaW4oXCIsXCIpICsgXCIpXCIsIGxpbmVXaWR0aDogMn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdDogZnVuY3Rpb24oaW5wdXRJbWFnZVdyYXBwZXIsIGNvbmZpZykge1xuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcblxuICAgICAgICBpbml0QnVmZmVycygpO1xuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgfSxcblxuICAgIGxvY2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXRjaGVzRm91bmQsXG4gICAgICAgICAgICB0b3BMYWJlbHMsXG4gICAgICAgICAgICBib3hlcztcblxuICAgICAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICBoYWxmU2FtcGxlKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluYXJpemVJbWFnZSgpO1xuICAgICAgICBwYXRjaGVzRm91bmQgPSBmaW5kUGF0Y2hlcygpO1xuICAgICAgICAvLyByZXR1cm4gdW5sZXNzIDUlIG9yIG1vcmUgcGF0Y2hlcyBhcmUgZm91bmRcbiAgICAgICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFzdGVycml6ZSBhcmVhIGJ5IGNvbXBhcmluZyBhbmd1bGFyIHNpbWlsYXJpdHk7XG4gICAgICAgIHZhciBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XG4gICAgICAgIGlmIChtYXhMYWJlbCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcbiAgICAgICAgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XG4gICAgICAgIGlmICh0b3BMYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJveGVzID0gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpO1xuICAgICAgICByZXR1cm4gYm94ZXM7XG4gICAgfSxcblxuICAgIGNoZWNrSW1hZ2VDb25zdHJhaW50czogZnVuY3Rpb24oaW5wdXRTdHJlYW0sIGNvbmZpZykge1xuICAgICAgICB2YXIgcGF0Y2hTaXplLFxuICAgICAgICAgICAgd2lkdGggPSBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICBoYWxmU2FtcGxlID0gY29uZmlnLmhhbGZTYW1wbGUgPyAwLjUgOiAxLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGFyZWE7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gYXJlYVxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSkge1xuICAgICAgICAgICAgYXJlYSA9IGNvbXB1dGVJbWFnZUFyZWEod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7eDogYXJlYS5zeCwgeTogYXJlYS5zeX0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7eDogd2lkdGgsIHk6IGhlaWdodH0pO1xuICAgICAgICAgICAgd2lkdGggPSBhcmVhLnN3O1xuICAgICAgICAgICAgaGVpZ2h0ID0gYXJlYS5zaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpemUgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLmZsb29yKHdpZHRoICogaGFsZlNhbXBsZSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGhlaWdodCAqIGhhbGZTYW1wbGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgcGF0Y2hTaXplID0gY2FsY3VsYXRlUGF0Y2hTaXplKGNvbmZpZy5wYXRjaFNpemUsIHNpemUpO1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBhdGNoLVNpemU6IFwiICsgSlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRXaWR0aChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS54IC8gcGF0Y2hTaXplLngpICogKDEgLyBoYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSk7XG4gICAgICAgIGlucHV0U3RyZWFtLnNldEhlaWdodChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS55IC8gcGF0Y2hTaXplLnkpICogKDEgLyBoYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS55KSk7XG5cbiAgICAgICAgaWYgKChpbnB1dFN0cmVhbS5nZXRXaWR0aCgpICUgcGF0Y2hTaXplLngpID09PSAwICYmIChpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSAlIHBhdGNoU2l6ZS55KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKFwiICtcbiAgICAgICAgICAgIHdpZHRoICsgXCIgKWFuZCBoZWlnaHQgKFwiICsgaGVpZ2h0ICtcbiAgICAgICAgICAgIFwiKSBtdXN0IGEgbXVsdGlwbGUgb2YgXCIgKyBwYXRjaFNpemUueCk7XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvci5qcyIsImltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuXG4vKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xudmFyIFJhc3Rlcml6ZXIgPSB7XG4gICAgY3JlYXRlQ29udG91cjJEOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcjogbnVsbCxcbiAgICAgICAgICAgIGluZGV4OiBudWxsLFxuICAgICAgICAgICAgZmlyc3RWZXJ0ZXg6IG51bGwsXG4gICAgICAgICAgICBpbnNpZGVDb250b3VyczogbnVsbCxcbiAgICAgICAgICAgIG5leHRwZWVyOiBudWxsLFxuICAgICAgICAgICAgcHJldnBlZXI6IG51bGxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIENPTlRPVVJfRElSOiB7XG4gICAgICAgIENXX0RJUjogMCxcbiAgICAgICAgQ0NXX0RJUjogMSxcbiAgICAgICAgVU5LTk9XTl9ESVI6IDJcbiAgICB9LFxuICAgIERJUjoge1xuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcbiAgICAgICAgSU5TSURFX0VER0U6IC0zMjc2NlxuICAgIH0sXG4gICAgY3JlYXRlOiBmdW5jdGlvbihpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgICAgIGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnksXG4gICAgICAgICAgICB0cmFjZXIgPSBUcmFjZXIuY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFzdGVyaXplOiBmdW5jdGlvbihkZXB0aGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBiYyxcbiAgICAgICAgICAgICAgICAgICAgbGMsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGN4LFxuICAgICAgICAgICAgICAgICAgICBjeSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4LFxuICAgICAgICAgICAgICAgICAgICBwLFxuICAgICAgICAgICAgICAgICAgICBjYyxcbiAgICAgICAgICAgICAgICAgICAgc2MsXG4gICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQ291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCA0MDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sb3JNYXBbMF0gPSBpbWFnZURhdGFbMF07XG4gICAgICAgICAgICAgICAgY2MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAoIGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBjeCA9IDE7IGN4IDwgd2lkdGggLSAxOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBjeSAqIHdpZHRoICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPT0gYmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxjID0gY29ubmVjdGVkQ291bnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbbGNdID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgbGMsIGNvbG9yLCBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UsIGNvbG9yLCBsYWJlbGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aGxhYmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChzYyAhPT0gbnVsbCkgJiYgc2MuaW5kZXggIT09IGxhYmVsaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBzYy5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjLmluc2lkZUNvbnRvdXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGFiZWxEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFtsYWJlbGluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYy5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNjOiBjYyxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvbm5lY3RlZENvdW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgICAgIGRyYXdDb250b3VyOiBmdW5jdGlvbihjYW52YXMsIGZpcnN0Q29udG91cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gZmlyc3RDb250b3VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXEsXG4gICAgICAgICAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcDtcblxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gaXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBpcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gcHEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChxLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJibHVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuVU5LTk9XTl9ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJncmVlblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwICE9PSBxLmZpcnN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSYXN0ZXJpemVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvY2F0b3IvcmFzdGVyaXplci5qcyIsIi8qIEBwcmVzZXJ2ZSBBU00gQkVHSU4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSovXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgICBcInVzZSBhc21cIjtcblxuICAgIHZhciBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKSxcbiAgICAgICAgc2l6ZSA9IGZvcmVpZ24uc2l6ZSB8IDAsXG4gICAgICAgIGltdWwgPSBzdGRsaWIuTWF0aC5pbXVsO1xuXG4gICAgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciA9IGluSW1hZ2VQdHIgfCAwO1xuICAgICAgICBvdXRJbWFnZVB0ciA9IG91dEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgdiA9IDAsXG4gICAgICAgICAgICB1ID0gMCxcbiAgICAgICAgICAgIHN1bSA9IDAsXG4gICAgICAgICAgICB5U3RhcnQxID0gMCxcbiAgICAgICAgICAgIHlTdGFydDIgPSAwLFxuICAgICAgICAgICAgeFN0YXJ0MSA9IDAsXG4gICAgICAgICAgICB4U3RhcnQyID0gMCxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggdiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKCB1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPT0gKDUgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciA9IGFJbWFnZVB0ciB8IDA7XG4gICAgICAgIGJJbWFnZVB0ciA9IGJJbWFnZVB0ciB8IDA7XG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9XG4gICAgICAgICAgICAgICAgKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIC0gKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyID0gYUltYWdlUHRyIHwgMDtcbiAgICAgICAgYkltYWdlUHRyID0gYkltYWdlUHRyIHwgMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgPSBvdXRJbWFnZVB0ciB8IDA7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID1cbiAgICAgICAgICAgICAgICAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgfCAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBzdW0gPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIHN1bSA9ICgoc3VtIHwgMCkgKyAoaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHN1bSB8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQoaW1hZ2VQdHIsIHZhbHVlKSB7XG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHwgMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBpbkltYWdlUHRyID0gaW5JbWFnZVB0ciB8IDA7XG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciB2ID0gMCxcbiAgICAgICAgICAgIHUgPSAwLFxuICAgICAgICAgICAgc3VtID0gMCxcbiAgICAgICAgICAgIHlTdGFydDEgPSAwLFxuICAgICAgICAgICAgeVN0YXJ0MiA9IDAsXG4gICAgICAgICAgICB4U3RhcnQxID0gMCxcbiAgICAgICAgICAgIHhTdGFydDIgPSAwLFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKCB2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAoIHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKChzdW0gfCAwKSA+ICgwIHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcbiAgICAgICAgc3JjSW1hZ2VQdHIgPSBzcmNJbWFnZVB0ciB8IDA7XG4gICAgICAgIGRzdEltYWdlUHRyID0gZHN0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhkc3RJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IChpbWFnZXNbKHNyY0ltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvQm9yZGVyKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwO1xuXG4gICAgICAgIGZvciAoIHggPSAwOyAoeCB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeCkgfCAwXSA9IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKCh5ICsgc2l6ZSkgLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICggeCA9IDA7ICh4IHwgMCkgPCAoc2l6ZSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZWxldG9uaXplKCkge1xuICAgICAgICB2YXIgc3ViSW1hZ2VQdHIgPSAwLFxuICAgICAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSAwLFxuICAgICAgICAgICAgdGVtcEltYWdlUHRyID0gMCxcbiAgICAgICAgICAgIHNrZWxJbWFnZVB0ciA9IDAsXG4gICAgICAgICAgICBzdW0gPSAwLFxuICAgICAgICAgICAgZG9uZSA9IDA7XG5cbiAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgc2tlbEltYWdlUHRyID0gKHRlbXBJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG5cbiAgICAgICAgLy8gaW5pdCBza2VsLWltYWdlXG4gICAgICAgIGluaXQoc2tlbEltYWdlUHRyLCAwKTtcbiAgICAgICAgemVyb0JvcmRlcihzdWJJbWFnZVB0cik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXJvZGUoc3ViSW1hZ2VQdHIsIGVyb2RlZEltYWdlUHRyKTtcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHN1YkltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBiaXR3aXNlT3Ioc2tlbEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHNrZWxJbWFnZVB0cik7XG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1bSA9IGNvdW50Tm9uWmVybyhzdWJJbWFnZVB0cikgfCAwO1xuICAgICAgICAgICAgZG9uZSA9ICgoc3VtIHwgMCkgPT0gMCB8IDApO1xuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNrZWxldG9uaXplOiBza2VsZXRvbml6ZVxuICAgIH07XG59XG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xuZXhwb3J0IGRlZmF1bHQgU2tlbGV0b25pemVyO1xuLyogZXNsaW50LWVuYWJsZSBlcWVxZXEqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmZ1bmN0aW9uIFR3b09mRml2ZVJlYWRlcihvcHRzKSB7XG4gICAgQmFyY29kZVJlYWRlci5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIHRoaXMuYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcbn1cblxudmFyIE4gPSAxLFxuICAgIFcgPSAzLFxuICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIFNUQVJUX1BBVFRFUk46IHt2YWx1ZTogW1csIE4sIFcsIE4sIE4sIE5dfSxcbiAgICAgICAgU1RPUF9QQVRURVJOOiB7dmFsdWU6IFtXLCBOLCBOLCBOLCBXXX0sXG4gICAgICAgIENPREVfUEFUVEVSTjoge3ZhbHVlOiBbXG4gICAgICAgICAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgICAgICAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgICAgICAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgICAgICAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgICAgICAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgICAgICAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgICAgICAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgICAgICAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgICAgICAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgICAgICAgICBbTiwgVywgTiwgVywgTl1cbiAgICAgICAgXX0sXG4gICAgICAgIFNJTkdMRV9DT0RFX0VSUk9SOiB7dmFsdWU6IDAuNzgsIHdyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAgQVZHX0NPREVfRVJST1I6IHt2YWx1ZTogMC4zMCwgd3JpdGFibGU6IHRydWV9LFxuICAgICAgICBGT1JNQVQ6IHt2YWx1ZTogXCIyb2Y1XCJ9XG4gICAgfTtcblxuY29uc3Qgc3RhcnRQYXR0ZXJuTGVuZ3RoID0gcHJvcGVydGllcy5TVEFSVF9QQVRURVJOLnZhbHVlLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCk7XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUd29PZkZpdmVSZWFkZXI7XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2ZpbmRQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIpIHtcbiAgICB2YXIgY291bnRlciA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaixcbiAgICAgICAgc3VtLFxuICAgICAgICBlcHNpbG9uID0gc2VsZi5BVkdfQ09ERV9FUlJPUjtcblxuICAgIGlzV2hpdGUgPSBpc1doaXRlIHx8IGZhbHNlO1xuICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KTtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBzdGFydEluZm8sXG4gICAgICAgIG5hcnJvd0JhcldpZHRoID0gMTtcblxuICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgIHN0YXJ0SW5mbyA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gc3RhcnRQYXR0ZXJuTGVuZ3RoKTtcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogNTtcbiAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICB9XG59O1xuXG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihlbmRJbmZvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2ZpbmRFbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVuZEluZm8sXG4gICAgICAgIHRtcCxcbiAgICAgICAgb2Zmc2V0O1xuXG4gICAgc2VsZi5fcm93LnJldmVyc2UoKTtcbiAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3Jvdyk7XG4gICAgZW5kSW5mbyA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICBzZWxmLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICBlbmRJbmZvLnN0YXJ0ID0gc2VsZi5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgIGVuZEluZm8uZW5kID0gc2VsZi5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gc2VsZi5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2RlY29kZUNvZGUgPSBmdW5jdGlvbihjb3VudGVyKSB7XG4gICAgdmFyIGosXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBub3JtYWxpemVkLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZXBzaWxvbiA9IHNlbGYuQVZHX0NPREVfRVJST1IsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9O1xuXG4gICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgIH1cbiAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgc2VsZi5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgc2VsZi5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgfVxufTtcblxuVHdvT2ZGaXZlUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcykge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgcG9zID0gMCxcbiAgICAgICAgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aCxcbiAgICAgICAgY291bnRlciA9IFswLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgY29kZTtcblxuICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJbaV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY291bnRlcik7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICsgXCJcIik7XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZTtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX3ZlcmlmeUNvdW50ZXJMZW5ndGggPSBmdW5jdGlvbihjb3VudGVycykge1xuICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xufTtcblxuVHdvT2ZGaXZlUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0SW5mbyxcbiAgICAgICAgZW5kSW5mbyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgY291bnRlcnM7XG5cbiAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kU3RhcnQoKTtcbiAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgIGVuZEluZm8gPSBzZWxmLl9maW5kRW5kKCk7XG4gICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvdW50ZXJzID0gc2VsZi5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICBpZiAoIXNlbGYuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb2RlID0gc2VsZi5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPCA1KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXNcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVHdvT2ZGaXZlUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5mdW5jdGlvbiBDb2RhYmFyUmVhZGVyKCkge1xuICAgIEJhcmNvZGVSZWFkZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9jb3VudGVycyA9IFtdO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBBTFBIQUJFVEhfU1RSSU5HOiB7dmFsdWU6IFwiMDEyMzQ1Njc4OS0kOi8uK0FCQ0RcIn0sXG4gICAgQUxQSEFCRVQ6IHt2YWx1ZTogWzQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0NSwgMzYsIDU4LCA0NywgNDYsIDQzLCA2NSwgNjYsIDY3LCA2OF19LFxuICAgIENIQVJBQ1RFUl9FTkNPRElOR1M6IHt2YWx1ZTogWzB4MDAzLCAweDAwNiwgMHgwMDksIDB4MDYwLCAweDAxMiwgMHgwNDIsIDB4MDIxLCAweDAyNCwgMHgwMzAsIDB4MDQ4LCAweDAwYywgMHgwMTgsXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV19LFxuICAgIFNUQVJUX0VORDoge3ZhbHVlOiBbMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdfSxcbiAgICBNSU5fRU5DT0RFRF9DSEFSUzoge3ZhbHVlOiA0fSxcbiAgICBNQVhfQUNDRVBUQUJMRToge3ZhbHVlOiAyLjB9LFxuICAgIFBBRERJTkc6IHt2YWx1ZTogMS41fSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJjb2RhYmFyXCIsIHdyaXRlYWJsZTogZmFsc2V9XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFyY29kZVJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2RhYmFyUmVhZGVyO1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGRlY29kZWRDaGFyLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBuZXh0U3RhcnQsXG4gICAgICAgIGVuZDtcblxuICAgIHRoaXMuX2NvdW50ZXJzID0gc2VsZi5fZmlsbENvdW50ZXJzKCk7XG4gICAgc3RhcnQgPSBzZWxmLl9maW5kU3RhcnQoKTtcbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBuZXh0U3RhcnQgPSBzdGFydC5zdGFydENvdW50ZXI7XG5cbiAgICBkbyB7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ2hhciA9IHNlbGYuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgIGlmIChkZWNvZGVkQ2hhciA8IDApe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICBuZXh0U3RhcnQgKz0gODtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxICYmIHNlbGYuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAobmV4dFN0YXJ0IDwgc2VsZi5fY291bnRlcnMubGVuZ3RoKTtcblxuICAgIC8vIHZlcmlmeSBlbmRcbiAgICBpZiAoKHJlc3VsdC5sZW5ndGggLSAyKSA8IHNlbGYuTUlOX0VOQ09ERURfQ0hBUlMgfHwgIXNlbGYuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gdmVyaWZ5IGVuZCB3aGl0ZSBzcGFjZVxuICAgIGlmICghc2VsZi5fdmVyaWZ5V2hpdGVzcGFjZShzdGFydC5zdGFydENvdW50ZXIsIG5leHRTdGFydCAtIDgpKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLl92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0LnN0YXJ0Q291bnRlcikpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiBzZWxmLl9jb3VudGVycy5sZW5ndGggPyBzZWxmLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XG4gICAgZW5kID0gc3RhcnQuc3RhcnQgKyBzZWxmLl9zdW1Db3VudGVycyhzdGFydC5zdGFydENvdW50ZXIsIG5leHRTdGFydCAtIDgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0XG4gICAgfTtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlXaGl0ZXNwYWNlID0gZnVuY3Rpb24oc3RhcnRDb3VudGVyLCBlbmRDb3VudGVyKSB7XG4gICAgaWYgKChzdGFydENvdW50ZXIgLSAxIDw9IDApXG4gICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tzdGFydENvdW50ZXIgLSAxXSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChzdGFydENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICBpZiAoKGVuZENvdW50ZXIgKyA4ID49IHRoaXMuX2NvdW50ZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tlbmRDb3VudGVyICsgN10gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoZW5kQ291bnRlcikgLyAyLjApKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBpLFxuICAgICAgICBzdW0gPSAwO1xuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNzsgaSsrKSB7XG4gICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4gPSBmdW5jdGlvbihyZXN1bHQsIHN0YXJ0Q291bnRlcil7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjYXRlZ29yaXphdGlvbiA9IHtcbiAgICAgICAgICAgIHNwYWNlOiB7XG4gICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUV9LFxuICAgICAgICAgICAgICAgIHdpZGU6IHtzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFfSxcbiAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUV9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGtpbmQsXG4gICAgICAgIGNhdCxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgcG9zID0gc3RhcnRDb3VudGVyLFxuICAgICAgICBwYXR0ZXJuO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgIGZvciAoaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBraW5kID0gKGogJiAxKSA9PT0gMiA/IGNhdGVnb3JpemF0aW9uLmJhciA6IGNhdGVnb3JpemF0aW9uLnNwYWNlO1xuICAgICAgICAgICAgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgICAgY2F0LnNpemUgKz0gc2VsZi5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICBjYXQuY291bnRzKys7XG4gICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSA4O1xuICAgIH1cblxuICAgIFtcInNwYWNlXCIsIFwiYmFyXCJdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBuZXdraW5kID0gY2F0ZWdvcml6YXRpb25ba2V5XTtcbiAgICAgICAgbmV3a2luZC53aWRlLm1pbiA9XG4gICAgICAgICAgICBNYXRoLmZsb29yKChuZXdraW5kLm5hcnJvdy5zaXplIC8gbmV3a2luZC5uYXJyb3cuY291bnRzICsgbmV3a2luZC53aWRlLnNpemUgLyBuZXdraW5kLndpZGUuY291bnRzKSAvIDIpO1xuICAgICAgICBuZXdraW5kLm5hcnJvdy5tYXggPSBNYXRoLmNlaWwobmV3a2luZC53aWRlLm1pbik7XG4gICAgICAgIG5ld2tpbmQud2lkZS5tYXggPSBNYXRoLmNlaWwoKG5ld2tpbmQud2lkZS5zaXplICogc2VsZi5NQVhfQUNDRVBUQUJMRSArIHNlbGYuUEFERElORykgLyBuZXdraW5kLndpZGUuY291bnRzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl9jaGFyVG9QYXR0ZXJuID0gZnVuY3Rpb24oY2hhcikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5BTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5BTFBIQUJFVFtpXSA9PT0gY2hhckNvZGUpe1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMHgwO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX3ZhbGlkYXRlUmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0LCBzdGFydENvdW50ZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHRocmVzaG9sZHMgPSBzZWxmLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdCwgc3RhcnRDb3VudGVyKSxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAga2luZCxcbiAgICAgICAgY2F0LFxuICAgICAgICBzaXplLFxuICAgICAgICBwb3MgPSBzdGFydENvdW50ZXIsXG4gICAgICAgIHBhdHRlcm47XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgIGZvciAoaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcbiAgICAgICAgICAgIGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgIHNpemUgPSBzZWxmLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICAgIGlmIChzaXplIDwgY2F0Lm1pbiB8fCBzaXplID4gY2F0Lm1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IDg7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX3BhdHRlcm5Ub0NoYXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5DSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmLkFMUEhBQkVUW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkID0gZnVuY3Rpb24ob2Zmc2V0LCBlbmQpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbWluID0gTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgbWF4ID0gMCxcbiAgICAgICAgY291bnRlcjtcblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSAyKXtcbiAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICBpZiAoY291bnRlciA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gY291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnRlciA8IG1pbikge1xuICAgICAgICAgICAgbWluID0gY291bnRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKG1pbiArIG1heCkgLyAyLjApIHwgMDtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl90b1BhdHRlcm4gPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgbnVtQ291bnRlcnMgPSA3LFxuICAgICAgICBlbmQgPSBvZmZzZXQgKyBudW1Db3VudGVycyxcbiAgICAgICAgYmFyVGhyZXNob2xkLFxuICAgICAgICBzcGFjZVRocmVzaG9sZCxcbiAgICAgICAgYml0bWFzayA9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSksXG4gICAgICAgIHBhdHRlcm4gPSAwLFxuICAgICAgICBpLFxuICAgICAgICB0aHJlc2hvbGQ7XG5cbiAgICBpZiAoZW5kID4gdGhpcy5fY291bnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBiYXJUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0LCBlbmQpO1xuICAgIHNwYWNlVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCArIDEsIGVuZCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKyl7XG4gICAgICAgIHRocmVzaG9sZCA9IChpICYgMSkgPT09IDAgPyBiYXJUaHJlc2hvbGQgOiBzcGFjZVRocmVzaG9sZDtcbiAgICAgICAgaWYgKHRoaXMuX2NvdW50ZXJzW29mZnNldCArIGldID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBwYXR0ZXJuIHw9IGJpdG1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgYml0bWFzayA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0dGVybjtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl9pc1N0YXJ0RW5kID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuU1RBUlRfRU5ELmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLlNUQVJUX0VORFtpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX3N1bUNvdW50ZXJzID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBpLFxuICAgICAgICBzdW0gPSAwO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fZmluZFN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBpLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBzdGFydCA9IHNlbGYuX25leHRVbnNldChzZWxmLl9yb3cpLFxuICAgICAgICBlbmQ7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5fY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0dGVybiA9IHNlbGYuX3RvUGF0dGVybihpKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gIT09IC0xICYmIHNlbGYuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IExvb2sgZm9yIHdoaXRlc3BhY2UgYWhlYWRcbiAgICAgICAgICAgIHN0YXJ0ICs9IHNlbGYuX3N1bUNvdW50ZXJzKDAsIGkpO1xuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBzZWxmLl9zdW1Db3VudGVycyhpLCBpICsgOCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICBzdGFydENvdW50ZXI6IGksXG4gICAgICAgICAgICAgICAgZW5kQ291bnRlcjogaSArIDhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb2RhYmFyUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5mdW5jdGlvbiBDb2RlMTI4UmVhZGVyKCkge1xuICAgIEJhcmNvZGVSZWFkZXIuY2FsbCh0aGlzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQ09ERV9TSElGVDoge3ZhbHVlOiA5OH0sXG4gICAgQ09ERV9DOiB7dmFsdWU6IDk5fSxcbiAgICBDT0RFX0I6IHt2YWx1ZTogMTAwfSxcbiAgICBDT0RFX0E6IHt2YWx1ZTogMTAxfSxcbiAgICBTVEFSVF9DT0RFX0E6IHt2YWx1ZTogMTAzfSxcbiAgICBTVEFSVF9DT0RFX0I6IHt2YWx1ZTogMTA0fSxcbiAgICBTVEFSVF9DT0RFX0M6IHt2YWx1ZTogMTA1fSxcbiAgICBTVE9QX0NPREU6IHt2YWx1ZTogMTA2fSxcbiAgICBDT0RFX1BBVFRFUk46IHt2YWx1ZTogW1xuICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXG4gICAgICAgIFsyLCAyLCAyLCAxLCAyLCAyXSxcbiAgICAgICAgWzIsIDIsIDIsIDIsIDIsIDFdLFxuICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXG4gICAgICAgIFsxLCAyLCAxLCAzLCAyLCAyXSxcbiAgICAgICAgWzEsIDMsIDEsIDIsIDIsIDJdLFxuICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXG4gICAgICAgIFsxLCAyLCAyLCAzLCAxLCAyXSxcbiAgICAgICAgWzEsIDMsIDIsIDIsIDEsIDJdLFxuICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXG4gICAgICAgIFsyLCAyLCAxLCAzLCAxLCAyXSxcbiAgICAgICAgWzIsIDMsIDEsIDIsIDEsIDJdLFxuICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXG4gICAgICAgIFsxLCAyLCAyLCAxLCAzLCAyXSxcbiAgICAgICAgWzEsIDIsIDIsIDIsIDMsIDFdLFxuICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXG4gICAgICAgIFsxLCAyLCAzLCAxLCAyLCAyXSxcbiAgICAgICAgWzEsIDIsIDMsIDIsIDIsIDFdLFxuICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXG4gICAgICAgIFsyLCAyLCAxLCAxLCAzLCAyXSxcbiAgICAgICAgWzIsIDIsIDEsIDIsIDMsIDFdLFxuICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXG4gICAgICAgIFsyLCAyLCAzLCAxLCAxLCAyXSxcbiAgICAgICAgWzMsIDEsIDIsIDEsIDMsIDFdLFxuICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXG4gICAgICAgIFszLCAyLCAxLCAxLCAyLCAyXSxcbiAgICAgICAgWzMsIDIsIDEsIDIsIDIsIDFdLFxuICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXG4gICAgICAgIFszLCAyLCAyLCAxLCAxLCAyXSxcbiAgICAgICAgWzMsIDIsIDIsIDIsIDEsIDFdLFxuICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXG4gICAgICAgIFsyLCAxLCAyLCAzLCAyLCAxXSxcbiAgICAgICAgWzIsIDMsIDIsIDEsIDIsIDFdLFxuICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXG4gICAgICAgIFsxLCAzLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgWzEsIDMsIDEsIDMsIDIsIDFdLFxuICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXG4gICAgICAgIFsxLCAzLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgWzEsIDMsIDIsIDMsIDEsIDFdLFxuICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXG4gICAgICAgIFsyLCAzLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgWzIsIDMsIDEsIDMsIDEsIDFdLFxuICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXG4gICAgICAgIFsxLCAxLCAyLCAzLCAzLCAxXSxcbiAgICAgICAgWzEsIDMsIDIsIDEsIDMsIDFdLFxuICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXG4gICAgICAgIFsxLCAxLCAzLCAzLCAyLCAxXSxcbiAgICAgICAgWzEsIDMsIDMsIDEsIDIsIDFdLFxuICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXG4gICAgICAgIFsyLCAxLCAxLCAzLCAzLCAxXSxcbiAgICAgICAgWzIsIDMsIDEsIDEsIDMsIDFdLFxuICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXG4gICAgICAgIFsyLCAxLCAzLCAzLCAxLCAxXSxcbiAgICAgICAgWzIsIDEsIDMsIDEsIDMsIDFdLFxuICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXG4gICAgICAgIFszLCAxLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgWzMsIDMsIDEsIDEsIDIsIDFdLFxuICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXG4gICAgICAgIFszLCAxLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgWzMsIDMsIDIsIDEsIDEsIDFdLFxuICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXG4gICAgICAgIFsyLCAyLCAxLCA0LCAxLCAxXSxcbiAgICAgICAgWzQsIDMsIDEsIDEsIDEsIDFdLFxuICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXG4gICAgICAgIFsxLCAxLCAxLCA0LCAyLCAyXSxcbiAgICAgICAgWzEsIDIsIDEsIDEsIDIsIDRdLFxuICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXG4gICAgICAgIFsxLCA0LCAxLCAxLCAyLCAyXSxcbiAgICAgICAgWzEsIDQsIDEsIDIsIDIsIDFdLFxuICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXG4gICAgICAgIFsxLCAxLCAyLCA0LCAxLCAyXSxcbiAgICAgICAgWzEsIDIsIDIsIDEsIDEsIDRdLFxuICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXG4gICAgICAgIFsxLCA0LCAyLCAxLCAxLCAyXSxcbiAgICAgICAgWzEsIDQsIDIsIDIsIDEsIDFdLFxuICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXG4gICAgICAgIFsyLCAyLCAxLCAxLCAxLCA0XSxcbiAgICAgICAgWzQsIDEsIDMsIDEsIDEsIDFdLFxuICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXG4gICAgICAgIFsxLCAzLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgWzEsIDEsIDEsIDIsIDQsIDJdLFxuICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXG4gICAgICAgIFsxLCAyLCAxLCAyLCA0LCAxXSxcbiAgICAgICAgWzEsIDEsIDQsIDIsIDEsIDJdLFxuICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXG4gICAgICAgIFsxLCAyLCA0LCAyLCAxLCAxXSxcbiAgICAgICAgWzQsIDEsIDEsIDIsIDEsIDJdLFxuICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXG4gICAgICAgIFs0LCAyLCAxLCAyLCAxLCAxXSxcbiAgICAgICAgWzIsIDEsIDIsIDEsIDQsIDFdLFxuICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXG4gICAgICAgIFs0LCAxLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgWzEsIDEsIDEsIDEsIDQsIDNdLFxuICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXG4gICAgICAgIFsxLCAzLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgWzEsIDEsIDQsIDEsIDEsIDNdLFxuICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXG4gICAgICAgIFs0LCAxLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgWzQsIDEsIDEsIDMsIDEsIDFdLFxuICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXG4gICAgICAgIFsxLCAxLCA0LCAxLCAzLCAxXSxcbiAgICAgICAgWzMsIDEsIDEsIDEsIDQsIDFdLFxuICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXG4gICAgICAgIFsyLCAxLCAxLCA0LCAxLCAyXSxcbiAgICAgICAgWzIsIDEsIDEsIDIsIDEsIDRdLFxuICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXG4gICAgICAgIFsyLCAzLCAzLCAxLCAxLCAxLCAyXVxuICAgIF19LFxuICAgIFNJTkdMRV9DT0RFX0VSUk9SOiB7dmFsdWU6IDAuNjR9LFxuICAgIEFWR19DT0RFX0VSUk9SOiB7dmFsdWU6IDAuMzB9LFxuICAgIEZPUk1BVDoge3ZhbHVlOiBcImNvZGVfMTI4XCIsIHdyaXRlYWJsZTogZmFsc2V9LFxuICAgIE1PRFVMRV9JTkRJQ0VTOiB7dmFsdWU6IHtiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XX19XG59O1xuXG5Db2RlMTI4UmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFyY29kZVJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuQ29kZTEyOFJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2RlMTI4UmVhZGVyO1xuXG5Db2RlMTI4UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlQ29kZSA9IGZ1bmN0aW9uKHN0YXJ0LCBjb3JyZWN0aW9uKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIGksXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBvZmZzZXQgPSBzdGFydCxcbiAgICAgICAgaXNXaGl0ZSA9ICFzZWxmLl9yb3dbb2Zmc2V0XSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2RlLFxuICAgICAgICBlcnJvcjtcblxuICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ycmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jb3JyZWN0KGNvdW50ZXIsIGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgc2VsZi5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgc2VsZi5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gc2VsZi5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSBjYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IGNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Db2RlMTI4UmVhZGVyLnByb3RvdHlwZS5fY29ycmVjdCA9IGZ1bmN0aW9uKGNvdW50ZXIsIGNvcnJlY3Rpb24pIHtcbiAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uc3BhY2UsIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xufTtcblxuQ29kZTEyOFJlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBpc1doaXRlID0gZmFsc2UsXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBqLFxuICAgICAgICBzdW07XG5cbiAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29kZSA9IHNlbGYuU1RBUlRfQ09ERV9BOyBjb2RlIDw9IHNlbGYuU1RBUlRfQ09ERV9DOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgc2VsZi5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBzZWxmLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSBjYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IGNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Db2RlMTI4UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kU3RhcnQoKSxcbiAgICAgICAgY29kZSA9IG51bGwsXG4gICAgICAgIGRvbmUgPSBmYWxzZSxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIG11bHRpcGxpZXIgPSAwLFxuICAgICAgICBjaGVja3N1bSA9IDAsXG4gICAgICAgIGNvZGVzZXQsXG4gICAgICAgIHJhd1Jlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgc2hpZnROZXh0ID0gZmFsc2UsXG4gICAgICAgIHVuc2hpZnQsXG4gICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuXG4gICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29kZSA9IHtcbiAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZCxcbiAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgYmFyOiBzdGFydEluZm8uY29ycmVjdGlvbi5iYXIsXG4gICAgICAgICAgICBzcGFjZTogc3RhcnRJbmZvLmNvcnJlY3Rpb24uc3BhY2VcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XG4gICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICBjYXNlIHNlbGYuU1RBUlRfQ09ERV9BOlxuICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0E7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2Ugc2VsZi5TVEFSVF9DT0RFX0I6XG4gICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBzZWxmLlNUQVJUX0NPREVfQzpcbiAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9DO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBjb2RlLmNvcnJlY3Rpb24pO1xuICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gc2VsZi5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gc2VsZi5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICByYXdSZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICBjaGVja3N1bSArPSBtdWx0aXBsaWVyICogY29kZS5jb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY29kZXNldCkge1xuICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfQTpcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGNvZGUuY29kZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlLmNvZGUgLSA2NCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHNlbGYuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0I6XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSBzZWxmLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9DOlxuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlIDwgMTAgPyBcIjBcIiArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gc2VsZi5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgICAgY29kZXNldCA9IGNvZGVzZXQgPT09IHNlbGYuQ09ERV9BID8gc2VsZi5DT0RFX0IgOiBzZWxmLkNPREVfQTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvZGUuZW5kID0gc2VsZi5fbmV4dFVuc2V0KHNlbGYuX3JvdywgY29kZS5lbmQpO1xuICAgIGlmICghc2VsZi5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGNvZGUpKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgbGFzdCBjb2RlIGZyb20gcmVzdWx0IChjaGVja3N1bSlcbiAgICBpZiAocmVtb3ZlTGFzdENoYXJhY3Rlcikge1xuICAgICAgICByZXN1bHQuc3BsaWNlKHJlc3VsdC5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0LFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgIGVuZEluZm86IGNvZGVcbiAgICB9O1xufTtcblxuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlID0gZnVuY3Rpb24oZW5kSW5mbykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb3JyZWN0aW9uKGV4cGVjdGVkLCBub3JtYWxpemVkLCBpbmRpY2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoLFxuICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgc3VtRXhwZWN0ZWQgPSAwO1xuXG4gICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtRXhwZWN0ZWQgKz0gZXhwZWN0ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgc3VtTm9ybWFsaXplZCArPSBub3JtYWxpemVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgfVxuICAgIHJldHVybiBzdW1FeHBlY3RlZC9zdW1Ob3JtYWxpemVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMTI4UmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIuanMiLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuXG5mdW5jdGlvbiBDb2RlMzlWSU5SZWFkZXIoKSB7XG4gICAgQ29kZTM5UmVhZGVyLmNhbGwodGhpcyk7XG59XG5cbnZhciBwYXR0ZXJucyA9IHtcbiAgICBJT1E6IC9bSU9RXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XXsxN30vXG59O1xuXG5Db2RlMzlWSU5SZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb2RlMzlSZWFkZXIucHJvdG90eXBlKTtcbkNvZGUzOVZJTlJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2RlMzlWSU5SZWFkZXI7XG5cbi8vIENyaWJiZWQgZnJvbTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iL21hc3Rlci9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9jbGllbnQvcmVzdWx0L1ZJTlJlc3VsdFBhcnNlci5qYXZhXG5Db2RlMzlWSU5SZWFkZXIucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlLmFwcGx5KHRoaXMpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5JT1EsICcnKTtcblxuICAgIGlmICghY29kZS5tYXRjaChwYXR0ZXJucy5BWjA5KSkge1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIEFaMDkgcGF0dGVybiBjb2RlOicsIGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkNvZGUzOVZJTlJlYWRlci5wcm90b3R5cGUuX2NoZWNrQ2hlY2tzdW0gPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiAhIWNvZGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlWSU5SZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5mdW5jdGlvbiBDb2RlOTNSZWFkZXIoKSB7XG4gICAgQmFyY29kZVJlYWRlci5jYWxsKHRoaXMpO1xufVxuXG5jb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZCpcIjtcblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQUxQSEFCRVRIX1NUUklORzoge3ZhbHVlOiBBTFBIQUJFVEhfU1RSSU5HfSxcbiAgICBBTFBIQUJFVDoge3ZhbHVlOiBBTFBIQUJFVEhfU1RSSU5HLnNwbGl0KCcnKS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpfSxcbiAgICBDSEFSQUNURVJfRU5DT0RJTkdTOiB7dmFsdWU6IFtcbiAgICAgICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXG4gICAgICAgIDB4MUE4LCAweDFBNCwgMHgxQTIsIDB4MTk0LCAweDE5MiwgMHgxOEEsIDB4MTY4LCAweDE2NCwgMHgxNjIsIDB4MTM0LFxuICAgICAgICAweDExQSwgMHgxNTgsIDB4MTRDLCAweDE0NiwgMHgxMkMsIDB4MTE2LCAweDFCNCwgMHgxQjIsIDB4MUFDLCAweDFBNixcbiAgICAgICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXG4gICAgICAgIDB4MTZFLCAweDE3NiwgMHgxQUUsIDB4MTI2LCAweDFEQSwgMHgxRDYsIDB4MTMyLCAweDE1RVxuICAgIF19LFxuICAgIEFTVEVSSVNLOiB7dmFsdWU6IDB4MTVFfSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJjb2RlXzkzXCIsIHdyaXRlYWJsZTogZmFsc2V9XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXJjb2RlUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29kZTkzUmVhZGVyO1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvdW50ZXJzID0gWzAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgc3RhcnQgPSBzZWxmLl9maW5kU3RhcnQoKSxcbiAgICAgICAgZGVjb2RlZENoYXIsXG4gICAgICAgIGxhc3RTdGFydCxcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgbmV4dFN0YXJ0O1xuXG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbmV4dFN0YXJ0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICBkbyB7XG4gICAgICAgIGNvdW50ZXJzID0gc2VsZi5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKTtcbiAgICAgICAgcGF0dGVybiA9IHNlbGYuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENoYXIgPSBzZWxmLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICBpZiAoZGVjb2RlZENoYXIgPCAwKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3csIG5leHRTdGFydCk7XG4gICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghc2VsZi5fdmVyaWZ5RW5kKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgIGlmICgocmVzdWx0ID0gc2VsZi5fZGVjb2RlRXh0ZW5kZWQocmVzdWx0KSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdFxuICAgIH07XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlFbmQgPSBmdW5jdGlvbihsYXN0U3RhcnQsIG5leHRTdGFydCkge1xuICAgIGlmIChsYXN0U3RhcnQgPT09IG5leHRTdGFydCB8fCAhdGhpcy5fcm93W25leHRTdGFydF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNvZGU5M1JlYWRlci5wcm90b3R5cGUuX3BhdHRlcm5Ub0NoYXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5DSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmLkFMUEhBQkVUW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl90b1BhdHRlcm4gPSBmdW5jdGlvbihjb3VudGVycykge1xuICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgIGxldCBwYXR0ZXJuID0gMDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGNvdW50ZXJzW2ldO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICBsZXQgbm9ybWFsaXplZCA9IE1hdGgucm91bmQoY291bnRlcnNbaV0gKiA5IC8gc3VtKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9ybWFsaXplZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IChwYXR0ZXJuIDw8IDEpIHwgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPDw9IG5vcm1hbGl6ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0dGVybjtcbn07XG5cbkNvZGU5M1JlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQsXG4gICAgICAgIGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBpc1doaXRlID0gZmFsc2UsXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIHdoaXRlU3BhY2VNdXN0U3RhcnQ7XG5cbiAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gc2VsZi5BU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVFeHRlbmRlZCA9IGZ1bmN0aW9uKGNoYXJBcnJheSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGNoYXJBcnJheS5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gY2hhckFycmF5W2ldO1xuICAgICAgICBpZiAoY2hhciA+PSAnYScgJiYgY2hhciA8PSAnZCcpIHtcbiAgICAgICAgICAgIGlmIChpID4gKGxlbmd0aCAtIDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGNoYXJBcnJheVsrK2ldO1xuICAgICAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gbmV4dENoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDY0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdFJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0snICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMTYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1AnICYmIG5leHRDaGFyIDw9ICdTJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgNDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICdaJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICc6JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMzIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlDaGVja3N1bXMgPSBmdW5jdGlvbihjaGFyQXJyYXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMiwgMjApXG4gICAgICAgICYmIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDEsIDE1KTtcbn07XG5cbkNvZGU5M1JlYWRlci5wcm90b3R5cGUuX21hdGNoQ2hlY2tDaGFyID0gZnVuY3Rpb24oY2hhckFycmF5LCBpbmRleCwgbWF4V2VpZ2h0KSB7XG4gICAgY29uc3QgYXJyYXlUb0NoZWNrID0gY2hhckFycmF5LnNsaWNlKDAsIGluZGV4KTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheVRvQ2hlY2subGVuZ3RoO1xuICAgIGNvbnN0IHdlaWdodGVkU3VtcyA9IGFycmF5VG9DaGVjay5yZWR1Y2UoKHN1bSwgY2hhciwgaSkgPT4ge1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSAoKChpICogLTEpICsgKGxlbmd0aCAtIDEpKSAlIG1heFdlaWdodCkgKyAxO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuQUxQSEFCRVQuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICByZXR1cm4gc3VtICsgKHdlaWdodCAqIHZhbHVlKTtcbiAgICB9LCAwKTtcblxuICAgIGNvbnN0IGNoZWNrQ2hhciA9IHRoaXMuQUxQSEFCRVRbKHdlaWdodGVkU3VtcyAlIDQ3KV07XG4gICAgcmV0dXJuIGNoZWNrQ2hhciA9PT0gY2hhckFycmF5W2luZGV4XS5jaGFyQ29kZUF0KDApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29kZTkzUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9jb2RlXzkzX3JlYWRlci5qcyIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcblxuZnVuY3Rpb24gRUFOMlJlYWRlcigpIHtcbiAgICBFQU5SZWFkZXIuY2FsbCh0aGlzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgRk9STUFUOiB7dmFsdWU6IFwiZWFuXzJcIiwgd3JpdGVhYmxlOiBmYWxzZX1cbn07XG5cbkVBTjJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFQU5SZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkVBTjJSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRUFOMlJlYWRlcjtcblxuRUFOMlJlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24ocm93LCBzdGFydCkge1xuICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICB2YXIgY291bnRlcnMgPSBbMCwgMCwgMCwgMF0sXG4gICAgICAgIGNvZGVGcmVxdWVuY3kgPSAwLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgb2Zmc2V0ID0gc3RhcnQsXG4gICAgICAgIGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGgsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCAyICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgaWYgKGNvZGUuY29kZSA+PSB0aGlzLkNPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICgxIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgIT0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPSAyIHx8IChwYXJzZUludChyZXN1bHQuam9pbihcIlwiKSkgJSA0KSAgIT09IGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgIGVuZDogY29kZS5lbmRcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFOMlJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLmpzIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuXG5mdW5jdGlvbiBFQU41UmVhZGVyKCkge1xuICAgIEVBTlJlYWRlci5jYWxsKHRoaXMpO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJlYW5fNVwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuY29uc3QgQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzI0LCAyMCwgMTgsIDE3LCAxMiwgNiwgMywgMTAsIDksIDVdO1xuXG5FQU41UmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRUFOUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5FQU41UmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVBTjVSZWFkZXI7XG5cbkVBTjVSZWFkZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHJvdywgc3RhcnQpIHtcbiAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgdmFyIGNvdW50ZXJzID0gWzAsIDAsIDAsIDBdLFxuICAgICAgICBjb2RlRnJlcXVlbmN5ID0gMCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG9mZnNldCA9IHN0YXJ0LFxuICAgICAgICBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoLFxuICAgICAgICBjb2RlLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgZGVjb2RlZENvZGVzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNSAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgIGlmIChjb2RlLmNvZGUgPj0gdGhpcy5DT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNCAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9IDQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggIT0gNSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0KSAhPT0gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgZW5kOiBjb2RlLmVuZFxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3kpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuXG5mdW5jdGlvbiBleHRlbnNpb25DaGVja3N1bShyZXN1bHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIHJldHVybiBzdW0gJSAxMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFONVJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLmpzIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuXG5mdW5jdGlvbiBFQU44UmVhZGVyKG9wdHMsIHN1cHBsZW1lbnRzKSB7XG4gICAgRUFOUmVhZGVyLmNhbGwodGhpcywgb3B0cywgc3VwcGxlbWVudHMpO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJlYW5fOFwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuRUFOOFJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVBTlJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuRUFOOFJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFQU44UmVhZGVyO1xuXG5FQU44UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY29kZS5lbmQsIHNlbGYuQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICB9XG5cbiAgICBjb2RlID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5NSURETEVfUEFUVEVSTiwgY29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBjb2RlID0gc2VsZi5fZGVjb2RlQ29kZShjb2RlLmVuZCwgc2VsZi5DT0RFX0dfU1RBUlQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2RlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLmpzIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQge21lcmdlfSBmcm9tICdsb2Rhc2gnO1xuXG5mdW5jdGlvbiBJMm9mNVJlYWRlcihvcHRzKSB7XG4gICAgb3B0cyA9IG1lcmdlKGdldERlZmF1bENvbmZpZygpLCBvcHRzKTtcbiAgICBCYXJjb2RlUmVhZGVyLmNhbGwodGhpcywgb3B0cyk7XG4gICAgdGhpcy5iYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuICAgIGlmIChvcHRzLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiA9IDAuMzg7XG4gICAgICAgIHRoaXMuQVZHX0NPREVfRVJST1IgPSAwLjA5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsQ29uZmlnKCkge1xuICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKEkyb2Y1UmVhZGVyLkNPTkZJR19LRVlTKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBjb25maWdba2V5XSA9IEkyb2Y1UmVhZGVyLkNPTkZJR19LRVlTW2tleV0uZGVmYXVsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG52YXIgTiA9IDEsXG4gICAgVyA9IDMsXG4gICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgU1RBUlRfUEFUVEVSTjoge3ZhbHVlOiBbTiwgTiwgTiwgTl19LFxuICAgICAgICBTVE9QX1BBVFRFUk46IHt2YWx1ZTogW04sIE4sIFddfSxcbiAgICAgICAgQ09ERV9QQVRURVJOOiB7dmFsdWU6IFtcbiAgICAgICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICAgICAgICAgIFtXLCBOLCBOLCBOLCBXXSxcbiAgICAgICAgICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICAgICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICAgICAgICAgIFtOLCBOLCBXLCBOLCBXXSxcbiAgICAgICAgICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICAgICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICAgICAgICAgIFtOLCBOLCBOLCBXLCBXXSxcbiAgICAgICAgICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICAgICAgICAgIFtOLCBXLCBOLCBXLCBOXVxuICAgICAgICBdfSxcbiAgICAgICAgU0lOR0xFX0NPREVfRVJST1I6IHt2YWx1ZTogMC43OCwgd3JpdGFibGU6IHRydWV9LFxuICAgICAgICBBVkdfQ09ERV9FUlJPUjoge3ZhbHVlOiAwLjM4LCB3cml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIE1BWF9DT1JSRUNUSU9OX0ZBQ1RPUjoge3ZhbHVlOiA1fSxcbiAgICAgICAgRk9STUFUOiB7dmFsdWU6IFwiaTJvZjVcIn1cbiAgICB9O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEkyb2Y1UmVhZGVyO1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX21hdGNoUGF0dGVybiA9IGZ1bmN0aW9uKGNvdW50ZXIsIGNvZGUpIHtcbiAgICBpZiAodGhpcy5jb25maWcubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGNvdW50ZXJTdW0gPSBbMCwgMF0sXG4gICAgICAgICAgICBjb2RlU3VtID0gWzAsIDBdLFxuICAgICAgICAgICAgY29ycmVjdGlvbiA9IFswLCAwXSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb25SYXRpbyA9IHRoaXMuTUFYX0NPUlJFQ1RJT05fRkFDVE9SLFxuICAgICAgICAgICAgY29ycmVjdGlvblJhdGlvSW52ZXJzZSA9IDEgLyBjb3JyZWN0aW9uUmF0aW87XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJTdW1baSAlIDJdICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBjb2RlU3VtW2kgJSAyXSArPSBjb2RlW2ldO1xuICAgICAgICB9XG4gICAgICAgIGNvcnJlY3Rpb25bMF0gPSBjb2RlU3VtWzBdIC8gY291bnRlclN1bVswXTtcbiAgICAgICAgY29ycmVjdGlvblsxXSA9IGNvZGVTdW1bMV0gLyBjb3VudGVyU3VtWzFdO1xuXG4gICAgICAgIGNvcnJlY3Rpb25bMF0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzBdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgY29ycmVjdGlvblsxXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMV0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBjb3JyZWN0aW9uO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnRlcltpXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9baSAlIDJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbWF0Y2hQYXR0ZXJuLmNhbGwodGhpcywgY291bnRlciwgY29kZSk7XG59O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX2ZpbmRQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIpIHtcbiAgICB2YXIgY291bnRlciA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaixcbiAgICAgICAgc3VtLFxuICAgICAgICBub3JtYWxpemVkLFxuICAgICAgICBlcHNpbG9uID0gc2VsZi5BVkdfQ09ERV9FUlJPUjtcblxuICAgIGlzV2hpdGUgPSBpc1doaXRlIHx8IGZhbHNlO1xuICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KTtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZmluZFN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LFxuICAgICAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3JvdyksXG4gICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgbmFycm93QmFyV2lkdGggPSAxO1xuXG4gICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgc3RhcnRJbmZvID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5TVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyA0KTtcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XG4gICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgfVxufTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihlbmRJbmZvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZmluZEVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZW5kSW5mbyxcbiAgICAgICAgdG1wO1xuXG4gICAgc2VsZi5fcm93LnJldmVyc2UoKTtcbiAgICBlbmRJbmZvID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5TVE9QX1BBVFRFUk4pO1xuICAgIHNlbGYuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgIGVuZEluZm8uc3RhcnQgPSBzZWxmLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgZW5kSW5mby5lbmQgPSBzZWxmLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyBzZWxmLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xufTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVQYWlyID0gZnVuY3Rpb24oY291bnRlclBhaXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgY29kZSxcbiAgICAgICAgY29kZXMgPSBbXSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRlclBhaXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY291bnRlclBhaXJbaV0pO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVzLnB1c2goY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2Rlcztcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlQ29kZSA9IGZ1bmN0aW9uKGNvdW50ZXIpIHtcbiAgICB2YXIgaixcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHN1bSA9IDAsXG4gICAgICAgIG5vcm1hbGl6ZWQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBlcHNpbG9uID0gc2VsZi5BVkdfQ09ERV9FUlJPUixcbiAgICAgICAgY29kZSxcbiAgICAgICAgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwXG4gICAgICAgIH07XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgfVxuICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCBzZWxmLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBzZWxmLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICB9XG59O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX2RlY29kZVBheWxvYWQgPSBmdW5jdGlvbihjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHBvcyA9IDAsXG4gICAgICAgIGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGgsXG4gICAgICAgIGNvdW50ZXJQYWlyID0gW1swLCAwLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDAsIDBdXSxcbiAgICAgICAgY29kZXM7XG5cbiAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyUGFpclswXVtpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICBjb3VudGVyUGFpclsxXVtpXSA9IGNvdW50ZXJzW3BvcyArIDFdICogdGhpcy5iYXJTcGFjZVJhdGlvWzFdO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXMgPSBzZWxmLl9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyKTtcbiAgICAgICAgaWYgKCFjb2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2Rlc1tpXS5jb2RlICsgXCJcIik7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvZGVzO1xufTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlDb3VudGVyTGVuZ3RoID0gZnVuY3Rpb24oY291bnRlcnMpIHtcbiAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0SW5mbyxcbiAgICAgICAgZW5kSW5mbyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgY291bnRlcnM7XG5cbiAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kU3RhcnQoKTtcbiAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgIGVuZEluZm8gPSBzZWxmLl9maW5kRW5kKCk7XG4gICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvdW50ZXJzID0gc2VsZi5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICBpZiAoIXNlbGYuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb2RlID0gc2VsZi5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyICE9PSAwIHx8XG4gICAgICAgICAgICByZXN1bHQubGVuZ3RoIDwgNikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzXG4gICAgfTtcbn07XG5cbkkyb2Y1UmVhZGVyLkNPTkZJR19LRVlTID0ge1xuICAgIG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg6IHtcbiAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICAgICdkZXNjcmlwdGlvbic6ICdJZiB0cnVlLCB0aGUgcmVhZGVyIHRyaWVzIHRvIG5vcm1hbGl6ZSB0aGUnICtcbiAgICAgICAgJ3dpZHRoLWRpZmZlcmVuY2UgYmV0d2VlbiBiYXJzIGFuZCBzcGFjZXMnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgSTJvZjVSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2kyb2Y1X3JlYWRlci5qcyIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcblxuZnVuY3Rpb24gVVBDRVJlYWRlcihvcHRzLCBzdXBwbGVtZW50cykge1xuICAgIEVBTlJlYWRlci5jYWxsKHRoaXMsIG9wdHMsIHN1cHBsZW1lbnRzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQ09ERV9GUkVRVUVOQ1k6IHt2YWx1ZTogW1xuICAgICAgICBbIDU2LCA1MiwgNTAsIDQ5LCA0NCwgMzgsIDM1LCA0MiwgNDEsIDM3IF0sXG4gICAgICAgIFs3LCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XV19LFxuICAgIFNUT1BfUEFUVEVSTjogeyB2YWx1ZTogWzEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDddfSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJ1cGNfZVwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuVVBDRVJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVBTlJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuVVBDRVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVUENFUmVhZGVyO1xuXG5VUENFUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY29kZS5lbmQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlLmNvZGUgPj0gc2VsZi5DT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgIGNvZGUuY29kZSA9IGNvZGUuY29kZSAtIHNlbGYuQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg1IC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgfVxuICAgIGlmICghc2VsZi5fZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGU7XG59O1xuXG5VUENFUmVhZGVyLnByb3RvdHlwZS5fZGV0ZXJtaW5lUGFyaXR5ID0gZnVuY3Rpb24oY29kZUZyZXF1ZW5jeSwgcmVzdWx0KSB7XG4gICAgdmFyIGksXG4gICAgICAgIG5yU3lzdGVtO1xuXG4gICAgZm9yIChuclN5c3RlbSA9IDA7IG5yU3lzdGVtIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IG5yU3lzdGVtKyspe1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV1baV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChuclN5c3RlbSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuVVBDRVJlYWRlci5wcm90b3R5cGUuX2NvbnZlcnRUb1VQQ0EgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB2YXIgdXBjYSA9IFtyZXN1bHRbMF1dLFxuICAgICAgICBsYXN0RGlnaXQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdO1xuXG4gICAgaWYgKGxhc3REaWdpdCA8PSAyKSB7XG4gICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgMykpXG4gICAgICAgICAgICAuY29uY2F0KFtsYXN0RGlnaXQsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoMywgNikpO1xuICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSAzKSB7XG4gICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNCkpXG4gICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDQsIDYpKTtcbiAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNCkge1xuICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDUpKVxuICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMCwgcmVzdWx0WzVdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA2KSlcbiAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIGxhc3REaWdpdF0pO1xuICAgIH1cblxuICAgIHVwY2EucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcbiAgICByZXR1cm4gdXBjYTtcbn07XG5cblVQQ0VSZWFkZXIucHJvdG90eXBlLl9jaGVja3N1bSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiBFQU5SZWFkZXIucHJvdG90eXBlLl9jaGVja3N1bS5jYWxsKHRoaXMsIHRoaXMuX2NvbnZlcnRUb1VQQ0EocmVzdWx0KSk7XG59O1xuXG5VUENFUmVhZGVyLnByb3RvdHlwZS5fZmluZEVuZCA9IGZ1bmN0aW9uKG9mZnNldCwgaXNXaGl0ZSkge1xuICAgIGlzV2hpdGUgPSB0cnVlO1xuICAgIHJldHVybiBFQU5SZWFkZXIucHJvdG90eXBlLl9maW5kRW5kLmNhbGwodGhpcywgb2Zmc2V0LCBpc1doaXRlKTtcbn07XG5cblVQQ0VSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihlbmRJbmZvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ0VSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL3VwY19lX3JlYWRlci5qcyIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcblxuZnVuY3Rpb24gVVBDUmVhZGVyKG9wdHMsIHN1cHBsZW1lbnRzKSB7XG4gICAgRUFOUmVhZGVyLmNhbGwodGhpcywgb3B0cywgc3VwcGxlbWVudHMpO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJ1cGNfYVwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuVVBDUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRUFOUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5VUENSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVVBDUmVhZGVyO1xuXG5VUENSZWFkZXIucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlLmNhbGwodGhpcyk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb2RlICYmIHJlc3VsdC5jb2RlLmxlbmd0aCA9PT0gMTMgJiYgcmVzdWx0LmNvZGUuY2hhckF0KDApID09PSBcIjBcIikge1xuICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBVUENSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQGFsaWFzIG1hdDIuY29weVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdXG4gIG91dFsxXSA9IGFbMV1cbiAgb3V0WzJdID0gYVsyXVxuICBvdXRbM10gPSBhWzNdXG4gIHJldHVybiBvdXRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC1tYXQyL2NvcHkuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuY3JlYXRlXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLW1hdDIvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydFxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuaW52ZXJ0XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGEzID0gYVszXVxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTFcblxuICBpZiAoIWRldCkgcmV0dXJuIG51bGxcbiAgZGV0ID0gMS4wIC8gZGV0XG5cbiAgb3V0WzBdID0gIGEzICogZGV0XG4gIG91dFsxXSA9IC1hMSAqIGRldFxuICBvdXRbMl0gPSAtYTIgKiBkZXRcbiAgb3V0WzNdID0gIGEwICogZGV0XG5cbiAgcmV0dXJuIG91dFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLW1hdDIvaW52ZXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlXG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiXG4gICAgb3V0WzFdID0gYVsxXSAqIGJcbiAgICByZXR1cm4gb3V0XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLXZlYzIvc2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MlxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHlcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5XG4gICAgcmV0dXJuIG91dFxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC12ZWMyL3RyYW5zZm9ybU1hdDIuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLXZlYzMvY2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fSGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19TdGFjay5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX1VpbnQ4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2FwcGx5LmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXJyYXlNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hcnJheVB1c2guanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUZsYXR0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VGb3IuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlSGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VLZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZU1lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVBpY2suanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VQaWNrQnkuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlUmVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VVbmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY29weUFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2NvcHlPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY29yZUpzRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZmxhdFJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19nZXRSYXdUYWcuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2dldFZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19oYXNQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19oYXNoQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19oYXNoRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2hhc2hHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faGFzaEhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2hhc2hTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2lzS2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2lzS2V5YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faXNNYXNrZWQuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19saXN0Q2FjaGVHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbWFwQ2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbWFwQ2FjaGVTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19uYXRpdmVLZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbm9kZVV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDE0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX292ZXJBcmcuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zaG9ydE91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fc3RhY2tDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fc3RhY2tHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fc3RhY2tIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3N0YWNrU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zdHJpbmdUb1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL190b1NvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9jb25zdGFudC5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2ZsYXR0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9oYXNJbi5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvbWVtb2l6ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlUGljayA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrJyksXG4gICAgZmxhdFJlc3QgPSByZXF1aXJlKCcuL19mbGF0UmVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGljaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvcGljay5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL3N0dWJGYWxzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC90b1BsYWluT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL3RvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==